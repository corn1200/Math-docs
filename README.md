# Math-docs

# 목차
* [1. 벡터와 스칼라](#1-벡터와-스칼라)
    * [1.1. 벡터의 연산](#11-벡터의-연산)
    * [1.2. 벡터의 내적과 외적](#12-벡터의-내적과-외적)
    * [1.3. 스칼라 삼중곱](#13-스칼라-삼중곱)
    * [1.4. 벡터 삼중곱](#14-벡터-삼중곱)
* [2. 좌표계](#2-좌표계)
    * [2.1. 데카르트 좌표계](#21-데카르트-좌표계)
    * [2.2. 극좌표계](#22-극좌표계)
    * [2.3. 동차 좌표계](#23-동차-좌표계)
* [3. 피타고라스 정리](#3-피타고라스-정리)
* [4. 삼각비](#4-삼각비)
* [5. 삼각함수](#5-삼각함수)
    * [5.1. 삼각함수를 활용한 물체의 회전](#51-삼각함수를-활용한-물체의-회전)
    * [5.2. 삼각함수의 역함수](#52-삼각함수의-역함수)
    * [5.3. 삼각함수의 덧셈 정리](#53-삼각함수의-덧셈-정리)
* [6. 수와 집합](#6-수와-집합)
    * [6.1. 연산과 수의 구조](#61-연산과-수의-구조)
    * [6.2. 수의 표현](#62-수의-표현)
* [7. 함수](#7-함수)
    * [7.1. 함수의 개념과 종류](#71-함수의-개념과-종류)
    * [7.2. 합성 함수](#72-합성-함수)
    * [7.3. 항등함수와 역함수](#73-항등함수와-역함수)
    * [7.4. 곱집합을 활용한 좌표 평면으로의 확장](#74-곱집합을-활용한-좌표-평면으로의-확장)
* [8. 행렬](#8-행렬)
    * [8.1. 선형성](#81-선형성)
        * [8.1.1. 선형 함수](#811-선형-함수)
    * [8.2. 행렬의 기본 연산](#82-행렬의-기본-연산)
    * [8.3. 행렬의 설계](#83-행렬의-설계)
        * [8.3.1. 크기 변환행렬](#831-크기-변환행렬)
        * [8.3.2. 회전 변환행렬](#832-회전-변환행렬)
        * [8.3.3. 전단 변환행렬](#833-전단-변환행렬)
    * [8.4. 역행렬](#84-역행렬)
        * [8.4.1. 역행렬의 존재를 판별하는 행렬식](#841-역행렬의-존재를-판별하는-행렬식)
        * [8.4.2. 크기 변환행렬의 역행렬](#842-크기-변환행렬의-역행렬)
        * [8.4.3. 회전 변환행렬의 역행렬](#843-회전-변환행렬의-역행렬)
        * [8.4.4. 전단 변환행렬의 역행렬](#844-전단-변환행렬의-역행렬)
        * [8.4.5. 행렬 곱의 역행렬](#845-행렬-곱의-역행렬)
* [9. 아핀 공간](#9-아핀-공간)
    * [9.1. 이동 변환을 위한 아핀 공간](#91-이동-변환을-위한-아핀-공간)
    * [9.2. 아핀 공간의 구성 요소](#92-아핀-공간의-구성-요소)
    * [9.3. 아핀 결합](#93-아핀-결합)
    * [9.4. 선 그리기 알고리즘](#94-선-그리기-알고리즘)
        * [9.4.1. 벡터를 모니터의 점으로 표현](#941-벡터를-모니터의-점으로-표현)
        * [9.4.1. 라인 클리핑 알고리즘](#942-라인-클리핑-알고리즘)
* [10. 메시](#10-메시)
    * [10.1. 무게중심좌표](#101-무게중심좌표)
    * [10.2. 정점에 설정된 부가 정보의 활용](#102-정점에-설정된-부가-정보의-활용)
    * [10.3. 텍스처 매핑](#103-텍스처-매핑)
* [11. 게임 엔진](#11-게임-엔진)
    * [11.1. 게임 엔진의 구성 요소](#111-게임-엔진의-구성-요소)
        * [11.1.1. 씬의 구조](#1111-씬의-구조)
        * [11.1.2. 모델링 행렬의 설계](#1112-모델링-행렬의-설계)
        * [11.1.3. 로컬 공간과 로컬 축](#1113-로컬-공간과-로컬-축)
    * [11.2. 카메라 시스템](#112-카메라-시스템)
* [12. 오일러 각](#12-오일러-각)
    * [12.1. 오일러 각의 특징](#121-오일러-각의-특징)
    * [12.2. 짐벌락 현상](#122-짐벌락-현상)
    * [12.3. 회전 보간의 계산](#123-회전-보간의-계산)
* [13. 백페이스 컬링](#13-백페이스-컬링)
* [14. 원근 투영](#14-원근-투영)
    * [14.1. 원근 투영 변환의 원리](#141-원근-투영-변환의-원리)
    * [14.2. 깊이 값](#142-깊이-값)
* [15. 절두체](#15-절두체)
    * [15.1. 절두체 컬링](#151-절두체-컬링)
        * [15.1.1. 평면의 방정식](#1511-평면의-방정식)
        * [15.1.2. 평면의 방정식의 정규화](#1512-평면의-방정식의-정규화)
    * [15.2. 바운딩 볼륨](#152-바운딩-볼륨)
        * [15.2.1. 구 바운딩 볼륨의 판정](#1521-구-바운딩-볼륨의-판정)
        * [15.2.2. AABB와의 판정](#1522-aabb와의-판정)
    * [15.3. 삼각형 클리핑](#153-삼각형-클리핑)
* [16. 복소수](#16-복소수)
    * [16.1. 허수](#161-허수)
    * [16.2. 복소평면](#162-복소평면)
        * [16.2.1. 단위 복소수와의 곱](#1621-단위-복소수와의-곱)
        * [16.2.2. 켤레 복소수의 회전 변환](#1622-켤레-복소수의-회전-변환)
    * [16.3. 복소수와 행렬의 관계](#163-복소수와-행렬의-관계)
* [17. 오일러 공식](#17-오일러-공식)
    * [17.1. 자연지수함수](#171-자연지수함수)
        * [17.1.1. 무리수 e](#1711-무리수-e)

# 1. 벡터와 스칼라
## 벡터(vector)
- 기하학적으로 벡터를 방향을 가진 선분 즉, 화살표로 표현한다.
- 벡터의 속성은 '길이(혹은 크기)'와 '가리키는 방향'
- '위치'는 벡터의 속성이 아니다.    
따라서 다른 위치에 있더라도 동일한 길이와 방향을 가리키는 두 개의 벡터는 동일한 것으로 취급된다.    
예를 들어, 아래의 그림에서 벡터 u와 v는 동일하다.
- 크기와 방향을 모두 갖는 물리량을 모델링하는 데 유용하다.  
ex) 빛이 비추는 방향, 다각형의 방향, 3D 세계에서의 카메라가 보고 있는 방향 등

![벡터](/img/vector0.png)

보통 벡터를 표시할 때는 굵은 소문자를 이용하지만 굵은 대문자를 이용하는 경우도 있다.    
다음은 각각 2차원, 3차원, 4차원 벡터의 표시 예이다.     
혹은 화살표를 사용하여 표기하기도 한다: $\overrightarrow{a}$    
$u = (u_x, u_y), N = (N_x, N_y, N_z), c = (c_x, c_y, c_z, c_w)$

### 벡터의 크기 계산
기하학적으로 벡터의 크기는 방향을 가진 선분의 길이이다.     
벡터의 성분이 주어졌다고 할 때, 다음과 같은 식을 이용해 벡터의 크기를 대수학적으로 계산해낼 수 있다.    
$||u|| = \sqrt{u_x^2 + u_y^2 + u_z^2}$

ex) $u = (1,2,3)$과 $v = (1,1)$ 벡터의 크기를 구하라.   
$||u|| = \sqrt{1^2 + 2^2 + 3^2} = \sqrt{1 + 4 + 9} = \sqrt{14}$

![벡터](/img/vector1.png)

마찬가지로, 위의 식을 2차원으로 일반화하면 다음과 같이 $v$를 얻을 수 있다.  
$||v|| = \sqrt{1^2 + 1^2} = \sqrt{2}$

![벡터](/img/vector2.png)   
연관 내용: 피타고라스의 정리

### 영 벡터와 단위 벡터
영 벡터란 모든 성분에 0을 가진 것이다.  
영 벡터는 굵은 0으로 표시된다: $0 = (0, 0, 0)$

단위 벡터란 크기가 1인 벡터이다.    
곱셈에서, $1 * n = n$일 때 n에 어떤 수를 넣더라도 항상 n이 나오도록 하는 1을 곱셈에서의 항등수라고 한다.    
벡터에서도 값과 벡터가 곱해질 때 단위 벡터는 항등수에 해당한다. 
단위 벡터는 크기가 1이고 방향을 가지고 있으므로, 여기에 값을 곱해주면 방향은 같지만 크기가 다른 벡터를 마음대로 만들 수 있다.   
혹은 크기는 무시하고 방향만 나타내기 위해서 사용한다.

모든 벡터는 정규화(normalize) 과정을 거쳐 단위 벡터로 만들 수 있다.     
단위 벡터의 용도는 일반적으로 회전의 중심축으로써 사용되는 경우가 많다.     
그 외에도 삼각형면의 법선 벡터(normal vector) 역시 단위 벡터를 사용한다.    
법선 벡터란, 평면에 수직인 벡터이다.

![벡터](/img/vector3.png)

### 벡터의 정규화
벡터의 정규화란 벡터의 크기를 1로 만들어 단위 벡터가 되도록 하는 것이다.    
다음과 같이 벡터의 각 성분을 벡터의 크기로 나누면 정규화가 된다.    
단위 벡터는 위에 모자를 씌워 표기한다: $\hat{u}$    
$\hat{u} = \frac{u}{||u||} = (\frac{u_x}{||u||}, \frac{u_y}{||u||}, \frac{u_z}{||u||})$

ex) $u = (1,2,3)$ 벡터를 정규화하라.    
$\hat{u} = \frac{u}{\sqrt{14}} = (\frac{1}{\sqrt{14}}, \frac{2}{\sqrt{14}}, \frac{3}{\sqrt{14}})$

## 스칼라(scalar)
- 크기와 방향을 가지는 벡터의 대비되는 개념
- 단지 크기만 있는 물리량이다.
- 좌표계가 변환되어도 그에 따라 변화하지 않는 양, 단순히 '하나의 숫자'이다.

### 벡터와 스칼라의 연산
스칼라는 벡터와의 곱셈 연산을 통해 벡터의 크기를 조정하는 데 사용된다.  
스칼라 연산은 벡터의 방향에는 영향을 미치지 않으며 단지 벡터의 크기만을 바꿀 뿐이다.    
각 항에 스칼라를 곱해주면 된다.     
만약 음수를 이용하는 경우에는 벡터의 방향이 뒤집힌다.   
즉, 벡터에서 부호는 방향을 결정하는 역할을 한다.    
$ku = (ku_x, ku_y, ku_z)$

![벡터](/img/vector4.png)

게임에서 캐릭터를 이동시킬 때, 단위 벡터와 스칼라의 곱을 사용한다.  
캐릭터를 이동시킬 방향(단위 벡터)에 이동하고자 하는 거리(스칼라) 값을 곱하면, 캐릭터가 이동할 벡터를 구할 수 있다.

즉, 캐릭터의 위치 벡터에 이동 벡터를 더하여, 최종적으로 캐릭터가 이동될 위치를 구해 캐릭터를 그 위치로 이동시키면 된다.

![벡터](/img/vector5.png)

### 역벡터
역벡터란 크기는 같으나 방향이 서로 반대인 벡터를 말한다.    
역벡터는 벡터 앞에 -(음부호)를 붙여서 표시를 한다.  
-(음부호)의 역할은 벡터의 방향을 바꾸는 역할을 하며, 각 성분에 -1을 곱한 것과 같다.     
예를 들어 (1, 1) 벡터에 -1을 곱해주면 크기는 그대로지만 방향이 반대가 된다는 것을 아래 그림을 통해 알 수 있다.

![벡터](/img/vector6.png)

# 1.1. 벡터의 연산
### 벡터의 덧셈
대응되는 성분을 더하면 두 개의 벡터를 더할 수 있다.     
이때, 더하고자 하는 벡터는 반드시 동일한 차원을 가져야 한다.    
교환법칙과 결합법칙이 성립한다.     
$u + v = (u_x + v_x, u_y + v_y, u_z + v_z)$

교환법칙 성립: $u + v = v + u$      
결합법칙 성립: $(u + v) + w = u + (v + w)$

아래의 그림은 벡터의 덧셈의 기하학적 보간을 보여준다.

![벡터](/img/vector7.png)

### 벡터의 뺄셈
벡터의 덧셈과 비슷하게 벡터의 대응되는 성분을 빼는 방법으로 벡터의 뺄셈을 수행할 수 있다.   
벡터는 반드시 동일한 차원을 가져야 한다.    
$u - v = u + (-v) = (u_x - v_x, u_y - v_y, u_z - v_z)$

아래의 그림은 벡터 뺄셈의 기하학적 보간을 보여주고 있다.    
게임에서는 '내'가 '타겟'을 보는 방향을 구하고자 할 때 벡터의 뺄셈이 유용하게 사용된다.

![벡터](/img/vector8.png)

### 벡터의 분해
하나의 벡터는 두 개의 성분 벡터로 분해될 수 있다.

![벡터](/img/vector9.png)

위 그림에서 벡터 A는 벡터 B와 벡터 C의 합으로 분해되어진다.     
벡터 B와 벡터 C의 합이 결국 A 벡터이기 때문이다.

이렇게 벡터를 성분 분해하는 이유는 벡터 연산을 좀 더 효율적이고 쉽게 하기 위함이다.     
예를 들어 2차원 벡터끼리 연산을 할 때 각 벡터를 x, y 축의 두 성분 벡터로 분해하여 연산하면 다음과 같다.

![벡터](/img/vector10.png)

벡터의 연산이 복잡해질 수록 벡터 분해에 대한 이해는 필수적이다.         
벡터 내적의 이해와도 관련되어 있다.

# 1.2. 벡터의 내적과 외적
## 내적
- 내적은 벡터 대수학에서 정의하는 두 가지 곱셈 중 하나이다.
- 두 벡터 사이의 연산이지만, 내적의 결과는 벡터가 아닌 스칼라 값이다.
- 벡터의 내적을 구하는 공식은 다음과 같다.

1. $u * v = u_xv_x + u_yv_y + u_zv_z$
2. $u * v = ||u||||v|| \cos \theta$

1번은 두 벡터의 각은 모르고 벡터의 성분만을 알고 있을 경우 사용할 수 있는 공식이며, 2번은 두 벡터의 각과 크기를 알고 있을 경우 사용할 수 있는 공식이다.

1번의 식은 분명한 기하학적 의미를 보여주고 있지 않다.   
코사인 법칙을 이용하면 $u * v = ||u||||v||$의 관계를 발견할 수 있으며, 이는 두 벡터 간의 내적이 벡터 크기 배율을 가진 벡터 간 각도의 코사인임을 알 수 있다.

1번 공식을 2차원 벡터를 예로 들어 그림으로 표현하면 다음과 같다.

![벡터](/img/vector11.png)

2번 공식을 2차원 벡터를 예로 들어 그림으로 표현하면 다음과 같다.

![벡터](/img/vector12.png)

벡터 D의 크기는 A 벡터의 크기에 $\cos \theta$를 곱한 것이다.    
$||D|| = ||A|| * \cos \theta$   
여기서 A의 크기가 아닌, A를 분해한 벡터 D의 크기를 곱해주는 이유는 B 벡터에 실제로 영향을 주는 벡터가 D이기 때문이다.   
한편 벡터 C는 벡터 B의 방향으로 어떤 영향도 주지 못하기 때문에, 내적 계산에서 무시한다.

### 내적의 특성
$u$와 $v$가 모두 단위 벡터인 경우 $u * v$는 두 벡터 간 각도의 코사인이 된다.

![벡터](/img/vector13.png)

만약 $u * v = 0$ 이라면, 두 벡터는 직각이다.     
만약 $u * v > 0$ 이라면, 두 벡터 간의 각도 $\theta$는 90도($\frac{\pi}{2}$) 보다 작다.      
만약 $u * v < 0$ 이라면, 두 벡터 간의 각도 $\theta$는 90도($\frac{\pi}{2}$) 보다 크다.

![벡터](/img/vector14.png)

또한, 자기자신과 내적하면 자기자신 크기만큼의 제곱이다.     
자기자신과 이루는 각도는 0도 이며, $\cos 0 = 1$이기 때문에 결과적으로 같은 벡터 2개를 내적하면 제곱이다.

### 벡터의 내적 활용
첫째, 두 벡터 사이각을 내적을 통해 구할 수 있다.    
두 벡터의 성분을 알고 있다면, 크기를 알 수 있고 내적 계산을 이용해 $\arccos \theta$를 통해 구할 수 있다.
$$\cos \theta = \frac{a * b}{||a||||b||} = \frac{a_xb_x + a_yb_y + a_zb_z}{||a||||b||}$$
$$\theta = \arccos(\frac{a * b}{||a||||b||})$$

![벡터](/img/vector15.png)

둘째, 어떤 벡터 a에서 수직으로 내린 길이(투영 길이)를 구할 때 내적을 사용한다.

![벡터](/img/vector16.png)

위의 그림에서 벡터 a의 투영 길이를 구하고자 할 때는 벡터 b의 단위 벡터를 이용한다.  
벡터 b의 단위 벡터의 길이는 1이며 내적 공식에 적용하면 $a * b = ||a|| * 1 * \cos \theta$가 되어 결국 투영 길이는 $||a|| \cos \theta$가 된다.   
또는 $a_xb_x + a_yb_y + a_zb_z$에서 벡터 b의 단위 벡터를 적용하면 된다.     
투영 길이는 곧 벡터 b의 방향으로 얼마만큼 뻗어있는지 그 정도(크기)를 의미한다.

셋째, '나'의 방향 벡터가 있을 때 적이 주인공의 앞에 있는지 뒤에 있는지 판단할 때 사용된다.      
적의 위치에서 '나'의 위치를 뺀 벡터 즉, 내가 적을 바라보는 방향 벡터와 나의 Forward 벡터 간 내적을 했을 때, 각이 -90도 ~ 90도 사이에 있으면($\cos \theta$가 양수이면) 적이 나의 앞에 있는 것이고, 각이 90도 ~ 270도 사이에 있으면($\cos \theta$가 음수이면) 적이 나의 뒤에 있는 것이다.

![벡터](/img/vector17.png)

넷째, 적이 '나'의 시야각 안에 들어와 있는지 아닌지 판단할 때 사용된다.    
'나'의 시야각을 $\theta$라고 하면, Forward 벡터와 적과 '적의 위치에서 나의 위치를 뺀' 벡터 A 간의 내적을 통해 나오는 각도 값이 $\frac{\theta}{2}$를 넘지 않아야 시야각 내에 존재한다는 것을 판별할 수 있다.

![벡터](/img/vector18.png)

다섯째, 점 A와 평면 S 간의 최단 거리를 구할 때 내적을 이용해 구할 수 있다.  
(B는 평면 위의 점, d는 점 A와 평면 S 간의 최단 거리)    
$(A - B) * n = d$

![벡터](/img/vector19.png)

단면으로 표현하면 아래와 같다.

![벡터](/img/vector20.png)

벡터 BA와 평면의 법선 벡터(normal vector)와 내적을 구하면, $||BA|| * \cos \theta$값이 된다.     
이때, 평면의 법선 벡터는 정규화된 단위 벡터라고 가정한다.   
'투영 길이'를 떠올려보면 점 A와 평면 S 간의 최단거리 d가 됨을 알 수 있다.   
만약, 거리값이 0이면 A는 평면 위의 점이 된다.

## 외적
- 벡터 수학이 정의하는 두번째 형식의 곱은 외적이다.
- 스칼라로 계산되는 내적과는 달리, 외적의 결과는 또 다른 벡터이다.
- a와 b 두 벡터의 외적을 수행하면 다른 벡터 p를 얻으며, 이는 a와 b에 서로 지각을 이룬다.    
즉, p는 a에 직각이며, p는 b에 직각이다.
- 벡터의 외적을 구하는 공식은 다음과 같다.

1. $p = a * b = \hat{n}||a||||b|| \sin \theta$
2. $p = a * b = [(a_yb_z - a_zb_y), (a_zb_x - a_xb_z), (a_xb_y - a_yb_x)]$

1번의 식을 자세히 살펴보면, n은 방향 벡터이고, 나머지는 값이기에 결과는 벡터라는 것을 알 수 있다.   
또한, 외적 벡터의 크기는 두 벡터의 크기에 $\sin \theta$를 곱한 값과 같음을 알 수 있다.

![벡터](/img/vector21.png)

2번의 식은 다음과 같이 행렬식(Determinant)를 이용하여 간단히 쓸 수 있다.    
($i = (1,0,0), j = (0,1,0), k = (0,0,1)$)

![벡터](/img/vector22.svg)

$a * b$ 외적 벡터의 방향은 수학에서는 오른손 좌표계를 사용하며, 게임은 엔진이 사용하는 좌표계에 따라 다르다. (OpenGL에서는 오른손 좌표계, Unity나 Direct3D에서는 왼손 좌표계)   
예를 들어, Direct3D는 왼손 좌표계를 사용하므로 왼손법칙에 따라 외적 벡터의 방향을 계산하지 않고도 알 수 있다.   
왼손으로 첫번째 벡터 방향으로 손바닥을 맞춘 후, 두번째 벡터 방향으로 구부렸을 때 엄지 손가락이 가리키는 방향이 바로 외적으로 리턴되는 벡터의 방향이 된다.

![벡터](/img/vector23.png)

### 외적의 특성
- 외적의 결과는 내적과 달리 벡터이기 때문에 방향과 크기를 동시에 가지게 된다.   
방향: $u \times v \perp u$ 이고 $u \times v \perp v$ 이다. 즉, 두 벡터 $u$와 $v$ 에 동시에 수직이다.    
크기: 외적 벡터의 크기는 $u$ 와 $v$를 변으로 하는 평행사변형의 넓이이다.

![벡터](/img/vector24.png)

외적도 내적과 마찬가지로 주로 단위 벡터와 함께 사용되는데, 예를 들어 위의 그림에서 u와 v가 단위 벡터라면, u와 v의 외적 결과값인 벡터 p의 크기로 u와 v의 사이각을 판단할 수 있다.    
벡터 p의 크기가 1이라면 u와 v를 연결해서 만든 도형이 가로세로가 1인 정사각형임을 알 수 있고, 결국 벡터 u와 벡터 v가 수직임을 알 수 있다.

- 내적과 달리 교환 법칙이 성립하지 않으며, 순서를 바꾸면 반대 방향의 벡터가 나온다: $u \times v = -(u \times v)$
- 내적과 동일하게 분배 법칙은 성립한다: $u \times (v + w) = (u \times v) + (u \times w)$
- 두 벡터가 모두 영벡터가 아닐 때, $u \times v = 0$인 것은 $u$와 $v$가 서로 평행인 것과 동치이다.   
즉, 두 벡터가 평행하면 크기는 0이다. $(\sin \theta = 0)$

![벡터](/img/vector25.png)

### 벡터의 외적 활용
첫째, 평면의 법선 벡터를 구할 때 사용한다.  
삼각형의 세 점을 알고 있다고 할 때, 벡터 2개를 구할 수 있게 되고 그 두 벡터를 외적하면 해당 삼각형이 속한 평면의 법선 벡터를 구할 수 있다.

![벡터](/img/vector26.png)

입체적으로 표현하면 아래 그림과 같다.

![벡터](/img/vector27.png)

또한, 삼각형의 넓이를 구할 때도 외적을 사용할 수 있다.

![벡터](/img/vector28.png)

둘째, 평면이 앞면인지 뒷면인지를 알아낼 수 있고, 따라서 컬링(culling)할 때 사용된다.    
법선 벡터가 한 평면의 뒤를 가리킨다면, 뒷면을 화면 출력에서 제외되는 면이 된다.     
이와 같이 보이지 않는 뒷면을 화면 출력에서 제외시키는 것을 백페이스 컬링(backface culling)이라고 하며, Direct3D에서는 컬링 옵션에 따라 출력에서 제외시키거나 출력하게 할 수 있다.   
컬링의 기준이 되는 것이 바로 이 법선 벡터의 방향이다.   
eye 벡터와 평면의 법선 벡터의 내적으로부터 얻는 $\cos \theta$ 값을 사용하면 앞과 뒤를 판단할 수 있다.

![벡터](/img/vector29.png)

셋째, 점과 직선사이의 거리를 구할 때 사용된다.

![벡터](/img/vector30.png)

직선 S의 위의 점 B와 C를 임의로 선택한다.   
$BA$ 와 $BC$ 벡터를 만들어, 평행사변형의 높이를 구하는 방법을 응용해 문제를 풀 수 있다.

넷째, 빛의 방향과 평면의 법선 사이의 각도를 이용해 평면에 적용될 빛의 영향을 결정하게 된다.     
만약 빛을 평면에 비추고 싶다면, 평면을 이루는 각 벡터 정보에는 법선 벡터에 대한 정보가 반드시 있어야한다.

# 1.3. 스칼라 삼중곱
스칼라 삼중곱(Scalar Triple Product)은 세 개의 벡터로 이루어진 연산으로, 벡터의 선형 독립성과 평면 내에서의 벡터들의 구성에 관한 정보를 제공하는 수학적인 개념이다.     
스칼라 삼중곱은 외적(Cross Product)과 비슷한 개념이며, 벡터의 곱에 대한 확장된 형태이다.

세 개의 벡터 A, B, C의 스칼라 삼중곱은 다음과 같이 표현된다:    
$(A \times B) \cdot C$

여기서 'x'는 벡터의 외적을 나타내며, '.'는 벡터의 내적을 나타낸다.

스칼라 삼중곱의 값은 실수(스칼라)이며 다음과 같이 계산된다:     
$(A \times B) \cdot C = (A \times B) \cdot C = A \cdot (B \times C)$

스칼라 삼중곱은 다음과 같은 의미와 성질을 가진다:

1. 스칼라 삼중곱의 값이 0인 경우, 벡터 A, B, C는 평면 상에 존재하는 것을 나타낸다.  
이는 A x B가 C에 수직인 경우, 또는 C가 A와 B가 만드는 평면 상에 위치하는 경우이다.
2. 스칼라 삼중곱의 값이 양수인 경우, 벡터 A, B, C가 오른손 좌표계 기준으로 시계 방향으로 정렬되어 있는 것을 나타낸다.
3. 스칼라 삼중곱의 값이 음수인 경우, 벡터 A, B, C가 오른손 좌표계 기준으로 반시계 방향으로 정렬되어 있는 것을 나타낸다.

스칼라 삼중곱은 주로 벡터 공간 상의 위치와 방향을 분석하는 데 사용되며, 평면의 정렬과 선형 독립성 판단 등에 활용된다.

# 1.4. 벡터 삼중곱
벡터 삼중곱(Vector Triple Product)은 세 개의 벡터로 이루어진 연산으로, 벡터의 선형 독립성과 평면 내에서의 벡터들의 구성에 관한 정보를 제공하는 수학적인 개념이다.   
벡터 삼중곱은 외적(Cross Product)과 스칼라 삼중곱(Scalar Triple Product)을 포함하는 개념으로, 벡터 간의 곱셈에 대한 확장된 형태이다.

세 개의 벡터 A, B, C의 벡터 삼중곱은 다음과 같이 표현된다:      
$A \times (B \times C)$

벡터 삼중곱의 계산은 외적을 두 번 적용하여 이루어진다.  
먼저 B와 C의 외적을 계산하고, 그 결과인 벡터를 A와 외적하는 것이다.

벡터 삼중곱의 값은 벡터이며, 다음과 같이 계산된다:  
$A \times (B \times C) = (A \cdot C)B - (A \cdot B)C$

벡터 삼중곱은 다음과 같은 의미와 성질을 가진다:

1. 벡터 삼중곱의 값은 초기 벡터 A, B, C의 선형 독립성에 영향을 준다.    
즉, 벡터 삼중곱의 값이 0인 경우, A, B, C가 평면 상에 존재하는 것을 나타내며, 선형 독립한 경우라면 평면 상에 존재하지 않는다.
2. 벡터 삼중곱의 값은 벡터 A, B, C가 A와 B 사이에 위치한 평면을 따라 방향이 결정된다.   
벡터 삼중곱의 값이 양수이면 B와 C의 외적 방향과 같다.   
벡터 삼중곱의 값이 음수이면 B와 C의 외적 방향의 반대 방향을 가진다.
3. 벡터 삼중곱은 회전 행렬과 관련된 연산 등에서 사용될 수 있다.

벡터 삼중곱은 벡터의 위치와 방향을 다루는데 사용된다.

# 2. 좌표계
좌표계는 크게 2D 좌표계와 3D 좌표계로 나눌 수 있다.     
2D 좌표계는 모니터 좌표계와 동일하며 x, y 좌표를 가진다.    
3D 좌표계는 공간상의 한 점을 나타내기 위해 x, y, z 좌표로 위치를 나타낸다.  
3D 프로그래밍은 3D 좌표계를 사용하며 Direct3D는 3D 공간상의 정점들을 2D 좌표계로 바꾸어 출력하게 된다.  

### 왼손 좌표계 & 오른손 좌표계
두 좌표계의 차이는 +z축이 진행하는 방향에 있다.     
왼손 좌표계에서의 +z축은 화면 안쪽으로 향하며, 오른손 좌표계에서는 화면 바깥쪽으로 향한다.  
Direct3D와 Unity3D는 왼손좌표계를 사용한다.

![좌표계](/img/coordinate0.png)

2차원에서 도형은 한 점(원점 또는 임의의 위치)을 기준으로 회전된다.  
하지만 3차원에서는 하나의 축(x, y, z축 혹은 임의의 축)을 기준으로 개체가 회전된다.

왼손 좌표계에서 회전 방향은 각 축에 대해 시계방향(clockwise)이다.   
왼주먹을 말아쥐고 엄지를 들었을 때 엄지방향이 회전축 방향, 말아쥔 손가락 방향이 회전방향임을 알 수 있다.

오른손 좌표계에서 회전 방향은 각 축에 대해 반시계방향(counterclockwise)이다.    
오른주먹을 말아쥐고 엄지를 들었을 때 엄지방향이 회전축 방향, 말아쥔 손가락 방향이 회전방향임을 알 수 있다.

![좌표계](/img/coordinate1.png)

# 2.1. 데카르트 좌표계
데카르트 좌표계는 수학에서 점들의 위치를 숫자의 조합으로 나타내는 방법 중 하나로, 평면이나 공간 상의 점들을 좌표로 표현할 수 있는 체계이다.     
이는 수학자 르네 데카르트에 의해 개발된 것으로, 대부분의 수학 분야에서 사용되는 중요한 개념 중 하나이다.

데카르트 좌표계는 평면과 공간을 직교하는 좌표 축들로 나타내며, 각 축은 서로 수직이며 원점을 공유한다.   
이 좌표축은 수평축을 x축, 수직축을 y축이라고 하는 경우가 많으며, 공간을 다루는 경우에는 추가적으로 수직축을 z축으로 추가할 수 있다.     

2차원 데카르트 좌표계:

- x축과 y축으로 구성된다.
- 각 점은 (x,y)와 같은 숫자 쌍으로 표현된다.
- 원점 (0,0)은 x축과 y축이 교차하는 지점이다.

3차원 데카르트 좌표계:

- x축, y축, z축으로 구성된다.
- 각 점은 (x,y,z)와 같은 숫자 세 개의 조합으로 표현된다.
- 원점 (0,0,0)은 세 축이 모두 교차하는 지점이다.

데카르트 좌표계를 사용하면 공간 상의 점들을 좌표로 표현하고, 이를 통해 거리, 각도, 면적 등을 계산하거나 문제를 해결할 수 있다.  
예를 들어, 두 점 간의 거리는 피타고라스의 정리를 사용하여 계산할 수 있다.

# 2.2. 극좌표계
삼각함수의 극좌표계는 데카르트 좌표계와는 다른 방식으로 점들의 위치를 나타내는 좌표 체계이다.   
극좌표계는 각도와 반지름의 조합으로 점의 위치를 나타내는 방식으로, 원의 중심으로부터의 거리와 각도로 점을 표현한다.     
이는 주로 원형 대칭, 원의 반지름과 각도와 관련된 문제에서 사용되며, 물체의 회전 운동과 같은 문제에도 적용될 수 있다.

극좌표계에서 한 점은 $(r, \theta)$로 나타내며, 여기서 $r$은 극좌표에서 원의 중심으로부터의 거리(반지름), $\theta$는 각도이다.   
각도는 라디안 형태로 표현된다.

데카르트 좌표계와 극좌표계 간의 변환은 다음과 같이 이루어진다:

$x = r \cdot \cos(\theta)$  
$y = r \cdot \sin(\theta)$

여기서 (x,y)는 데카르트 좌표계의 좌표이며, $(r, \theta)$는 극좌표계의 좌표이다.

### 예시:
만약 $(r, \theta) = (3, \pi/4)$라면, 이는 극좌표계에서 반지름이 3이고 각도가 $\pi/4$인 점을 나타낸다.   
데카르트 좌표계로 변환하며:

$x = 3 \cdot \cos(\pi/4) = \frac{3}{\sqrt{2}} \approx 2.1213$   
$y = 3 \cdot \sin(\pi/4) = \frac{3}{\sqrt{2}} \approx 2.1213$

따라서, 데카르트 좌표계에서의 좌표는 (2.1213, 2.1213)이다.

극좌표계는 특히 원 대칭과 각도 관련 문제에서 데카르트 좌표계보다 간단하고 편리하게 사용된다.    
또한 물체의 위치와 회전 운동을 설명할 때도 적용될 수 있다.

# 2.3. 동차 좌표계
동차 좌표계(Homogeneous Coordinates)는 컴퓨터 그래픽스와 컴퓨터 비전 분야에서 매우 중요한 개념 중 하나이다.     
이 좌표계는 2D와 3D 공간에서 점, 벡터 및 변환을 표현하는 데 사용되며 다양한 그래픽스 및 비전 연산을 효율적으로 수행하는 데 도움이 된다.

동차 좌표계의 주요 특징과 개념을 설명한다:

1. 확장된 좌표 표현: 동차 좌표계는 일반적인 카르테시안 좌표계(Cartesian Coordinates)와는 달리 좌표를 추가로 하나 더 갖는다.     
2D에서는 보통 (x, y, w)로 표현하고, 3D에서는 (x, y, z, w)로 표현한다.   
여기서 w는 일반적으로 1로 설정되며, 때로는 다른 값으로 설정되기도 한다.
2. 점과 벡터 표현: 동차 좌표계에서는 점과 벡터를 동일한 방식으로 표현할 수 있다.    
예를 들어, (x, y, 1)은 2D 점을 나타내고, (x, y, 0)은 2D 벡터를 나타낸다.
3. 변환 표현: 동차 좌표계에서 변환(이동, 회전, 확대/축소 등)을 매우 효율적으로 나타낼 수 있다.  
특히, 변환 행렬의 마지막 행이 (0, 0, 0, 1)로 설정되면 이 행렬은 순수한 기하학적 변환이 아니라 점의 위치를 옮기는 변환을 나타낸다.   
4. 원근 투영: 동차 좌표계는 원근 투영 변환을 쉽게 나타낼 수 있는데, 이것은 3D 공간에서의 객체를 2D 화면에 투영하는 데 필요한 것이다.    
원근 투영 변환을 행렬로 표현할 때, 동차 좌표계가 편리하게 사용된다.
5. 점의 동질성: 동차 좌표계에서 (x, y, w)와 (2x, 2y, 2w)는 동일한 점을 나타낸다.    
이러한 특성을 이용하여 정규화(normalization)와 연산을 더욱 효율적으로 수행할 수 있다,

동차 좌표계는 컴퓨터 그래픽스에서 변환 및 투영 연산을 표현하고 수행하는 데 중요한 개념으로 활용된다.    
3D 그래픽스에서는 특히 투영 변환과 카메라 시스템에서 많이 사용된다.

# 3. 피타고라스 정리

![피타고라스](/img/pytha0.svg)      
$a^2 + b^2 = c^2$   
직각삼각형에서 빗변의 길이의 제곱은 나머지 두 변의 길이를 제곱한 뒤 더한 것과 같다.

직각삼각형의 세 변의 길이를 각각 a, b, c 라 하고 변 a, b 사이 각도가 직각을 이룰 때, 즉 변 c가 빗변일때 $a^2 + b^2 = c^2$가 성립함을 뜻한다.

### 유클리드의 증명법

![피타고라스](/img/pytha1.gif)

위의 그림과 같이 $\angle C = 90^\circ$인 직각삼각형 ABC 에 대하여 세 변의 길이를 각각 한 변의 길이로 하는 정사각형 ADEB, ACHI, BFGC를 그린다.   
점 C에서 변 AB에 내린 수선의 발을 M, 그 연장선과 변 DE와 만나는 점을 N이라고 하자.      
이 때   
1. $\Box ACHI = 2 \triangle ACI$   

또, 밑변의 길이와 높이가 각각 같으므로,     

2. $\triangle ACI = \triangle ABI$

두 변의 길이와 그 끼인각의 크기가 각각 같으므로,    

3. $\triangle ABI \equiv \triangle ADC$    

밑변의 길이와 높이가 각각 같으므로,     

4. $\triangle ADC = \triangle ADM$     
5. $\Box ADNM = 2 \triangle ADM$   

(1), (2), (3), (4), (5)에서     

6. $\Box ACHI = \Box ADNM$  

같은 방법으로

7. $\Box ACHI = \Box ADNM$

(6), (7)에서    
$\Box ADEB = \Box ACHI + \Box BFGC$     
$\therefore \overline{AB}^2 = \overline{BC}^2 + \overline{BC}^2$

### 바스카라의 증명법

![피타고라스](/img/pytha2.png)

정사각형 ABCD를 기준으로, 대각선이 c가 되는 직각 삼각형을 그린다.   

그러면 삼각형 ABE와 같은 모양이 된다.   
그리고, 각 모서리를 기준으로 돌려가면서 배치하면, 가운데 정사각형 EFGH를 남겨놓는 모양이 된다.

넓이를 비교하면,
- S1 = 전체 정사각형(ABCD)의 넓이 = $c \times c = c^2$
- S2 = 부분 도형들의 넓이의 함 = $\triangle ABE + \triangle BCF + \triangle GCD + \triangle AHD + \Box EFGH = 4 \times \frac{1}{2} \times a \times b + (b - a)^2$

S1 = S2 이므로,     
$c^2 = 2ab + b^2 - 2ab + a^2$   
$c^2 = a^2 + b^2$   
$a^2 + b^2 = c^2$

# 4. 삼각비

직각삼각형의 세 변의 길이 중 두 변의 길이간의 비례 관계를 나타내는 값이다.  
일반적으로 비례 관계는 분수로 나타낸다.     
또한 $\sin$과 $\cos$은 반비례한다.  

항상 빗변의 길이를 나눠야 될 물리량으로 생각하면 직관적으로 적용할 수 있다.     
밑변의 길이에서 나누면 코사인(cosine), 높이에서 나누면 사인(sine)이라고 한다.

![삼각비](/img/triratios0.webp)

엄밀하게는 직각삼각형에 대해 sine, cosine, tangent를 다음과 같이 정의한다.  
$$\sin A = \frac{a}{h}$$
$$\cos A = \frac{b}{h}$$
$$\tan A = \frac{a}{b}$$

그리고 이들을 역수로서 cosecant, secant, cotangent 함수를 다음과 같이 정의한다.
$$\csc A = \frac{1}{\sin A} = \frac{h}{a}$$
$$\sec A = \frac{1}{\cos A} = \frac{h}{b}$$
$$\cot A = \frac{1}{\tan A} = \frac{b}{a}$$

# 5. 삼각함수
삼각비에서 쓰이는 정의역을 예각($0^\circ$ 에서 $90^\circ$ 사이의 각)에서 일반각(기존의 예각은 물론 예각이 아닌 각까지 포함하는 더 넓은 개념)으로 확장시킨 것을 삼각함수라고 한다.

### 일반각과 삼각비
일반각을 정의하는 방법에는 도($^\circ$)를 단위로 하는 육십분법과 라디안(rad)을 단위로 하는 호도법이 있다.

- 육십분법(단위: $^\circ$)은 시초선을 기준($0^\circ$)으로 하여 1회전을 $360^\circ$로 정의하는 각이다.
- 호도법(단위: rad)은 부채꼴에서 중심각의 크기와 호의 길이가 반지름에 비례한다는 특징과, '원주가 지름의 $\pi$배(원주가 반지름의 $2\pi$배)'라는 성질을 이용하여 정의되는 각이다. (차원이 없다.)

### 좌표와 원으로 정의하기
![삼각함수](/img/trifunc0.svg)

좌표평면 상 원점 $O$가 중심인 단위원을 고려하자.    
단위원 위의 한 점 $P(x, y)$에 대해여 $x$축의 양의 방향을 시초선으로 잡는다.     
$O$를 중심으로 시초선에서 반시계 방향 회전을 각의 양의 방향으로 잡고, 그 각의 크기를 $\theta$라고 하면, 다음으로 정의한다.
$$\sin \theta := y$$
$$\cos \theta := x$$
$$\tan \theta := \frac{y}{x}\quad (x \neq 0)$$

동경이 몇 사분면에 위치하는지에 따라 삼각함수의 부호는 달라진다.

|동경의 위치|1사분면|2사분면|3사분면|4사분면|
|---|---|---|---|---|
|사인의 부호|$+$|$+$|$-$|$-$|
|코사인의 부호|$+$|$-$|$-$|$+$|
|탄젠트의 부호|$+$|$-$|$+$|$-$|

$\theta$가 예각일 때, 위의 관계식은 빗변의 길이가 1인 직각삼각형에서 삼각비를 정의했던 것과 완전히 같다.    
차이점은 (0 또는 음수가 될 수 없는)'길이' 개념에서 벗어나 '좌표'를 이용하기 때문에 직각삼각형에 구애받을 필요가 없고, 따라서 $\theta$가 일반각으로 확장된다.

다음과 같이 삼각함수의 역수를 정의한다.
$$\sec \theta := \frac{1}{\cos \theta} = \frac{1}{x} \quad (x \neq 0)$$
$$\csc \theta := \frac{1}{\sin \theta} = \frac{1}{y} \quad (y \neq 0)$$
$$\cot \theta := \frac{1}{\tan \theta} = \frac{x}{y} \quad (y \neq 0)$$

각각 '시컨트', '코시컨트', '코탄젠트'라 읽는다.     
또, 코시컨트는 $\cosec x$로 쓰기도 한다.

좌표평면 상 원점 $O$가 중심이고, 반지름이 $r$인 원 위의 점 $(x, y)$에 대해서도 동일한 방법으로 정의가 가능하며, 아래와 같다.
$$\sin \theta := \frac{y}{r}$$
$$\cos \theta := \frac{x}{r}$$
$$\tan \theta := \frac{y}{x}$$

주의해야 할 것은 거듭제곱 꼴로 나타낸 경우, 예를 들어 $\sin^n \theta$, 그것은 $n$번 함수를 합성한 것이 아닌 함숫값의 $n$제곱의 값을 의미한다.   
즉, $\sin^2 \theta = (\sin \theta)^2 \neq \sin(\sin \theta)$

# 5.1. 삼각함수를 활용한 물체의 회전
삼각함수는 물체의 회전과 같은 주기적인 운동을 모델링하고 분석하는 데 매우 유용하게 사용된다.    
물체의 회전은 주기적으로 반복되는 움직임이므로, 삼각함수의 주기성과 파동의 특성을 활용하여 설명할 수 있다.

회전 운동의 주요 특성을 삼각함수를 통해 설명하는 데에는 주로 사인 함수와 코사인 함수가 사용된다.

### 사인 함수와 코사인 함수의 활용:
1. 사인 함수 (Sine Function): 사인 함수는 주기적인 진동을 나타내는데 사용된다.      
물체가 주기적으로 왕복하거나 진동할 때 사인 함수가 적용될 수 있다.      
예를 들어, 시계 바늘이나 그림자의 움직임과 같이 주기적으로 변화하는 움직임은 사인 함수를 통해 모델링할 수 있다.
2. 코사인 함수 (Cosine Function): 코사인 함수도 사인 함수와 마찬가지로 주기적인 운동을 나타내는 데 사용된다.    
코사인 함수는 움직임의 초기 위상을 나타내거나, 사인 함수와 함께 사용하여 복잡한 주기 운동을 설명하는 데 활용된다.

### 각도와 시간의 관계:
물체의 회전 운동을 설명할 때는 일반적으로 각도와 시간의 관계를 사용한다.    
각도는 물체가 회전한 정도를 나타내며, 시간은 회전이 진행되는 동안의 흐름을 나타낸다.    
각도를 라디안으로 표현하면 수학적인 계산이 더 편리해지며, 이를 통해 각도와 삼각함수를 연결할 수 있다.

# 5.2. 삼각함수의 역함수
삼각함수의 역함수는 원래의 삼각함수 함수들의 역전된 동작을 나타내는 함수이다.   
각각의 삼각함수에 대해 역함수가 존재하며, 역함수는 원래 함수의 출력값을 입력값으로 사용하여 원래의 입력값을 찾아내는 역할을 한다.   
역함수는 각도나 비율과 같은 삼각함수의 입력값을 구할 때 유용하게 사용된다.

1. 사인 함수의 역함수 (Arcsine, asin):
사인 함수의 역함수는 주어진 숫자의 사인 값을 입력으로 받아 그에 해당하는 각도를 출력으로 내놓는다.  
일반적으로 arcsin 또는 asin으로 표기된다.   
즉, $\sin(\theta) = x$ 일 때, $\theta = \arcsin(x)$이다.    
주의할 점은 역함수의 출력은 $-\pi/2$에서 $\pi/2$ 범위에 제한되어 있다.
2. 코사인 함수의 역함수 (Arccosine, acos):  
코사인 함수의 역함수는 주어진 숫자의 코사인 값을 입력으로 받아 그에 해당하는 각도를 출력으로 내놓는다.      
일반적으로 arccos 또는 acos로 표기된다.     
즉, $\cos(\theta) = x$ 일 때, $\theta = \arccos(x)$이다.    
역함수의 출력은 0에서 $\pi$ 범위에 제한되어 있다.
3. 탄젠트 함수의 역함수 (Arctangent, atan):     
탄젠트 함수의 역함수는 주어진 숫자의 탄젠트 값을 입력으로 받아 그에 해당하는 각도를 출력으로 내놓는다.  
일반적으로 arctan 또는 atan로 표기된다.     
즉, $\tan(\theta) = x$ 일 때, $\theta = \arctan(x)$이다.    
역함수의 출력은 $-\pi/2$에서 $\pi/2$ 범위에 제한되어 있다.

각 역함수의 범위에는 주의해야 하며, 일부 역함수 값은 다른 값으로 매핑될 수 있기 때문에 주의 깊게 사용해야 한다.     
역함수는 삼각함수의 역전 동작을 반대로 해석하거나, 각도를 계산하는 데 사용할 수 있다.

### 예시:
움직이는 바닥에 그림자가 떨어지는 상황을 가정해본다.    
물체의 회전에 의해 그림자의 길이가 주기적으로 변하는 경우, 사인 함수를 사용하여 그림자의 길이와 시간의 관계를 표현할 수 있다.   
그림자의 길이는 각도의 변화와 관련이 있으며, 각도와 시간의 관계를 삼각함수로 표현하여 회전 운동을 모델링할 수 있다.

이와 같이 삼각함수는 회전 및 주기적인 운동을 수학적으로 모델링하고 분석하는 데 사용되며, 물리학, 공학, 컴퓨터 그래픽스 등 다양한 분야에서 활용된다.

# 5.3. 삼각함수의 덧셈 정리
삼각함수의 덧셈 공식은 두 개의 각에 대한 삼각함수 값을 더할 때 사용되는 공식이다.   
이 공식을 사용하면 두 각의 삼각함수 값을 더하거나 빼는 것을 더 쉽게 계산할 수 있다.     
주로 삼각함수 값을 합치거나 분해하는 데 사용되며, 삼각형의 변의 길이나 각의 관계를 계산하는 데에도 활용된다.

주요한 삼각함수의 덧셈 공식은 다음과 같다:

1. 사인 함수의 덧셈 공식:   
$\sin(\alpha + \beta) = \sin(\alpha) \cos(\beta) + \cos(\alpha) \sin(\beta)$
2. 코사인 함수의 덧셈 공식:     
$\cos(\alpha + \beta) = \cos(\alpha) \cos(\beta) - \sin(\alpha) \sin(\beta)$
3. 탄젠트 함수의 덧셈 공식:     
$\tan(\alpha + \beta) = \frac{\tan(\alpha) + \tan(\beta)}{1 - \tan(\alpha) \tan(\beta)}$

이 공식들을 사용하면 두 각의 삼각함수 값을 더하거나 빼는 것을 수월하게 계산할 수 있다.

# 6. 수와 집합
### 수 (Numbers):
수는 양, 음, 정수, 유리수, 실수 등으로 나타낼 수 있는 개념이다.     
여러 가지 형태와 특성을 갖는다.

1. 자연수 (Natural Numbers): 1, 2, 3, 4와 같이 양의 정수들을 의미한다.  
주로 자연적인 세기나 계산에 사용된다.
2. 정수 (Integers): 0, 양의 정수, 음의 정수를 포함한 수의 집합이다.     
양의 정수와 음의 정수는 무한대로 확정될 수 있다.
3. 유리수 (Rational Numbers): 두 정수의 나눗셈으로 나타낼 수 있는 수를 의미한다.    
이 때 분모는 0이 아니어야 한다.     
예를 들어 1/2, -3/4 등이 유리수이다.
4. 실수 (Real Numbers): 유리수와 더불어 모든 실수를 포함하는 집합이다.  
실수는 실제 세계의 대부분의 측정이나 계산에 사용된다.   
실수는 무한 소수로 나타낼 수도 있다.
5. 복소수 (Complex Numbers): 실수와 허수를 합한 수이다.     
허수는 실수와 곱하여 -1을 얻는 수로, i라는 기호로 표현한다.     
복소수는 a + bi 형태로 나타낼 수 있으며, 여기서 a는 실수 부분이고 bi는 허수 부분이다.

### 집합 (Sets):
집합은 원소들의 모임을 나타내는 개념이다.   
집합은 중복되지 않는 원소들로 구성된다.     
수학적으로 집합은 중괄호 {} 안에 원소를 나열하여 나타낼 수 있다.

예를 들어, A = {1, 2, 3}은 원소 1, 2, 3으로 구성된 집합 A를 나타낸다.   
또 다른 예로, B = {red, green, blue}는 색상을 나타내는 집합 B를 나타낸다.

집합의 특성:

- 원소 (Elements): 집합을 구성하는 각각의 개별 요소를 원소라고 한다.
- 원소의 중복: 집합은 중복된 원소를 허용하지 않는다.    
즉, 하나의 원소는 집합 내에서 유일하게 나타난다.
- 집합의 크기: 집합 내 원소의 개수를 집합의 크기 또는 원소의 개수라고 한다.
- 부분집합 (Subset): 집합 A의 모든 원소가 집합 B에도 속할 때, 집합 A는 집합 B의 부분집합이라고 한다.
- 합집합 (Union): 두 개 이상의 집합에서 모든 원소들을 모아 새로운 집합을 만들 때, 이를 합집합이라고 한다.
- 교집합 (Intersection): 두 개 이상의 집합에서 공통으로 포함된 원소들을 모아 새로운 집합을 만들 때, 이를 교집합이라고 한다.

집합 이론은 수학적 분석, 확률론, 그래프 이론 등 다양한 분야에서 활용되며, 수와 관련된 다양한 개념과 연산을 다루는데 사용된다.

# 6.1. 연산과 수의 구조
### 연산 (Operations):
연산은 수나 다른 개체들 사이에서 수행되는 계산 또는 작용을 의미한다.    
연산은 수학적으로 다양한 형태로 나타낼 수 있으며, 주요한 연산에는 다음과 같은 것들이 있다.

1. 덧셈 (Addition): 두 수를 더하는 연산이다.    
덧셈은 수의 합을 구하는 데 사용된다.
2. 뺄셈 (Substraction): 하나의 수에서 다른 수를 빼는 연산이다.  
뺄셈은 두 값 사이의 차이를 구하는 데 사용된다.
3. 곱셈 (Multiplication): 두 수를 곱하는 연산이다.  
곱셈은 수의 증가율, 면적 등을 계산하는 데 사용된다.
4. 나눗셈 (Division): 하나의 수를 다른 수로 나누는 연산이다.    
나눗셈은 비율, 분수 등을 표현하는 데 사용된다.
5. 지수 (Exponentiation): 수를 다른 수의 거듭제곱으로 나타내는 연산이다.    
a^n은 a를 n번 곱하는 것을 의미한다.
6. 제곱근 (Square Root): 어떤 수의 제곱이 특정한 값이 되도록 하는 수를 찾는 연산이다.

### 수의 구조:
수의 구조는 수들 간의 관계와 패턴을 이해하고 분석하는 데 도움을 준다.

1. 집합 구조: 수는 집합의 원소로 나타낼 수 있다.    
집합에는 원소 간의 연산인 합집합, 교집합 등의 연산이 있다.
2. 순서 구조: 수의 순서는 수열이나 수량을 나타내는 데 사용된다.     
수열은 수들이 순서대로 나열된 구조이다.
3. 대수 구조: 수의 대수 구조는 수들 간의 연산에 관한 구조를 의미한다.   
이에는 그룹, 반환, 체 등이 포함된다.
4. 유한성과 무한성: 수의 구조에는 유한한 수의 개수와 무한한 수의 개수가 있다.   
자연수 집합은 무한한 원소를 가지지만, 유한한 집합도 있을 수 있다.
5. 소수와 합성수: 소수는 1과 자기 자신만을 약수로 가지는 수이다.    
합성수는 두 개 이상의 양의 약수를 가지는 수이다.
6. 모듈로 구조: 모듈로 연산은 나눗셈의 나머지를 다루는 구조이다.    
이 구조는 순환 패턴이나 주기성을 분석하는 데 사용된다.
7. 순열과 조합: 순열은 원소들의 순서에 따른 나열을 의미하고, 조합은 원소들의 순서에 관계 없는 선택을 의미한다.  
이들은 주로 카운팅 문제나 확률 문제에서 사용된다.

수의 구조와 연산은 수학의 핵심 개념이며, 이를 통해 다양한 문제를 분석하고 해결할 수 있다.

# 6.2. 수의 표현
수는 다양한 방법으로 표현될 수 있다.    
각각의 표현 방법은 수의 특성이나 용도에 따라 선택될 수 있다.    

1. 십진법 (Decimal Notation):   
십진법은 일상 생활에서 가장 많이 사용되는 표현 방법이다.    
숫자 0부터 9까지의 10개의 기호를 사용하여 수를 나타낸다.    
수의 위치가 변화함에 따라 그 값이 달라지는 위치 표기법을 사용한다.      
예를 들어, 365는 3 * 10^2 + 6 * 10^1 + 5 * 10^0으로 표현된다.

2. 이진법 (Binary Notation):    
이진법은 0과 1의 두 개의 기호만을 사용하여 수를 나타내는 방법이다.      
컴퓨터 시스템에서 주로 사용되며, 전기 신호의 온/오프 상태로 표현된다.   
예를 들어, 101은 1 * 2^2 + 0 * 2^1 + 1 * 2^0으로 표현된다.

3. 프로그래밍에서의 표현:   
프로그래밍 언어에서는 정수, 부동소수점, 복소수 등 다양한 형식으로 수를 표현할 수 있다.      

4. 지수 표기법 (Scientific Notation):   
매우 크거나 작은 수를 간결하게 표현하기 위해 지수 표기법을 사용한다.    
예를 들어, 3,000,000은 3 * 10^6으로 표현할 수 있다.

5. 분수 (Fractions):    
분수는 두 개의 정수를 나누어 나타내는 표현 방법이다.    
분자와 분모로 구성되며, 분자는 분모를 나눈 몫을 나타낸다.   
예를 들어, 1/2는 분자가 1이고 분모가 2인 분수를 나타낸다.

6. 소수 (Decimal Fractions):    
소수는 십진법에서 소수점을 가진 수로, 정수와 소수 부분으로 나누어 나타낸다.     
예를 들어, 3.14159sms 정수 부분이 3이고 소수 부분이 0.14159인 소수이다.

7. 혼합수 (Mixed Numbers):  
정수 부분과 분수 부분을 함께 가진 표현 방법이다.    
예를 들어, 2 1/2는 정수 부분이 2이고 분수 부분이 1/2인 혼합수를 나타낸다.

8. 복소수 (Complex Numbers):    
실수와 허수 부분으로 구성된 수이다.     
a + bi 형태로 나타내며, a는 실수 부분이고 bi는 허수 부분이다.

이러한 다양한 표현 방법은 수학적 계산, 과학, 엔지니어링, 프로그래밍 등 다양한 분야에서 사용되며, 특정한 문제나 상황에 맞게 선택하여 사용한다.

# 7. 함수
함수는 수학과 다양한 분야에서 중요한 개념으로 사용되는 개념이다.    
함수는 입력값을 받아서 특정한 규칙에 따라 출력값을 계산하는 규칙이나 연산을 나타내는 수학적 객체이다.   
함수는 다양한 형태와 목적으로 사용된다.

### 함수의 구성요소:
1. 입력 (Domain): 함수에 입력되는 값들의 집합을 의미한다.   
이 집합은 함수가 정의되는 범위를 결정한다.
2. 출력 (Codomain 또는 Range): 함수가 입력값을 대응시켜 계산한 결과값들의 집합이다.     
함수의 출력값은 입력값에 따라 달라질 수 있다.
3. 규칙 (Rule): 함수가 입력값을 어떤 연산에 따라 출력값으로 변환하는지를 나타내는 부분이다.     
이 규칙은 함수의 정의에 따라 달라진다.

### 함수의 표기법:
함수는 보통 다음과 같이 표기된다: f(x), g(y), h(z)와 같이 함수 이름 다음에 입력값을 나타내는 변수를 괄호 안에 표기한다.     
함수 이름은 임의로 지정할 수 있으며, 입력 변수도 함수에 따라 다를 수 있다.

### 예시:
1. 선형 함수 (Linear Function): 가장 간단한 함수 중 하나로, 출력값이 입력값에 대해 일정한 비율로 변하는 함수이다.   
예를 들어, f(x) = 2x는 입력값을 2배씩 증가시켜 출력값을 계산한다.
2. 제곱 함수 (Quadratic Function): 출력값이 입력값의 제곱에 관련된 함수이다.    
예를 들어, g(x) = x^2는 입력값을 제곱하여 출력값을 계산한다.
3. 삼각 함수 (Trigonometric Function): 삼각형의 각도와 변의 비율에 관련된 함수로, 삼각함수(sin, cos, tan 등)는 각도에 따른 값을 계산한다.
4. 지수 함수 (Exponential Function): 출력값이 입력값의 지수에 관련된 함수로, f(x) = e^x는 입력값의 지수에 해당하는 값들을 출력값으로 계산한다.

### 함수의 활용:
함수는 수학뿐만 아니라 과학, 공학, 경제학, 컴퓨터 과학 등 다양한 분야에서 활용된다.     
함수는 데이터 분석, 모델링, 문제 해결 등에 사용되며, 복잡한 현상을 간단한 규칙으로 설명할 수 있는 도구로 활용된다.      
함수의 연속성, 미분, 적분 등의 특성은 미적분학과 같은 수학 분야에서 중요한 개념이다.

# 7.1. 함수의 개념과 종류
### 함수의 개념:
함수는 입력과 출력 간의 대응 관계를 정의하는 수학적 규칙이다.   
어떤 집합의 각 원소(입력)가 다른 집합의 원소(출력)와 대응된다.      
이때, 하나의 입력에 대해 하나의 출력이 대응되어야 한다.     
함수는 특정한 규칙에 따라 입력값을 처리하고 연산하여 출력값을 생성하는 과정을 나타낸다.

수학적으로 함수는 다음과 같이 표기된다:     
$f : X \rightarrow Y$   
여기서 $f$는 함수의 이름, $X$는 입력의 집합(도메인), $Y$는 출력의 집합(치역)을 나타낸다.    
입력 $x$가 주여졌을 때, 함수 $f(x)$로 나타내며 이는 입력 $x$에 대응되는 출력값을 의미한다.

### 함수의 종류:
1. 선형 함수 (Linear Functions): 출력이 입력에 대해 일정한 비율로 변화하는 함수이다.    
$f(x) = ax + b$ 형태로 나타낼 수 있으며, $a$는 기울기를, $b$는 y 절편을 나타낸다.
2. 다항 함수 (Polynomial Functions): 여러 항의 합으로 표현되는 함수로, $f(x) = a_nx^n + a_{n-1}x^{n-1} + ... + a_1x + a_0$ 형태이다.    
n은 차수를 나타내며, $a_n$부터 $a_0$은 계수이다.
3. 지수 함수 (Exponential Functions): 출력이 입력값의 지수에 관련된 함수이다.   
$f(x) = a^x$ 형태로 나타낼 수 있으며, $a$는 기저이며 양수여야 한다.
4. 로그 함수 (Logarithmic Functions): 입력값의 로그에 관련된 함수이다.      
$f(x) = \log _a(x)$ 형태로 나타낼 수 있으며, $a$는 양수인 상수이며, 입력 $x$는 양수여야 한다.
5. 삼각 함수 (Trigonometric Functions): 삼각형의 각도와 변의 비율에 관련된 함수로, 삼각함수인 $\sin (x), \cos (x), \tan (x)$ 등이 있다.
6. 복소 함수 (Complex Functions): 복소수를 입력값이나 출력값으로 가지는 함수이다.   
$f(z)$ 형태로 표기되며, $z$는 복소수이다.
7. 계단 함수 (Step Functions): 입력값의 범위에 따라 출력값이 불연속적으로 변화하는 함수이다.    
주로 디지털 신호 처리 등에 활용된다.
8. 비선형 함수 (Nonlinear Functions): 선형이 아닌 형태로 출력값이 입력값에 대해 변화하는 함수들을 포함한다.     
다항 함수, 지수 함수, 로그 함수 등이 비선형 함수에 해당된다.

# 7.2. 합성 함수
합성 함수는 두 개 이상의 함수를 결합하여 새로운 함수를 만드는 개념이다.     
하나의 함수의 출력값을 다른 함수의 입력값으로 사용하여 새로운 함수를 생성하는 것을 의미한다.    
이렇게 합성된 함수는 두 개의 함수를 조합한 결과로, 입력을 첫 번째 함수에 넣고 그 출력을 다시 두 번째 함수의 입력으로 넣어 최종 출력값을 얻는다.

합성 함수의 표기는 $(f \circ g)(x)$와 같이 표현됩니다. 여기서 $f$와 $g$는 두 개의 함수이며, $x$는 입력 변수이다.    
합성 함수에서 먼저 입력 $x$가 함수 $g$의 입력으로 들어가고, 그 결과가 함수 $f$의 입력으로 들어가 최종 출력값이 계산된다.

수식적으로 나타내면 다음과 같습니다:    
$(f \circ g)(x) = f(g(x))$

### 예시:
1. 함수 $f(x) = 2x$와 함수 $g(x) = x + 3$이 있다고 가정해 본다.     
이 경우 합성 함수 $(f \circ g)(x)$는 다음과 같이 계산된다:    
$(f \circ g)(x) = f(g(x)) = f(x + 3) = 2(x + 3) = 2x + 6$

2. 함수 $h(x) = x^2$와 함수 $k(x) = \sqrt{x}$가 있다고 가정해 본다.     
이 경우 합성 함수 $(h \circ k)(x)$는 다음과 같이 계산된다:      
$(h \circ k)(x) = h(k(x)) = h(\sqrt{x}) = (\sqrt{x})^2 = x$

합성 함수는 함수를 조합하고 복잡한 연산을 간편하게 표현할 수 있는 강력한 도구이다.  
실제로 다양한 수학적, 과학적, 공학적 문제에서 사용되며, 함수들 간의 관계를 분석하고 모델링하는데 유용하게 활용된다.

# 7.3. 항등함수와 역함수
항등함수와 역함수는 함수의 중요한 개념 중 하나로, 서로 반대되는 역할을 하는 함수이다.

### 항등함수 (Identity Function):
항등함수는 입력값과 출력값이 동일한 함수를 말한다.      
다시 말해, 모든 입력값에 대해 출력값이 그 입력값과 같은 함수이다.   
수학적으로 표기하면 다음과 같다:

$f(x) = x$

여기서 $f(x)$는 항등함수이며, $x$는 입력 변수이다.      
항등함수는 어떤 값을 넣어도 그 값을 그대로 반환하는 역할을 한다.    
그래프로 나타내면 직선 $y = x$와 같은 형태가 된다.

### 역함수 (Inverse Function):
역함수는 어떤 함수의 입력과 출력의 역할을 뒤바꾼 함수를 말한다.     
즉, $f(x)$가 어떤 함수일 때, $f$의 출력값을 입력값으로, $f$의 입력값을 출력값으로 가지는 함수를 $f$의 역함수라고 한다.      
역함수는 $f^{-1}$로 표기하며, 다음과 같이 나타낼 수 있다:

$f^{-1}(f(x)) = x$  
$f(f^{-1}(x)) = x$

여기서 $f^{-1}(x)$는 $f$의 역함수이며, $x$는 입력 변수이다.     
역함수는 원래 함수의 반대 동작을 수행하므로, $f$의 출력값을 넣으면 원래 입력값이 나오고, $f$의 입력값을 넣으면 원래 출력값이 나온다.

### 예시:
1. 항등함수: $f(x) = x$는 입력값과 출력값이 같은 항등함수이다.
2. 역함수: $f(x) = 2x$일 때, $f^{-1}(x) = \frac{x}{2}$가 역함수이다.    
즉, $f(f^{-1}(x)) = 2(\frac{x}{2}) = x$가 되며, 역으로도 $f^{-1}(f(x)) = \frac{2x}{2} = x$가 된다.

항등함수와 역함수는 함수의 특성과 관계를 분석하는 데 중요한 역할을 한다.    
역함수를 구하는 것은 함수의 규칙과 역전을 이해하는 데 도움이 되며, 실제 문제에서도 활용되는 경우가 많다.

# 7.4. 곱집합을 활용한 좌표 평면으로의 확장
곱집합을 활용한 좌표 평면으로의 확장은 수학적 개념을 사용하여 2개의 집합을 결합하여 새로운 공간을 생성하는 것을 의미한다.   
이를 통해 2개 이상의 차원을 가지는 좌표 평면이나 공간을 표현할 수 있다.

일반적으로, 2차원 좌표 평면은 숫자 쌍인 x와 y로 표현되는 점들의 집합이다.   
각 점은 x축과 y축의 값으로 나타내지며, 예를 들어 (2,3)은 x=2와 y=3의 교차점을 의미한다.

이제, 좌표 평면을 확장하여 3차원 공간으로 생각해 보겠다.    
이때, 각 점은 숫자 쌍이 아닌 숫자 세 개의 조합 (x,y,z)로 표현된다.      
이렇게 하여 3차원 공간에서 각 점은 x,y,z 축에 의해 정의된다.

마찬가지로, 곱집합을 사용하여 좌표 평면이나 공간을 더 높은 차원으로 확장할 수 있다.     
n차원 공간에서 각 점은 숫자 n개의 조합 $(x_1, x_2, ..., x_n)$로 표현된다.   
이런 식으로 곱집합을 사용하여 다차원 공간을 생성하면, 좌표 평면이나 공간에서의 점들을 더 다양하게 나타낼 수 있다.

### 예시:
1. 2차원 좌표 평면: 점 (2,3)은 x=2와 y=3의 교차점이다.
2. 3차원 공간: 점 (2,3,4)는 x=2, y=3, z=4의 교차점으로, 3차원 공간에서의 위치를 나타낸다.
3. 4차원 공간: 점 (1,2,3,4)는 4개의 좌표 축으로 나타낸 4차원 공간에서의 점이다.     
이는 상상력을 초월하는 개념이므로 시각적으로는 표현하기 어려울 수 있다.

이와 같이 곱집합을 사용하여 좌표 평면이나 다차원 공간을 확장하는 개념은 수학적 모델링, 공학, 물리학, 컴퓨터 그래픽스 등 다양한 분야에서 사용되며, 다차원 공간에서의 데이터나 개념을 표현하는 데 유용하다.

# 8. 행렬
게임 수학에서 행렬은 게임의 다양한 측면을 모델링하고 해결하는 데 사용되는 중요한 수학적 도구이다.   
행렬은 게임 엔진 개발, 그래픽스, 물리 시뮬레이션, 인공지능 등 다양한 영역에서 활용되며, 게임 내의 객체의 변환, 충돌 감지, 렌더링, 카메라 관리 등에 사용된다.

1. 변환 행렬 (Transformation Matrices): 물체의 이동, 회전, 크기 조절과 같은 변환은 행렬을 사용하여 표현될 수 있다.  
이러한 변환 행렬을 사용하면 게임 객체들의 위치와 방향을 효과적으로 제어할 수 있다.
2. 카메라 행렬 (Camera Matrices): 게임 내에서 카메라의 위치와 방향은 행렬로 표현된다.   
이를 통해 게임 화면을 구성하거나 3D 공간을 2D 화면에 투영할 수 있다.
3. 물리 시뮬레이션 (Physics Simulation): 물리 엔진에서 물체의 운동을 시뮬레이션하기 위해 행렬을 사용한다.   
행렬을 사용하여 물체의 위치, 속도, 가속도 등을 계산하고 시간에 따른 물체의 움직임을 예측할 수 있다.
4. 그래픽스 렌더링 (Graphics Rendering): 게임 그래픽스에서 행렬은 3D 모델의 변환과 렌더링 과정에서 중요한 역할을 한다.  
객체의 변환, 투영, 뷰 변환 등에 행렬이 사용되어 실제 화면에 어떻게 표시될지 결정된다.
5. 인공지능 (Artificial Intelligence): 게임 내의 NPC나 적 캐릭터의 움직임과 의사 결정에도 행렬이 사용된다.  
경로 탐색, 강화 학습, 행동 패턴 등을 모델링하기 위해 행렬 연산을 활용할 수 있다.

행렬은 게임 개발에서 수학적 모델링과 계산을 효과적으로 다루는 데 필수적인 도구로 활용되며, 게임의 시각적인 표현과 물리적 모델링, 인공지능 구현 등 다양한 측면에서 중요한 역할을 한다.

# 8.1. 선형성
행렬의 선형성과 예측 가능한 비례 관계는 선형대수학의 중요한 개념 중 하나이다.   
이들은 다양한 수학적 연산과 현실 세계에서의 관계를 모델링하고 분석하는 데 사용된다.

### 선형성 (Linearity):
행렬의 선형성은 다음 두 가지 기본 조건으로 정의된다:

1. 덧셈에 대한 선형성: 행렬 $A$와 $B$가 주어졌을 때, $A + B$ 역시 선형성을 만족해야 한다.   
즉, $A + B = B + A$이며, $A + (B + C) = (A + B) + C$가 성립해야 한다.   
2. 스칼라 곱에 대한 선형성: 행렬 $A$와 스칼라 $c$가 주어졌을 때, $cA$ 역시 선형성을 만족해야 한다.  
즉, $1 \cdot A = A$이며, $(cd)A = c(dA)$가 성립해야 한다.

이러한 선형성은 행렬 연산을 조합하거나 분해할 때 유용하게 사용된다.     
예를 들어, 여러 가지 선형 변환을 연결하여 복잡한 변환을 표현하거나, 선형 시스템의 해를 구하는 과정에서 선형성을 활용할 수 있다.

### 예측 가능한 비례 관계:
행렬은 예측 가능한 비례 관계를 모델링하는 데 사용될 수 있다.    
예를 들어, $Ax = b$와 같은 선형 시스템을 생각해보자.    
이 때, $A$는 변환 행렬, $x$는 입력 벡터, $b$는 결과 벡터이다.   
$A$가 주어지면 입력 벡터를 변환하여 결과 벡터를 예측할 수 있다.     
이러한 예측 가능한 비례 관계는 데이터 분석, 예측 모델링, 신호 처리 등 다양한 분야에서 활용된다.

예시:

- 선형 회귀 분석에서, 입력 변수와 결과 변수 간의 관계를 행렬과 벡터를 사용하여 모델링할 수 있다.
- 그래픽스 프로그래밍에서 변환 행렬을 사용하여 객체를 움직이고 변형시키는 것이 가능하다.

행렬의 선형성과 예측 가능한 비례 관계는 수학적 모델링과 문제 해결에 있어서 강력하고 유용한 도구다.

# 8.1.1. 선형 함수
선형 함수는 수학에서 매우 중요한 개념으로, 다음 두 가지 기본적인 성질을 만족하는 함수를 말한다:

1. 가산성 (Additivity): 함수의 입력값에 대한 합성이 결과값에 대한 합성으로 이어져야 한다.   
즉, 함수 $f$가 가산성을 만족하려면 모든 $x$와 $y$에 대해 $f(x + y) = f(x) + f(y)$이어야 한다.
2. 동차성 (Homogeneity): 함수의 입력값에 스칼라를 곱한 것이 결과값에도 그 스칼라를 곱한 것과 같아야 한다.   
즉, 함수 $f$가 동차성을 만족하려면 모든 $x$와 스칼라 $c$에 대해 $f(cx) = cf(x)$이어야 한다.

선형 함수는 주로 선형대수학이나 미적분학에서 중요한 역할을 한다.    
예를 들어, 선형 함수의 예시로 $f(x) = ax + b$를 들 수 있다.     
여기서 $a$와 $b$는 상수이며, 가산성과 동차성을 만족한다.    
선형 함수는 입력값과 결과값 간의 비례 관계를 나타내며, 다양한 수학적 문제나 현실 세계에서의 문제를 모델링하고 해결하는 데 사용된다.

선형 함수의 중요한 특징은 슈퍼포지션의 원리를 만족한다는 것이다.    
이는 한 선형 함수의 출력을 다른 선형 함수의 입력으로 사용하여 두 함수를 결합해도 결과는 여전히 선형 함수가 된다.

또한, 선형 함수는 다른 함수를 선형 변환하는데 사용되며, 이는 다양한 분야에서 활용된다.  
물리학에서는 물체의 움직임을 모델링하고, 공학에서는 시스템의 동작을 분석하는데 사용된다.    
또한, 선형 회귀 분석과 같은 통계적 기법에서도 사용된다.

### 벡터 공간의 선형 변환
벡터 공간의 선형 변환은 한 벡터 공간에서 다른 벡터 공간으로 벡터를 변환시키는 함수를 의미한다.  
선형 변환은 선형 함수의 한 형태로, 입력 벡터들에 대해 가산성과 동차성을 유지하는 변환을 말한다.     
이러한 선형 변환은 수학적 모델링, 물리학, 공학, 그래픽스 등 다양한 분야에서 사용되며, 벡터의 형태나 방향을 변화시키거나 공간을 변형하는데 활용된다.

선형 변환의 주요 특징은 가산성과 동차성이다.

선형 변환은 여러 가지 방식으로 나타낼 수 있다.  
행렬을 사용하는 것이 가장 흔한 방법 중 하나이다.    
행렬을 사용하여 벡터를 변환하는 경우, 행렬과 벡터의 곱셈을 통해 변환된 결과를 계산할 수 있다.

예시:

- 2D나 3D 그래픽스에서 변환 행렬을 사용하여 객체를 이동, 회전, 크기 조절하는 것이 선형 변환의 예시이다.
- 선형 회귀 분석에서 입력 변수들을 변환하여 결과 변수와의 관계를 모델링하는 것도 선형 변환의 한 형태이다.   
- 어떤 시스템의 입력과 출력 간의 관계를 선형 변환으로 나타내어 분석하는 것도 일반적인 응용 중 하나이다.

선형 변환은 다양한 분야에서 벡터나 공간의 변환을 모델링하고 다루는 데에 사용되며, 수학적 모델링과 문제 해결에 있어서 매우 중요한 개념 중 하나이다.

# 8.2. 행렬의 기본 연산
행렬의 기본 연산에는 덧셈, 뺄셈, 스칼라 곱, 행렬곱 등이 포함된다.   
이러한 연산들은 행렬을 다루고 변형하는 데 사용되며, 선형 대수학과 다양한 응용 분야에서 중요한 역할을 한다.

1. 행렬 덧셈과 뺄셈:    
행렬 간의 덧셈과 뺄셈은 각 원소별로 동일한 위치에 있는 원소들끼리 더하거나 뺄 때 이루어진다.    
두 행렬의 크기가 같을 때만 덧셈과 뺄셈이 가능하다.  
예시:   
$$\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix} + \begin{bmatrix} 5 & 6 \\ 7 & 8 \end{bmatrix} = \begin{bmatrix} 6 & 8 \\ 10 & 12 \end{bmatrix}$$
2. 스칼라 곱:   
행렬과 스칼라(숫자)의 곱은 해당 행렬의 모든 원소에 스칼라를 곱해주는 연산이다.  
예시:
$$2 \cdot \begin{bmatrix} 3 & 4 \\ 5 & 6 \end{bmatrix} = \begin{bmatrix} 6 & 8 \\ 10 & 12 \end{bmatrix}$$
3. 행렬곱 (Matrix Multiplication):
두 행렬 $A$와 $B$의 행렬곱 $C = AB$는 $C$의 각 원소를 $A$의 해당 행과 $B$의 해당 열의 내적으로 구한다.  
행렬곱을 수행하기 위해서는 첫 번째 행렬의 열 수와 두 번째 행렬의 행 수가 일치해야 한다.     
예시:
$$\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix} \cdot \begin{bmatrix} 5 & 6 \\ 7 & 8 \end{bmatrix} = \begin{bmatrix} 19 & 22 \\ 43 & 50 \end{bmatrix}$$
4. 전치행렬 (Transpose Matrix):     
행렬의 전치는 행과 열을 바꾸는 연산이다.    
$A$의 전치는 $A^T$로 나타내며, $A$의 $i$행과 $j$열의 원소가 $A^T$의 $j$행과 $i$열의 원소로 이동한다.    
예시:
$$\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix}^T = \begin{bmatrix} 1 & 3 \\ 2 & 4 \end{bmatrix}$$

행렬의 이러한 기본 연산들은 선형 변환, 데이터 분석, 컴퓨터 그래픽스, 공학 등 다양한 분야에서 활용되며, 행렬을 다루고 조작하는 데에 필수적이다.

# 8.3. 행렬의 설계
행렬의 설계는 행렬의 크기, 원소의 값, 구조, 목적 등을 결정하는 과정을 의미한다.     
행렬은 다양한 수학적 모델링과 문제 해결에 사용되며, 이에 따라 행렬을 어떻게 설계하느냐에 따라 결과나 성능이 크게 영향을 받을 수 있다.   
다음은 행렬의 설계에 관련된 몇 가지 요소들이다:

1. 크기 (Dimensions):   
행렬의 크기는 행과 열의 개수로 결정된다.    
행렬의 크기는 해당 문제에 맞게 결정되어야 하며, 연산이나 변환에 필요한 차원을 고려하여 정확하게 정의되어야 한다.
2. 원소의 값 (Values of Elements):  
행렬의 원소들은 해당 문제나 모델의 특성에 따라 결정된다.    
일부 문제에서는 행렬의 원소들을 임의로 설정하는 것이 가능하며, 다른 경우에는 데이터나 조건에 따라 값을 채워넣어야 할 수도 있다.
3. 구조 (Structure):    
행렬은 여러 가지 구조를 가질 수 있다.   
대각행렬, 삼각행렬, 대칭행렬, 희소행렬 등 다양한 구조의 행렬을 사용하여 특정한 성질이나 조건을 나타낼 수 있다.  
4. 목적 (Purpose):  
행렬의 설계는 해당 행렬이 어떤 목적을 위해 사용되는지에 따라 결정된다.  
예를 들어, 변환 행렬은 객체의 이동, 회전, 크기 조절과 관련하여 설계될 것이며, 데이터 분석을 위한 행렬은 주어진 데이터와 분석 목적에 따라 설계될 것이다.
5. 행렬의 종류 (Types of Matrices):     
특정한 목적이나 문제에 따라 다양한 종류의 행렬을 사용할 수 있다.    
예를 들어, 항등행렬, 영행렬, 대각행렬 등의 특수한 형태의 행렬을 활용하여 특별한 성질을 나타낼 수 있다.

행렬의 설계는 해당 문제의 특성을 이해하고 수학적인 모델을 구축하는 과정을 포함한다. 
이를 통해 행렬을 최적으로 활용하여 원하는 결과를 얻을 수 있다.

# 8.3.1. 크기 변환행렬
크기 변환 행렬은 객체나 벡터의 크기를 조절하기 위해 사용되는 변환 행렬이다.     
크기 변환은 객체를 확대 또는 축소하는 등 크기를 조절하는 변환을 의미하며, 이를 수행하기 위해 행렬을 사용할 수 있다.     
크기 변환 행렬은 주로 2D나 3D 그래픽스에서 사용되며, 객체를 원하는 크기로 변환하는데 활용된다.

2D 그래픽스에서 크기 변환 행렬은 일반적으로 다음과 같이 나타낼 수 있다:
$$S = \begin{bmatrix} S_x & 0 \\ 0 & S_y \end{bmatrix}$$

여기서 $S_x$는 $x$축 방향으로의 크기 비율이고, $S_y$는 $y$축 방향으로의 크기 비율이다.  
이 행렬을 사용하여 객체의 각 점을 변환하면, 객체가 $x$축과 $y$축 방향으로 각각 $S_x$와 $S_y$배만큼 확대 또는 축소된다.

3D 그래픽스에서 크기 변환 행렬은 다음과 같이 나타낼 수 있다:

$$S = \begin{bmatrix} S_x & 0 & 0 \\ 0 & S_y & 0 \\ 0 & 0 & S_z \end{bmatrix}$$

여기서 $S_x$, $S_y$, $S_z$는 각각 $x$축, $y$축, $z$축 방향으로의 크기 비율을 나타낸다.  
이 행렬을 사용하여 3D 객체의 각 점을 변환하면, 객체가 각 축 방향으로 크기 비율에 따라 확대 또는 축소된다.   

크기 변환행렬은 여러 가지 분야에서 활용된다:

1. 그래픽스: 2D나 3D 그래픽스에서 객체의 크기를 확대 또는 축소하는 데 사용된다.     
또한, 객체의 크기를 조절하여 시각적인 효과를 줄 수 있다.
2. 이미지 처리: 이미지를 확대 또는 축소하는데 크기 변환행렬을 사용하여 이미지를 변형하고 조정할 수 있다.
3. 물리 시뮬레이션: 물체의 크기 변환을 모델링하여 시뮬레이션하는데 사용된다.    
예를 들어, 물체가 확대되거나 수축되는 상황을 모델링할 수 있다.

크기 변환행렬은 선형 변환 중 하나로, 객체의 크기를 조절하는 데 유용하게 사용되며, 다양한 응용 분야에서 활용된다.

# 8.3.2. 회전 변환행렬
회전 변환행렬은 객체나 벡터를 특정 각도만큼 회전시키기 위해 사용되는 행렬이다.  
이 행렬은 객체의 방향을 바꾸거나 좌표계를 회전시키는데 사용된다.    
회전 변환행렬은 선형 변환 행렬의 일종으로, 주어진 행렬과 원본 벡터 또는 객체를 곱하여 회전된 결과를 얻는 과정으로 작용한다.

2D 공간에서의 회전 변환행렬은 다음과 같은 형태를 가진다:
$$R = \begin{bmatrix} \cos(\theta) & -\sin(\theta) \\ \sin(\theta) & \cos(\theta) \end{bmatrix}$$

여기서 $\theta$는 회전 각도이다.    
이 회전 변환행렬은 시계방향으로 회전하는 경우에는 각도 $\theta$가 양수이며, 반시계반향으로 회전하는 경우에도 각도 $-\theta$가 사용된다.

3D 공간에서는 축에 따라 회전 변환행렬이 다양한 형태를 가진다.   
주요한 회전 변환행렬로 다음과 같은 것들이 있다:

- X축 주위 회전:
$$R_x = \begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos(\theta) & -\sin(\theta) \\ 0 & \sin(\theta) & \cos(\theta) \end{bmatrix}$$

- Y축 주위 회전:
$$R_y = \begin{bmatrix} \cos(\theta) & 0 & \sin(\theta) \\ 0 & 1 & 0 \\ -\sin(\theta) & 0 & \cos(\theta) \end{bmatrix}$$

- Z축 주위 회전:
$$R_z = \begin{bmatrix} \cos(\theta) & -\sin(\theta) & 0 \\ \sin(\theta) & \cos(\theta) & 0 \\ 0 & 0 & 1 \end{bmatrix}$$

회전 변환행렬은 그래픽스, 로봇공학, 물리 시뮬레이션 등 다양한 분야에서 활용된다.    
객체의 방향을 조절하거나 3D 공간에서의 움직임을 모델링할 때 회전 변환행렬이 중요한 도구로 사용된다.

# 8.3.3. 전단 변환행렬
전단 변환행렬은 객체나 벡터를 특정 축 방향으로 변형하는 변환을 나타내는 행렬이다.   
이 변환은 객체의 모양을 뒤틀거나 늘이는데 사용된다.     
전단 변환행렬은 선형 변환 행렬의 한 형태로, 주어진 행렬과 원본 벡터 또는 객체를 곱하여 변환된 결과를 얻는 과정으로 작용한다.

2D 공간에서의 전단 변환행렬은 다음과 같은 형태를 가진다:
$$SH = \begin{bmatrix} 1 & sh_x \\ sh_y & 1 \end{bmatrix}$$

여기서 $sh_x$는 $x$축 방향으로의 전단 계수이며, $sh_y$는 $y$축 방향으로의 전단 계수이다.    
전단 변환행렬은 원본 객체의 점들을 해당 축 방향으로 이동시키는 역할을 한다.

3D 공간에서도 각 축에 대한 전단 변환행렬이 있으며, 이는 해당 축에 대한 이동 변환이 이루어짐을 나타낸다.

전단 변환행렬은 다양한 분야에서 사용된다:

1. 그래픽스: 객체나 이미지를 뒤틀거나 변형시키는 데 사용된다.   
에를 들어, 텍스트나 이미지를 특정 각도로 기울이는 데 활용된다.
2. 컴퓨터 비전: 이미지 처리와 패턴 인식에서 이미지의 형태를 변형하거나 조정하는 데 사용된다.

전단 변환행렬은 객체나 벡터의 형태를 뒤틀거나 늘이는 데 활용되며, 다양한 응용 분야에서 사용되는 중요한 변환 중 하나이다.

# 8.4. 역행렬
역행렬(Inverse Matrix)은 주어진 정방행렬(행과 열의 개수가 같은 행렬)의 곱으로 항등행렬이 되는 행렬을 말한다.    
즉, 행렬 $A$의 역행렬 $A^{-1}$은 다음 조건을 만족하는 행렬이다:

$A \cdot A^{-1} = A^{-1} \cdot A = I$

여기서 $I$는 항등행렬(identity matrix)을 나타낸다.  
역행렬을 구하는 것은 주어진 행렬로부터 역변환을 수행하는 과정으로, 선형 변환의 역변환을 구하는 데에 중요한 역할을 한다. 

행렬 $A$의 역행렬 $A^{-1}$이 존재하려면 몇 가지 조건을 만족해야 한다:

1. 행렬 $A$는 정방행렬이어야 한다: 역행렬은 정방행렬에 대해서만 정의된다.   
즉, 행과 열의 개수가 같은 행렬이어야 한다.
2. 행렬 $A$는 풀랭크(full rank)여야 한다: 행렬 $A$의 역행렬이 존재하려면 $A$가 선형 독립인 행(또는 열) 벡터들로 이루어져 있어야 한다.
3. 행렬 $A$의 행렬식(determinant)이 0이 아니어야 한다: 만약 $A$의 행렬식이 0이라면, 역행렬은 존재하지 않는다.

역행렬은 다양한 응용 분야에서 중요한 역할을 한다.   
선형 방정식의 해를 구하는데 사용되거나, 선형 변환의 역변환을 계산하거나, 데이터 분석과 최적화 문제를 해결하는 데에 활용된다.    
하지만 모든 정방행렬이 역행렬을 갖는 것으 아니며, 역행렬이 존재하지 않을 수도 있다.

# 8.4.1. 역행렬의 존재를 판별하는 행렬식
역행렬의 존재를 판별하는 주요한 기준 중 하나는 행렬식(Determinant)을 사용하는 것이다.   
행렬식은 정방행렬(행과 열의 개수가 같은 행렬)의 성질을 나타내는 값으로, 역행렬의 존재 여부와 관련된 중요한 정보를 제공한다.

만약 행렬 $A$가 $n \times n$ 크기의 정방행렬이라면, $A$의 역행렬이 존재하려면 그리고 그럴 때에만, $A$의 행렬식이 0이 아니어야 한다.

수식으로 나타내면 다음과 같다:

If $det(A) \neq 0$, then $A^{-1}$ exits.

이 조건을 만족하지 않는 경우, 즉 $det(A) = 0$인 경우에는 역행렬이 존재하지 않는다.

행렬식은 다양한 방법으로 계산할 수 있지만, 주로 가우스 소거법이나 행렬의 특성값과 특성벡터를 활용하여 계산한다.     
행렬식은 행렬의 선형 변환에 따른 부피 변화를 나타내는 값으로 이해할 수 있다.    
따라서 역행렬이 존재하려면 원본 공간의 부피가 변환된 공간의 부피와 같아야 한다.

# 8.4.2. 크기 변환행렬의 역행렬
크기 변환행렬의 역행렬은 원본 객체나 벡터의 크기를 원래의 크기로 돌리기 위해 사용되는 역변환 행렬이다.  
역행렬은 이전에 적용한 변환을 원래대로 되돌리는 역할을 하며, 크기 변환에 대한 역변환을 구하는 데 활용된다.

2D 공간에서의 크기 변환행렬은 다음과 같다:
$$S = \begin{bmatrix} s_x & 0 \\ 0 & s_y \end{bmatrix}$$

역행렬 $S^{-1}$은 다음과 같다:
$$S^{-1} = \begin{bmatrix} \frac{1}{s_x} & 0 \\ 0 & \frac{1}{s_y} \end{bmatrix}$$

여기서 $s_x$와 $s_y$는 원래 크기 대비 확대 또는 축소 비율이다.  
역행렬을 적용하면 이전의 크기 변환을 원래대로 돌릴 수 있다.

3D 공간에서도 크기 변환행렬과 역행렬의 개념이 유사하게 적용된다.    
3D 공간에서의 크기 변환행렬은 각 축에 대해 크기 변환 비율을 지정하는 대각 행렬의 형태를 가지며, 역행렬은 각 축의 크기 변환 비율의 역수로 이루어진 대각 행렬이다.

크기 변환행렬의 역행렬은 객체나 벡터의 크기 변환을 원래대로 되돌리는 데에 활용되며, 그래픽스, 이미지 처리, 데이터 분석 등 다양한 분야에서 유용하게 사용된다.

# 8.4.3. 회전 변환행렬의 역행렬
회전 변환행렬의 역행렬은 원래의 회전을 되돌리는 데 사용되는 역변환 행렬이다.    
회전 변환행렬은 객체나 벡터를 특정 각도만큼 회전시키는 변환을 나타내며, 역행렬은 그 회전을 원래의 상태로 되돌리는데 활용된다.

2D 공간에서의 회전 변환행렬은 다음과 같다:
$$R = \begin{bmatrix} \cos(\theta) & -\sin(\theta) \\ \sin(\theta) & \cos(\theta) \end{bmatrix}$$

여기서 $\theta$는 회전 각도이다.    
역행렬 $R^{-1}$은 다음과 같다:
$$R^{-1} = \begin{bmatrix} \cos(-\theta) & -\sin(-\theta) \\ \sin(-\theta) & \cos(-\theta) \end{bmatrix} = \begin{bmatrix} \cos(\theta) & \sin(\theta) \\ -\sin(\theta) & \cos(\theta) \end{bmatrix}$$

따라서 역행렬은 원래의 회전 각도의 음수값으로 구성된다.     
이를 적용하면 원래의 회전을 원상태로 되돌릴 수 있다.

3D 공간에서도 회전 변환행렬과 역행렬의 개념이 유사하게 적용된다.    
3D 공간에서의 회전 변환행렬은 축 주위의 회전을 나타내며, 역행렬은 이 회전을 원래대로 되돌리는 역변환을 수행한다.

회전 변환행렬의 역행렬은 회전을 원래대로 되돌리는데 사용되며, 그래픽스, 로봇공학, 3D 모델링 등 다양한 분야에서 활용된다.

# 8.4.4. 전단 변환행렬의 역행렬
전단 변환행렬의 역행렬은 원래의 전단 변환을 되돌리는데 사용되는 역변환 행렬이다.    
전단 변환행렬은 객체나 벡터를 특정 축 방향으로 변형하는 변환을 나타내며, 역행렬은 그 변형을 원래대로 되돌리는 역할을 한다.

2D 공간에서의 전단 변환행렬은 다음과 같다:
$$SH = \begin{bmatrix} 1 & sh_x \\ sh_y & 1 \end{bmatrix}$$

전단 변환행렬의 역행렬 $SH^{-1}$은 다음과 같다:
$$SH^{-1} = \begin{bmatrix} 1 & -sh_x \\ -sh_y & 1 \end{bmatrix}$$

여기서 $sh_x$와 $sh_y$는 원래 전단 변환의 이동량을 나타냈다.    
역행렬을 적용하면 원래의 변형을 되돌릴 수 있다.

3D 공간에서도 각 축에 대한 전단 변환행렬과 역행렬의 개념이 유사하게 적용된다.   
3D 공간에서의 전단 변환행렬은 각 축 방향으로의 변형을 나타내며, 역행렬은 이 변형을 되돌리는 역변환을 수행한다.

전단 변환행렬의 역행렬은 객체나 벡터의 변형을 원래대로 되돌리는데 사용되며, 그래픽스, 이미지 처리, 데이터 분석 등 다양한 분야에서 활용된다.

# 8.4.5. 행렬 곱의 역행렬
두 개의 행렬을 곱할 때, 이 두 행렬의 곱의 역행렬은 각각의 행렬의 역행렬을 곱한 것과 같다.   
수식적으로 나타내면, 만약 $A$와 $B$라는 두 행렬이 있을 때, 다음과 같은 관계가 성립한다:

$(AB)^{-1} = B^{-1}A^{-1}$

이 관계는 행렬의 곱의 역행렬에 대한 중요한 성질 중 하나이다.

이러한 성질을 이해하기 위해서는 행렬의 곱셈과 역행렬의 정의를 이해하는 것이 중요하다.   
역행렬은 주어진 행렬의 곱으로 항등행렬이 나오도록 하는 행렬이며, 두 행렬의 곱의 역행렬은 각 행렬의 역행렬을 곱해서 얻을 수 있다.

이러한 성질을 활용하면 두 개의 행렬을 곱한 후에 역행렬을 구하는 경우, 두 행렬의 역행렬을 각각 구한 다음 순서를 바꿔서 곱하면 된다.  
이는 행렬 곱셈의 순서를 바꿀 수 없지만 역행렬을 구하는 순서를 바꿀 수 있기 때문에 가능한 것이다.

이 성질은 선형 대수학과 다양한 응용 분야에서 사용되며, 복잡한 행렬식을 간단하게 다룰 수 있는 도구 중 하나이다.

# 9. 아핀 공간
아핀 공간(Affine Space)은 벡터 공간(Vector Space)의 일반화된 개념으로, 점들 간의 상대적인 위치와 거리를 다루는 공간이다.    
아핀 공간은 벡터 덧셈을 통해 정의되며, 점과 점 사이의 차이 벡터의 개념을 사용하여 상대적인 위치를 표현한다.     
하지만 아핀 공간은 원점(영벡터)를 갖지 않으며, 벡터 공간의 원래 구조에서 원점을 제외한 것이라고 볼 수 있다.

아핀 공간의 특징은 다음과 같다:

1. 아핀 조합(Affine Combination): 주어진 점들에 대해 아핀 조합은 각 점과 그에 해당하는 가중치의 선형 조합을 의미한다.   
아핀 조합을 통해 아핀 공간 내의 새로운 점을 생성할 수 있다.
2. 점 간 거리와 상대적 위치: 아핀 공간에서는 점 간 거리보다는 점들 간의 상대적인 위치와 방향이 더 중요하다.     
따라서 점들 사이의 벡터 차이, 즉 차이 벡터를 통해 거리와 방향을 나타낼 수 있다.
3. 변환 및 이동: 아핀 공간에서는 점들에 대한 변환이나 이동(이동 변환)이 중요한데, 이는 아핀 변환(Affine Transformation)이라고 불린다.   
아핀 변환은 선형 변환과 이동 변환을 조합하여 점들 간의 상대적 위치와 거리를 보존하는 변환이며, 그래픽스와 컴퓨터 비전 분야에서 널리 사용된다.

아핀 공간은 그래픽스, 컴퓨터 비전, 기하학, 물리학 등 다양한 분야에서 활용되며, 점들 간의 상대적 위치와 변환을 다루는 데 유용한 개념이다.

# 9.1. 이동 변환을 위한 아핀 공간
이동 변환은 아핀 변환(Affine Transformation)의 한 형태로, 객체나 좌표를 특정 벡터만큼 이동 시키는 변환을 의미한다.  
이동 변환은 아핀 공간 내에서 점들의 위치를 변경시키는 작업을 나타낸다.  
이때, 이동 변환은 점들 간의 상대적인 위치와 방향을 보존하면서 이루어지며, 아핀 변환의 중요한 부분 중 하나이다.

아핀 공간에서의 이동 변환은 다음과 같은 특징을 가진다:

1. 벡터의 덧셈을 통한 이동: 이동 변환은 벡터의 덧셈을 통해 이루어진다.  
특정 벡터를 주어진 점들에 더함으로써 모든 점들을 동일한 벡터만큼 이동시킬 수 있다.
2. 상대적인 위치 보존: 이동 변환은 점들의 상대적인 위치와 방향을 보존한다.  
즉, 어떤 점에서 다른 점으로의 벡터 차이는 변환 전후에도 보존된다.
3. 변환 행렬: 이동 변환은 행렬로 표현되며, 이동 변환행렬은 대각 요소가 1이고 나머지 요소가 0인 항등 행렬과 벡터의 덧셈으로 구성된다.

2D 아핀 공간에서의 이동 변환행렬은 다음과 같다:
$$T = \begin{bmatrix} 1 & 0 & t_x \\ 0 & 1 & t_y \\ 0 & 0 & 1 \end{bmatrix}$$

여기서 $(t_x, t_y)$는 이동할 벡터를 나타낸다.

3D 아핀 공간에서도 유사한 원리로 이동 변환행렬을 구성할 수 있다.

이동 변환은 그래픽스, 컴퓨터 비전, 로봇공학 등에서 다양하게 활용되며, 객체나 좌표의 위치를 조절하는 데에 중요한 역할을 한다.

# 9.2. 아핀 공간의 구성 요소
아핀 공간은 다양한 구성 요소로 이루어진 개념적인 공간이다.  
이 공간은 점들 간의 상대적인 위치와 변환이 중요하며, 다음과 같은 구성 요소를 가지고 있다:

1. 점(Point): 아핀 공간의 기본 단위는 점이다.   
각 점은 좌표로 나타내며, 점들 간의 상대적인 위치를 다루는데 사용된다.
2. 벡터(Vector): 아핀 공간에서의 벡터는 한 점에서 다른 점으로의 방향과 거리를 표현하는 데 사용된다.     
벡터는 점들 간의 차이를 표현하는 데 활용되며, 이동 변환과 같은 작업에 중요한 역할을 한다.
3. 아핀 조합(Affine Combination): 아핀 조합은 점들 간의 가중치를 고려한 선형 조합을 의미한다.   
즉, 주어진 점들과 그에 해당하는 가중치를 조합하여 새로운 점을 생성하는데 사용된다.
4. 아핀 변환(Affine Transformation): 아핀 변환은 점들 간의 상대적인 위치와 거리를 보존하면서 변환을 수행하는 작업을 의미한다.   
이동 변환, 회전 변환, 크기 변환 등이 아핀 변환에 해당한다.
5. 아핀 공간의 차원(Dimension): 아핀 공간의 차원은 그 공간 내의 벡터의 개수를 나타낸다. 
2D 아핀 공간은 평면을, 3D 아핀 공간은 입체를 나타낸다.
6. 아핀 기하학(Affine Geometry): 아핀 공간 내에서 점들의 상대적인 위치와 변환에 관한 기하학적 개념을 다루는 분야이다.   
이동 변환, 회전 변환, 크기 변환 등의 아핀 변환을 다루며, 그래픽스와 기하학 분야에서 중요한 개념이다.

아핀 공간은 객체의 변환, 이미지 처리, 기하학적 모델링, 컴퓨터 비전 등 다양한 분야에서 사용되며, 점들 간의 상대적인 위치와 변환을 다루는 데 중요한 개념이다.

# 9.3. 아핀 결합
아핀 결합(Affine Combination)은 아핀 공간에서 주어진 점들과 그에 해당하는 가중치를 사용하여 새로운 점을 생성하는 작업을 의미한다.   
이 작업은 아핀 조합이라고도 불린다.     
아핀 결합은 벡터의 선형 결합과 유사한 개념이지만, 점들 간의 상대적인 위치와 변환이 중요한 아핀 공간에서 사용된다.

두 개 이상의 점 $P_1, P_2, ..., P_n$과 그에 해당하는 가중치 $w_1, w_2, ..., w_n$가 주어졌을 때, 이들을 아핀 결합하여 새로운 점 $Q$를 생성하는 수식은 다음과 같다:

$Q = w_1P_1 + w_2P_2 + ... + w_nP_n$

이 수식에서 각 가중치 $w_i$는 실수 값이며, 가중치의 합은 1이어야 한다: $w_1 + w_2 + ... + w_n = 1.$

아핀 결합은 점들 간의 상대적인 위치를 나타내는 중요한 개념이다.     
예를 들어, 세 점 $A, B, C$의 아핀 결합 $P = w_AA + w_BB + w_CC$는 이 세 점을 가중치 $w_A, w_B, w_C$에 따라 섞은 결과로, $P$의 위치는 $A, B, C$의 상대적인 위치에 의해 결정된다.

아핀 결합은 아핀 공간에서 다양한 작업에 사용된다.   
예를 들어, 선형 보간, 다각형의 내부 계산, 그리고 그래픽스에서 곡선의 표현 등에서 사용된다.

# 9.4. 선 그리기 알고리즘
아핀 공간에서 선 그리기 알고리즘은 주어진 두 점을 연결하여 직선을 그리는 과정을 나타내는 알고리즘이다.  
이 알고리즘은 컴퓨터 그래픽스 분야에서 매우 중요한 역할을 하며, 선분을 화면에 그리는 데에 사용된다.     
여러 선 그리기 알고리즘이 개발되었는데, 그 중 가장 간단한 것 중 하나는 Bresenham's Line Algorithm이다.

Bresenham's Line Algorithm은 점 $P(x_1, y_1)$와 점 $Q(x_2,y_2)$를 연결하여 선을 그리는 알고리즘이다.    
이 알고리즘은 기울기가 0보다 작은 경우와 0보다 큰 경우, 그리고 두 점이 수직한 경우 등을 모두 처리할 수 있다.    
알고리즘의 핵심은 픽셀 간의 거리와 기울기를 이용하여 어떤 픽셀을 선택할지 결정하는 것이다.

Bresenham's Line Algorithm의 간략한 설명은 다음과 같다:

1. 두 점 $P(x_1,y_1)와 $Q(x_2,y_2)$를 입력으로 받는다.
2. 점 $P$를 기준으로 시작하며, 각 단계마다 픽셀을 선택하고 다음 픽셀을 결정한다.
3. 기울기를 기준으로 직선의 방향을 결정하고, 픽셀 간의 거리를 이용하여 다음 픽셀의 위치를 선택한다.
4. 직선의 방향에 따라 x 좌표 또는 y 좌표를 하나씩 증가시키면서 픽셀을 선택한다.

이 알고리즘은 계산량이 적고, 단순한 방식으로 선을 그릴 수 있어서 과거에는 많이 사용되었다.  
하지만 현대의 그래픽스 하드웨어은 더 정교한 알고리즘을 사용하며, 더 부드럽고 정교한 선을 그릴 수 있게 되었다.   

# 9.4.1. 벡터를 모니터의 점으로 표현
아핀 공간에서 벡터를 모니터의 점으로 표현하는 과정은 컴퓨터 그래픽스에서 벡터를 화면 상에 표현하는 작업을 의미한다.     
이 작업은 컴퓨터 그래픽스 애플리케이션에서 객체나 도형을 화면에 그릴 때 사용된다.

일반적으로 모니터나 디스플레이는 그리드 형태의 픽셀로 구성되어 있다.    
각 픽셀은 특정 색상을 가지며, 이러한 픽셀을 조합하여 그림을 만들어낸다.     
이때 아핀 공간의 벡터를 모니터의 픽셀 좌표로 변환하는 과정은 다음과 같이 진행된다:

1. 모델 좌표 변환(Model Coordinate Transformation): 객체나 도형의 모델 좌표를 정의한다.     
이 모델 좌표는 일반적으로 상대적인 크기 및 위치 정보를 가지고 있다.
2. 월드 좌표 변환(World Coordinate Transformation): 모델 좌표를 월드 좌표로 변환한다.   
월드 좌표는 전체 그래픽스 공간에서 객체의 위치와 방향을 나타낸다.   
이 단계에서 크기 변환, 회전 변환, 이동 변환 등을 수행할 수 있다.
3. 뷰포트 변환(Viewport Transformation): 월드 좌표를 실제 화면의 뷰포트 좌표로 변환한다.    
이때 뷰포트는 화면 상에서 어떤 영역에 그림을 그릴 것인지를 지정하는 영역이다.   
뷰포트 변환은 월드 좌표를 화면에 맞는 좌표로 조정한다.
4. 투영 변환(Projection Transformation): 뷰포트 변환된 좌표를 2D 투영 좌표로 변환한다.  
이 단계에서 원근감을 추가하여 3D 공간을 2D 화면에 표현할 수 있다.
5. 디바이스 좌표 변환(Device Coordinate Transformation): 투영된 2D 좌표를 디바이스 좌표로 변환한다.     
디바이스 좌표는 실제 모니터나 디스플레이의 픽셀 좌표를 의미한다.
6. 클리핑과 래스터화(Clipping and Rasterization): 디바이스 좌표로 변환된 객체들을 화면에 표시할 영역 내에서 잘라내고, 픽셀 단위로 변환하여 표시될 부분을 결정한다.
7. 색칠 및 그림 그리기: 래스터화된 픽셀들에 색상을 할당하고, 필요한 그림을 화면에 그린다.

3D 벡터를 모니터의 점으로 표현하는 과정은 복잡한 계산과 변환을 포함하지만, 그 결과로 3D 객체를 2D 화면에서 시각적으로 표현할 수 있게 된다.  
이러한 과정을 그래픽스 파이프라인이라고 부르며, 그래픽스 애플리케이션에서 3D 시각화를 구현하는 핵심 과정 중 하나이다.

# 9.4.2. 라인 클리핑 알고리즘
아핀 공간에서의 라인 클리핑 알고리즘은 주어진 라인 또는 선분을 특정 영역 내로 잘라내는 작업을 의미한다.     
이는 그래픽스에서 화면에 표시할 범위 내에 있는 객체를 제외한 부분을 제거하는 작업으로, 특히 2D 그래픽스에서 중요한 역할을 한다.     
여러 라인 클리핑 알고리즘이 개발되었는데, 그 중에는 Cohen-Sutherland 알고리즘과 Liang-Barsky 알고리즘이 널리 사용된다.

Cohen-Sutherland 알고리즘은 2D 공간을 9개의 영역으로 나누고, 라인의 각 점을 이 영역에 따라 분류하는 방식을 사용한다.    
이때, 화면 영역과 라인의 각 점이 어느 영역에 속하는지를 판별하여 영역 내에 있는 점을 선택하거나, 화면 영역 밖에 있는 점을 제거하여 라인을 잘라낸다.     
이 알고리즘은 빠르고 간단한 방식으로 클리핑을 수행할 수 있다.

Liang-Barsky 알고리즘은 Cohen-Sutherland 알고리즘보다 좀 더 정교한 방법으로 라인 클리핑을 수행한다.     
이 알고리즘은 화면 영역을 벗어나지 않는 라인 세그먼트에 대해 더 정확한 클리핑을 수행할 수 있다.     
Liang-Barsky 알고리즘은 라인의 각 점이 화면 영역 밖에 있는지, 내부에 있는지를 판별하여 클리핑을 수행하며, 계산량이 좀 더 복잡하지만 정교한 결과를 제공한다.

라인 클리핑 알고리즘은 그래픽스 애플리케이션에서 뷰포트 내에 있는 부분만을 처리하고 불필요한 계산을 줄이는 데에 중요한 역할을 한다.     
이를 통해 객체들을 효율적으로 화면에 표시할 수 있게 된다.

# 10. 메시
컴퓨터 그래픽스에서의 "메시"는 3D 객체를 구성하는 정점(Vertex)과 그 정점들을 연결하는 면(Face)으로 이루어진 구조를 의마한다.    
메시는 3D 모델을 표현하고 저장하기 위한 중요한 개념으로, 그래픽스 애플리케이션에서 다양한 객체를 만들고 표현하는 데 사용된다.

메시는 다음과 같은 요소로 구성된다:

1. 정점(Vertex): 정점은 3D 공간 상의 하나의 점을 나타낸다.  
각 정점은 위치 좌표(x,y,z)를 포함하여, 종종 색상, 텍스처 좌표, 법선 벡터 등의 추가 정보도 포함할 수 있다.   
정점은 3D 모델의 모양과 성질을 결정하는데 중요한 역할을 한다.
2. 면(Face): 면은 정점들의 연결로 구성되며, 이 연결을 통해 실제 객체의 표면을 나타낸다.     
3D 모델을 만들 떄 면들을 조합하여 객체의 형태를 결정하며, 이때 면의 종류에 따라 삼각형(Triangle), 사각형(Quadrilateral) 등이 사용될 수 있다.
3. 인덱스(Index): 메시의 정점을 저장할 때 중복되는 정점을 줄이고 메모리 사용량을 최적화하기 위해 인덱스를 사용하는 경우가 있다.     
이는 정점들의 순서를 인덱스로 참조하여 면을 구성하는 방식이다.
4. 텍스처 좌표(Texture Coordinates): 객체에 텍스처를 입히기 위해 각 정점에 텍스처의 어느 부분을 매핑할 것인지를 나타내는 좌표이다.

메시는 컴퓨터 그래픽스에서 3D 모델을 표현하고 처리하는 핵심적인 구조이다.   
메시를 이용하면 다양한 형태의 객체와 표면을 생성하고 조작할 수 있으며, 조명, 재질, 텍스처 등을 적용하여 현실적이고 다양한 시각적 효과를 구현할 수 있다.     
메시의 분할, 변환, 클리핑, 래스터화 등의 작업은 그래픽스 파이프라인의 중요한 단계 중 하나이다.

# 10.1. 무게중심좌표
메시의 무게중심좌표는 3D 메시(3D 모델의 정점과 면으로 이루어진 구조) 내의 정점들의 무게를 고려하여 계산된 평균 위치를 나타내는 좌표이다.    
이는 메시가 어디에 위치하며 어떻게 균형을 이루는지를 나타내는 중요한 개념이다.

메시의 무게중심좌표를 계산하는 방법은 다음과 같다:

1. 정점의 무게(weight) 계산: 각 정점은 일반적으로 추가 정보인 무게(weight)를 가지고 있다.   
이 무게는 해당 정점이 메시의 무게중심에 얼마나 기여하는지를 나타내는 값이다.    
이 값은 주로 정점의 면적, 부피, 질량 등과 관련되며, 그래픽스 애플리케이션에 따라 다르게 정의될 수 있다.
2. 무게중심 계산: 메시의 모든 정점들의 무겔르 사용하여 각 좌표 축(x,y,z)에 대한 가중 평균을 계산한다.   
이를 통해 메시의 무게중심 좌표가 구해진다.

메시의 무게중심은 물리 시뮬레이션, 모델의 배치 및 애니메이션, 그리고 렌더링 등 다양한 그래픽스 작업에서 활용될 수 있다.

# 10.2. 정점에 설정된 부가 정보의 활용
메시 정점에 설정된 부가 정보는 3D 모델의 정점에 대한 추가적인 데이터를 의미한다.    
이러한 정보는 그래픽스 애플리케이션에서 다양한 목적으로 활용될 수 있다.     
아래는 메시 정점에 설정된 부가 정보의 일부 활용 예시이다:

1. 색상 정보: 정점마다 특정 색상 정보를 가질 수 있다.   
이를 활용하여 3D 모델의 다양한 부분에 다른 색상을 입힐 수 있다.     
예를 들어, 각 정점을 다른 색상으로 설정하여 물체를 다채롭게 표현하거나, 그라데이션 효과를 만들 수 있다.
2. 텍스처 좌표: 정점에 텍스처 좌표를 할당하여 텍스처 이미지의 어느 부분을 정점에 매핑할 것인지를 지정할 수 있다.    
이를 통해 3D 모델에 텍스처를 입히거나, 물체의 일부에만 특정 이미지를 입힐 수 있다.
3. 법선 벡터: 정점에 법선 벡터를 할당하여 면의 방향과 표면 노말을 정의할 수 있다.   
법선 벡터는 조명과 그림자 계산, 셰이딩 등의 작업에서 중요한 역할을 한다.
4. 애니메이션 정보: 애니메이션을 위해 정점마다 변형 정보를 설정할 수 있다.  
이를 활용하여 모델의 움직임이나 변형을 지정할 수 있다.  
예를 들어, 캐릭터의 관절 부분을 움직이는 애니메이션에 사용될 수 있다.
5. 추가 속성 정보: 정점에는 위에서 언급한 것 외에도 다양한 추가 정보를 할당할 수 있다.  
예를 들어, 투명도 정보, 반사도 정보, 표면의 거칠기 정보 등을 정점에 설정하여 렌더링 효과를 조작할 수 있다.

이러한 부가 정보는 그래픽스 애플리케이션에서 시각적인 다양성을 확보하고 더 현실적인 결과물을 얻기 위해 사용된다.    
다양한 효과를 표현하거나 모델의 시각적 품질을 향상시키는 데 활용되며, 모델의 다양한 특성을 정밀하게 제어하는 데 중요힌 역할을 한다.

# 10.3. 텍스처 매핑
텍스처 매핑은 3D 그래픽스에서 객체의 표면을 텍스처 이미지로 입히는 작업을 의미한다.     
이를 통해 객체에 디테일한 색상, 패턴, 이미지 등을 추가하여 더 현실적이고 다양한 시각적 효과를 구현할 수 있다.   

텍스처 매핑은 주로 다음과 같은 단계로 이루어진다:

1. 텍스처 생성: 텍스처 매핑을 위해서는 먼저 텍스처 이미지를 준비해야 한다.  
이 이미지는 보통 JPEG, PNG 등의 형식으로 저장되며, 객체의 표면에 표시할 디테일이나 색상 정보가 포함된다.
2. 텍스처 좌표 설정: 메시의 각 정점에 텍스처 좌표를 할당한다.   
텍스처 좌표는 텍스처 이미지 상에서 어떤 부분을 해당 정점에 매핑할 것인지를 나타내는 값이다.     
텍스처 좌표는 일반적으로 (u,v) 좌표로 표현되며, 각 정점마다 해당 텍스처의 어느 부분을 사용할 것인지를 지정한다.
3. 텍스처 매핑 계산: 텍스처 좌표를 기반으로 실제 텍스처 이미지에서 해당 위치의 색상을 가져온다.     
이를 활용하여 각 정점에서 텍스처의 색상을 보간하여 표면 상에 텍스처를 입힌다.
4. 셰이딩과 조명 적용: 텍스처 매핑된 표면에 빛의 조명이나 그림자 효과 등을 적용하여 현실적인 느낌을 만들어낸다.     
텍스처 매핑은 그림자와 반사 등을 시뮬레이션하기 위해 사용되는 데 중요한 역할을 한다.

텍스처 매핑은 게임 그래픽스, 가상현실, 시뮬레이션 등 다양한 분야에서 사용된다.  
객체의 표면을 현실적으로 보이게 하거나 특정 효과를 구현하는 데 유용하며, 텍스처의 다양한 매핑 기법과 효과를 조합하여 다양한 시각적 품질을 얻을 수 있다.

# 11. 게임 엔진
수학은 게임 엔진의 핵심적인 요소로 사용되며 다양한 게임 시스템과 시각적 효과를 구현하는 데 필수적이다.  
아래는 수학과 게임 엔진 간의 연관성에 대한 설명이다:

1. 3D 그래픽스 및 물리 시뮬레이션: 게임은 보통 3D 공간에서 동작하는데, 3D 그래픽스를 구현하기 위해서는 선형 대수학과 행렬 연산을 활용해야 한다.     
이를 통해 객체의 변환, 회전, 크기 조절 등을 구현하고 물체의 충돌, 운동 등을 모델링하는 데 사용된다.
2. 벡터 및 행렬 연산: 게임에서는 객체의 위치, 방향, 속도 등을 다차원 공간에서 표현해야 한다.    
이를 위해 벡터와 행렬 연산이 사용되며, 게임 엔진은 이러한 연산을 효율적으로 처리하는 데 중요한 역할을 한다.
3. 물리 엔진: 게임에서 물리 시뮬레이션은 중요한 요소 중 하나이다.   
물리 엔진은 물체의 운동, 중력, 충돌, 힘의 적용 등을 모델링하여 현실적인 동작을 구현한다.    
이를 위해 뉴터의 운동 법칙, 적분, 미분 등의 수학적 개념이 활용된다.
5. 조명과 셰이딩: 게임에서는 조명과 셰이딩을 통해 그래픽스의 현실감을 높이는 데 수학적인 계산이 필요하다.   
광원의 위치, 표면의 법선 벡터, 재질의 반사 특성 등을 고려하여 조명 효과를 계산한다.
6. 데이터 구조와 알고리즘: 게임은 대량의 데이터를 효율적으로 처리해야 한다.     
데이터 구조와 알고리즘을 통해 빠른 렌더링, 충돌 감지, 경로 탐색 등을 구현한다.
7. 수학적 시뮬레이션: 게임에서는 현실적인 상황을 시뮬레이션하기 위해 수학적 모델을 사용한다.    
경기장의 물리, 인공지능 행동, 경제 시뮬레이션 등 다양한 분야에서 수학적 모델링이 사용된다.

게임 엔진은 이러한 수학적 개념과 기술을 모아 효율적으로 동작하도록 설계된다.

# 11.1. 게임 엔진의 구성 요소
게임 엔진은 복잡한 시스템으로, 다양한 기능을 수행하기 위해 여러 구성 요소로 나누어진다.     
아래는 대표적인 게임 엔진의 구성 요소들이다:

1. 렌더링 엔진(Rendering Engine): 그래픽 처리를 담당하는 부분으로, 3D 렌더링, 쉐이딩, 조명, 텍스처 매핑 등을 수행한다.  
2D 및 3D 객체를 화면에 렌더링하여 시각적인 효과를 만든다.
2. 물리 엔진(Physics Engine): 물리 시뮬레이션을 다루는 부분으로, 물체의 운동, 충돌, 중력 등을 모델링하여 현실적인 동작을 시뮬레이션한다.
3. 애니메이션 엔진(Animation Engine): 캐릭터 및 객체의 애니메이션을 제어하고, 보간(interpolation) 기술을 사용하여 부드러운 모션을 생성한다.
4. 사운드 엔진(Sound Engine): 게임 내의 음향 효과, 배경 음악 등을 재생하고 관리한다.    
3D 위치음향, 음향 효과 등을 다룬다.
5. 인풋 엔진(Input Engine): 사용자 입력을 처리하고, 키보드, 마우스, 조이스틱 등의 입력 장치와 상호작용한다.
6. 인공지능 엔진(Artificial Intelligence Engine): NPC(non-player character)의 행동을 조절하고, 경로 탐색, 의사 결정 등을 다루어 인공지능을 시뮬레이션한다.
7. 씬 그래프(Scene Graph): 게임 내의 객체들의 계층 구조와 관계를 나타내는 구성 요소로, 객체의 위치, 회전, 스케일 등을 관리한다.
8. 자원 관리(Resource Management): 텍스처, 모델, 사운드 파일 등 게임에 사용되는 자원들을 관리하고 로드하여 사용한다.
9. 데이터베이스 관리(Database Management): 게임의 상태, 플레이어 정보, 저장된 데이터 등을 관리하며 필요한 데이터를 저장 및 검색한다.
10. 데이터 시스템(Data System): 게임 내에서 사용되는 데이터의 구조와 관리를 담당하며, 게임의 설정, 레벨 디자인, 스토리 등을 저장하고 조작한다.
11. UI 엔진(User Interface Engine): 게임의 사용자 인터페이스 요소를 디자인하고 관리한다.    
메뉴, 버튼, 텍스트 등을 표시하고 상호 작용할 수 있게 한다.
12. 파일 시스템(File System): 게임 파일들을 읽고 쓰며, 자원들의 경로와 저장 위치를 관리한다.

게임 엔진은 이러한 구성 요소들을 통합하여 게임을 개발하고 실행하는 환경을 제공한다.     
이들 요소는 서로 협력하여 게임의 시각적, 음향적, 물리적 요소를 통합하고 게임 플레이어에게 원활한 경험을 제공하는 데 기여한다.

# 11.1.1. 씬의 구조
씬(Scene)의 구조와 수학은 게임 개발에서 중요한 역할을 하는데, 수학은 씬 내의 객체의 위치, 변환, 렌더링, 물리 시뮬레이션 등을 다루는 데 필수적이다.  
아래는 씬의 구조와 수학의 연관성에 대한 설명이다:

1. 객체의 위치와 변환(Transformations): 씬 내의 객체는 3D 공간 상에서 위치하며, 이들 객체의 위치, 회전, 크기 조절 등의 변환은 수학적 행렬 연산을 통해 이루어진다.   
이동 변환, 회전 변환, 크기 변환 등을 표현하고 조직화하기 위해 선형 대수학의 행렬과 벡터 연산이 사용된다.
2. 뷰 프로젝션(View Projection): 객체가 3D 공간에서 화면에 투영되는 과정에서 수학적 프로젝션 변환을 사용한다.   
이를 통해 카메라 시점에 따라 객체의 3D 좌표를 2D 화면 좌표로 변환하며, 플레이어의 시야를 시뮬레이션한다.
3. 렌더링(Rendering): 씬 내의 객체를 렌더링하기 위해서는 객체의 변환, 조명, 재질, 텍스처 매핑 등이 필요하다.    
이들 요소를 조합하여 물체의 표면을 계산하고 화면에 그리는데, 이 과정에서 선형 대수학 및 행렬 연산이 사용된다.
4. 물리 시뮬레이션(Physics Simulation): 물리 시뮬레이션은 씬 내의 물체의 운동, 충돌, 중력 등을 모델링한다.  
뉴턴의 운동 법칙, 적분, 미분 등의 수학적 개념을 활용하여 객체의 동작을 시뮬레이션한다.
5. 수학적 보간(Interpolation): 애니메이션과 보간은 씬 내의 객체의 움직임을 부드럽게 만드는 데 사용된다.     
베지어 곡선, 쿼터니언 등의 수학적 보간 기법을 활용하여 객체의 변화를 조절한다.
6. 콜리전 검출(Collision Detection): 씬 내의 객체 간의 충돌을 검출하려면 수학적 계산이 필요하다.    
객체의 형상을 기반으로 충돌을 감지하고 처리하는데 수학적 알고리즘이 사용된다.
7. 좌표 변환(Coordinate Transformations): 씬 내에서 다양한 좌표계를 사용해야 할 때, 좌표 변환을 수행한다.   
이는 객체를 다른 공간으로 이동시키거나 회전시키는 등의 작업에 사용된다.
8. 상호 작용과 위치 계산(Interaction and Position Calculation): 사용자 입력과 게임 객체의 상호 작용은 수학적 계산을 통해 이루어진다.    
마우스 클릭 위치의 화면 좌표를 3D 공간의 객체 위치로 변환하는 등의 작업에서 수학이 활용된다.

씬 내의 수학적 계산은 게임 엔진의 다양한 구성 요소에서 필수적으로 사용되며, 게임의 시각적, 물리적, 상호 작용적 요소들을 제어하는 데 중요한 역할을 한다.

# 11.1.2. 모델링 행렬의 설계
모델링 행렬(Modeling Matrix)은 3D 그래픽스에서 객체의 위치, 회전, 크기 조절 등의 변환을 수행하는 데 사용되는 행렬이다.  
모델링 행렬은 객체의 로컬 좌표 공간(Local Coordinate Space)에서 월드 좌표 공간(World Coordinate Space)으로의 변환을 나타내며, 객체의 모양을 결정하는 중요한 역할을 한다.

모델링 행렬의 설계는 다음과 같은 단계를 포함한다:

1. 이동: 객체의 위치를 조정하기 위해 이동 변환을 적용한다.     
이동 변환은 3D 공간에서 객체를 지정된 위치로 옮기는 것을 의미한다.  
이동 변환은 3D 공간에서 특정 위치만큼 x, y, z 축 방향으로 이동하는 행렬로 나타낼 수 있다.
2. 회전: 객체의 방향을 조정하기 위해 회전 변환을 적용한다.  
회전 변환은 객체를 기준 축 주변으로 회전시키는 것을 의미한다.   
회전은 일반적으로 쿼터니언이나 오일러 각 등의 방식으로 표현되며, 이를 행렬로 변환하여 모델링 행렬에 적용한다.
3. 크기 조절: 객체의 크기를 조절하기 위해 크기 조절 변환을 적용한다.    
크기 조절 변환은 객체의 x, y, z 축 방향으로의 확대 또는 축소를 나타낸다.    
크기 조절 변환은 대각 행렬로 나타내며, 크기 조절 요소가 대각선 요소에 위치한다.
4. 변환의 조합(Combining Transformations): 이동, 회전, 크기 조절 등의 변환을 모두 하나의 모델링 행렬로 결합한다.    
변환 순서에 따라 결과가 달라지므로, 일반적으로 변환 순서는 이동 -> 회전 -> 크기 조절로 적용된다.    
변환 행렬을 곱하여 모델링 행렬을 생성한다.
5. 로컬 -> 월드 변환(Local to World Transfomation): 겍체의 로컬 좌표 공간에서 월드 좌표 공간으로의 변환을 위해 모델링 행렬을 사용한다.  
이 모델링 행렬은 객체가 월드 공간에서의 위치, 방향 및 크기를 정의한다.

모델링 행렬은 게임 오브젝트의 변환을 통해 객체의 모양, 위치, 방향 등을 조작하는 데 사용된다.    
이를 통해 게임 개발자는 객체의 시각적 표현과 움직임을 자유롭게 제어하며, 다양한 시각적 효과와 애니메이션을 구현할 수 있다.

# 11.1.3. 로컬 공간과 로컬 축
로컬 공간(Local Space)은 객체의 자체적인 좌표 공간을 의미한다.  
이 공간은 객체가 어떤 변환이나 이동도 적용되지 않은 초기 상태의 공간이다.   
로컬 공간은 객체의 로컬 좌표 시스템을 기준으로 정의되며, 객체의 중심이 원점이 되고 로컬 축이 정의된다.

로컬 축(Local Axes)은 객체의 로컬 공간 내에서의 기준 축을 나타낸다.     
일반적으로 로컬 축은 객체의 모양과 방향에 따라 정의된다.    
객체의 로컬 축은 세 가지 주요 방향을 나타내며, 주로 x, y, z 축으로 표현된다.    
이 축들은 객체의 로컬 공간 내에서의 방향을 결정하며, 이를 기반으로 객체의 위치, 회전, 크기 조절 등의 변환을 수행한다.

로컬 공간과 로컬 축은 객체 간의 상대적인 관계를 표현하는 데 사용된다.   
예를 들어, 하나의 부모 객체와 여러 개의 자식 객체가 있다고 가정하면, 부모 객체의 로컬 공간 내에서의 변환이 자식 객체에 영향을 주면, 자식 객체는 부모 객체의 로컬 공간을 기준으로 위치하게 된다.     
이렇게 함으로써 부모 객체의 변환에 따라 자식 객체도 변환되는 계층 구조를 만들 수 있다.

로컬 공간과 로컬 축은 3D 그래픽스에서 객체의 계층 구조와 변환을 처리하는 중요한 개념이다.   
이를 통해 객체의 상대적인 위치와 방향을 쉽게 정의하고 제어할 수 있으며, 계층 구조를 구현하여 복잡한 모델링과 에니메이션을 가능하게 한다.

# 11.2. 카메라 시스템
수학은 게임 엔진의 카메라 시스템을 설계하고 구현하는 데 필수적인 역할을 한다.   
카메라 시스템은 플레이어의 시야와 화면 표시를 관리하는데 사용되며, 수학적인 개념과 계산을 통해 다양한 시각 효과를 구현할 수 있다.   
아래는 수학과 카메라 시스템의 연관성을 설명한 것이다:

1. 투영 변환(Projection Transformation): 카메라 시스템에서 가장 중요한 개념 중 하나로, 3D 공간의 객체를 2D 화면에 투영하는 과정을 다룬다.   
수학적인 투영 변환은 원근감을 표현하고 원하는 시점에서의 시야를 시뮬레이션한다.
2. 카메라 위치와 방향 결정: 수학은 카메라의 위치와 방향을 결정하는 데 사용된다.     
벡터와 행렬 연산을 활용하여 카메라의 위치와 방향을 3D 공간에서 정의하고 변환한다.
3. 카메라 시점 조작: 수학적인 계산을 사용하여 카메라 시점을 조작하고 변경할 수 있다.    
사용자 입력에 따라 카메라를 회전, 이동시키거나 줌 인/아웃을 구현할 수 있다.
4. 시야 범위 설정: 수학적인 개념을 사용하여 카메라의 시야 범위를 정의하고 조절할 수 있다.   
시야각과 가시 거리 등을 계산하여 플레이어의 시야를 제어한다.
5. 화면 공간 변환(Screen Space Transformation): 화면 좌표 공간으로의 변환을 수행하여 게임 객체를 화면에 렌더링한다.     
이 과정에서 픽셀 좌표와 화면 해상도를 고려하여 변환 계산이 필요하다.
6. 카메라 쿼터니언 사용: 쿼터니언(quaternion)은 카메라 회전을 효율적으로 다루는데 사용된다.     
회전을 오일러 각으로 표현하는 것보다 쿼터니언을 사용하면 회전 문제를 해결하기 용이하다.
7. 카메라 추적 및 보간: 수학적 보간법을 활용하여 카메라를 특정 위치로 부드럽게 이동시키거나 추적하는데 사용된다.    
선형 보간, 스플라인 보간 등을 적용하여 자연스러운 카메라 움직임을 구현한다.
8. 카메라 스크린샷: 카메라가 렌더링하는 화면을 이미지로 저장하는데 수학적인 계산을 활용한다.    
뷰 프로젝션 및 화면 좌표 변환을 통해 스크린샷을 생성한다.

카메라 시스템은 게임에서 시각적 표현을 제어하는 중요한 요소이며, 이를 효과적으로 구현하기 위해 수학의 다양한 개념과 기법을 활용한다.

# 12. 오일러 각
오일러 각(Euler angles)은 객체의 3차원 공간 내에서의 회전을 나타내는 수학적인 표현 방법이다.    
세 개의 각도로 회전을 정의하여 객체를 다양한 방향으로 회전시킬 수 있다.     
이 방법은 간단하고 직관적이지만, 몇 가지 문제점을 가지고 있기도 하다.

오일러 각은 일반적으로 세 개의 회전 각도로 구성된다:

1. 롤 각 (Roll Angle): X축을 중심으로 회전하는 각도로, 오브젝트를 좌우로 기울이는 회전을 나타낸다.
2. 피치 각 (Pitch Angle): Y축을 중심으로 회전하는 각도로, 오브젝트를 위아래로 기울이는 회전을 나타낸다.
3. 요우 각 (Yaw Angle): Z축을 중심으로 회전하는 각도로, 오브젝트를 좌우로 회전시키는 회전을 나타낸다.

이 세 개의 각도를 조합하여 오브젝트의 회전을 표현할 수 있다.    
예를 들어, 먼저 롤 각을 적용한 후 피치 각과 요우 각을 차례로 적용하면 다양한 방향의 회전을 만들 수 있다.

하지만 오일러 각은 "진동"이나 "잠금"과 같은 문제를 가지고 있다.     
예를 들어, 회전을 연속적으로 적용하다 보면, 어느 순간에는 원래의 방향으로 돌아오지 않는 현상이 발생할 수 있다.  
이러한 현상을 짐벌락(gimbal lock)이라고 한다.   
또한 회전 순서에 따라 결과가 달라지는 문제도 있다.

오일러 각은 간단한 회전을 표현하는 데는 유용하지만, 복잡한 회전을 다루거나 연속적인 회전을 처리하는데는 한계가 있다.    
따라서 더 복잡한 회전을 다루기 위해 쿼터니언(quaternion)과 같은 다른 회전 표현 방법을 사용하는 경우도 많다.

# 12.1. 오일러 각의 특징
오일러 각을 사용할 때 고려해야 할 중요한 점들:

1. 직관적이고 간단한 표현: 오일러 각은 롤, 피치, 요우 각 세 개의 각도로 회전을 표현하기 때문에 직관적이며 이해하기 쉽다.
2. 회전 순서의 영향: 오일러 각은 회전 순서에 따라 결과가 달라지는 문제를 가진다.    
예를 들어, X -> Y -> Z 축으로의 회전과 Y -> X -> Z 축으로의 회전은 서로 다른 결과를 나타낼 수 있다.
3. 짐벌락 문제(Gimbal Lock): 오일러 각은 특정한 회전 순서에서 짐벌락이라고 불리는 문제가 발생할 수 있다.    
이는 한 축의 회전이 제한되거나 다른 축의 회전이 힘을 잃는 현상으로, 객체의 자유도가 제한되는 문제이다.
4. 각도 제한: 오일러 각 중 하나의 각도가 90도에 도달하면 다른 각도들과 복잡한 상호작용을 일으켜 원하지 않는 결과를 초래할 수 있다.
5. 복잡한 회전을 다루기 어려움: 오일러 각은 복잡한 회전을 다루는데 어려움이 있다.   
예를 들어, 회전하는 객체에 다른 회전을 중첩하는 등의 복잡한 변환을 정확하게 표현하기 어렵다.

# 12.2. 짐벌락 현상
짐벌락(Gimbal Lock)은 오일러 각을 사용하는 경우에 발생할 수 있는 현상 중 하나로, 특정한 회전 순서에서 자유도가 제한되거나 회전이 예상대로 이루어지지 않는 문제이다.     
이로 인해 객체의 움직임이 예상치 못하게 제한되거나 예상과 다르게 나타날 수 있다.

짐벌락은 세 개의 회전 축(롤, 피치, 요우)을 사용하는 경우에 발생하는데, 특히 피치 각도가 $\pm 90$도에 가까워지는 경우에 문제가 발생한다.   
이러한 상황에서는 두 축이 일치하여 회전 자유도가 제한되며, 이로 인해 두 번째 회전 축이 자유롭게 회전할 수 없게 된다.

가장 일반적인 예로 XYZ 축 회전을 고려해보면, 만약 객체가 Y축으로 $\pm 90$도만큼 피치 회전을 하고 나서 X축 회전을 시도하면 Z축과 X축이 일치하게 되어 두 번째 회전 축인 X축의 회전이 불가능해지는 상황이 발생한다.     
이로 인해 원래의 자유로운 회전이 불가능하게 되는 것이 짐벌락의 문제점이다.

# 12.3. 회전 보간의 계산
회전 보간(rotation interpolation)은 두 개의 회전을 중간 값으로 스무딩하거나 움직이는 물체가 회전할 때 부드럽게 전환하기 위한 기술이다.      
회전 보간은 애니메이션, 게임, 컴퓨터 그래픽스 등에서 매끄러운 회전 전환이나 움직임을 만들어내는 데 사용된다.

보간은 두 개의 회전을 보간 함수를 사용하여 중간 값으로 스무딩하는 프로세스이다.     
주로 선형 보간과 쿼터니언 보간이 사용된다.

1. 선형 보간(Linear Interpolation):     
선형 보간은 두 개의 회전을 직선으로 연결하는 방식으로, 각 회전 각도를 따로 보간하여 중간 값으로 만든다.     
간단하게는 두 각도 사이의 중간 각도를 계산하거나, 회전 행렬의 성분을 보간하여 중간 행렬을 계산한다.     
선형 보간은 간단하지만 회전 각도가 크거나 특정 회전을 처리할 때 부정확할 수 있다.
2. 쿼터니언 보간(Quaternion Interpolation):     
쿼터니언 보간은 쿼터니언이라는 수학적 개념을 활용하여 회전을 부드럽게 전환하는 방식이다.    
쿼터니언은 회전을 나타내는데 더 적합한 표현 방법으로, 선형 보간보다 더 부드러운 움직임을 만들어낸다.    
쿼터니언 보간은 선형 보간보다 복잡하지만 정확하고 안정적인 결과를 제공한다.

회전 보간은 객체가 움직이거나 회전할 때 자연스러운 애니메이션을 만들어내기 위해 중요한 기술이다.    
보간 알고리즘을 사용하여 시작 회전과 목표 회전 사이의 중간 회전 값을 계산하면, 객체의 움직임이 부드럽고 현실적으로 느껴진다.

# 13. 백페이스 컬링
백페이스 컬링(Backface Culling)은 3D 그래픽스에서 사용되는 기술로, 카메라의 시점에 보이지 않는 뒷면을 렌더링하지 않고 건너뛰는 것을 의미한다.   
이 기술은 불필요한 연산을 줄이고 성능을 향상시키기 위해 사용된다.

3D 객체는 그릴 때 보이는 면과 보이지 않는 면이 있다.    
보이는 면은 카메라의 시점에서 볼 때 바라볼 수 있는 면이며, 보이지 않는 면은 카메라의 시점에서 볼 때 뒷편에 위치하는 면이다.     
백페이스 컬링은 이러한 보이지 않는 면을 그리지 않고 제외하는 기술로, 화면의 효율적인 렌더링을 위해 사용된다.

백페이스 컬링은 다음과 같은 원리로 동작한다:

1. 각 삼각형의 정점들은 보통 시계방향 또는 반시계방향으로 정렬되어 있다.    
이 방향을 정점의 순서에 따라 결정한다.  
2. 카메라의 시점에서 보이는 면은 정점들이 시계방향으로 정렬되어 있는 경우이다.  
반면, 카메라의 시점에서 보이지 않는 면은 정점들이 반시계방향으로 정렬되어 있는 경우이다.    
3. 백페이스 컬링은 보이지 않는 면을 그리지 않기 위해 이러한 방향을 이용한다.    
삼각형의 뒷면인 경우 렌더링을 스킵하고, 앞면인 경우에만 렌더링을 수행한다.

이러한 백페이스 컬링은 GPU 등의 그래픽 하드웨어에서 자동으로 처리되는 경우가 많다.  
이를 통해 불필요한 연산을 줄이고 성능을 향상시킬 수 있으며, 뒷면이 보이지 않도록 설정해야 할 때 유용하다.

# 14. 원근 투영
원근 투영(Perspective Projection)은 3D 공간에 있는 객체를 2D 화면에 투영하는 과정 중 하나로, 카메라 렌즈나 눈의 위치에서 발생하는 원근적인 효과를 모방하기 위해 사용된다.   
이러한 원근 투영은 3D 장면을 2D 화면에 그리거나 렌더링할 때 현실적인 깊이와 거리 효과를 제공한다.

카메라 시스템과 함께 사용되어 현실적인 시각적 효과를 제공하며, 3D 공간을 2D 화면으로 표현하는 데 중요한 역할을 한다.

# 14.1. 원근 투영 변환의 원리
1. 카메라 위치와 시점:  
원근 투영의 핵심은 카메라(또는 관찰자)의 위치와 시점이다.   
카메라는 3D 공간에서 특정 위치에 있으며, 화면을 바라본다.   
이 위치를 시점이라고 한다.
2. 시점과 객체 간의 직선 연결:  
원근 투영은 카메라 시점에서 객체의 각 점까지의 직선을 그린다.   
이 직선을 시점과 객체 사이의 시각선이라고 한다.
3. 투영 평면:   
2D 화면은 투영 평면(projection plane)으로 정의된다.     
이 투영 평면은 화면의 크기와 비율을 나타내며, 보통 카메라 렌즈의 위치와 평면 사이에 위치한다.
4. 투영 행렬:   
투영 행렬(projection matrix)은 카메라의 시점, 투영 평면, 시야각 등과 관련된 파라미터를 기반으로 생성된다.   
이 행렬은 3D 공간의 점을 2D 화면으로 변환하는데 사용된다.
5. 원근 투영 계산:  
3D 공간의 점을 투영 평면에 투영하기 위해, 해당 점에서 시점까지의 시각선을 따라 투영 평면과 만나는 지점을 찾는다.    
이 점이 투영된 2D 화면상의 위치가 된다.
6. 원근 효과:   
투영된 2D 화면상의 점은 원근적인 효과를 가지며, 시각적으로 먼 객체는 작게, 가까운 객체는 크게 보인다.   
이 효과는 시점과 투영 평면 간의 거리 및 시야각에 따라 결정된다.
7. 종합:    
위 과정을 모든 3D 공간의 점에 대해 반복하여 객체를 2D 화면으로 투영한다.    
결과적으로 3D 공간의 객체는 2D 화면에 그려진다.

객체의 실제적인 깊이와 거리 효과를 제공한다.    
이 원리를 이해하고 이를 구현하는 투영 행렬을 사용하여 3D 렌더링을 수행할 수 있다.

# 14.2. 깊이 값
원근 투영(Perspective Projection)에서의 깊이 값은 3D 공간에서 카메라 렌즈 또는 관찰자(시점)로부터 객체까지의 거리를 나타내는 중요한 개념이다.   
이 거리 정보는 3D 공간을 2D 화면에 투영하는 과정에서 중요한 역할을 한다.

원근 투영에서의 깊이 값에 대한 설명은 다음과 같다:

1. 깊이 값 표현: 3D 공간에서 카메라 렌즈 또는 관찰자로부터 객체까지의 거리를 깊이(depth)라고 한다.  
이 거리는 보통 양수로 표현되며, 카메라로부터 먼 객체는 큰 깊이 값을 갖고 가까운 객체는 작은 깊이 값을 갖는다.
2. 깊이 버퍼: 컴퓨터 그래픽스에서는 원근 투영의 깊이 값을 저장하고 관리하는 깊이 버퍼(depth buffer) 또는 Z-버퍼(Z-buffer)라고 하는 버퍼를 사용한다.     
깊이 버퍼는 화면의 각 픽셀에 해당하는 깊이 값을 저장한다.
3. 깊이 값 계산: 원근 투영 변환에서는 각 객체의 깊이 값은 카메라 위치와 객체의 위치 사이의 거리에 따라 결정된다.    
이 거리는 투영 행렬과 객체의 3D 좌표에 따라 계산된다.
4. 깊이 버퍼 사용: 렌더링 과정에서, 카메라 시점에서부터 객체까지의 거리와 깊이 값을 계산하고, 이를 깊이 버퍼에 저장한다.    
그런 다음, 픽셀 별로 객체들이 그려질 때 깊이 값을 확인하고, 가장 깊이 값이 작은 객체가 화면에 표시된다.     
이를 통해 원근 투영을 구현하고 깊이 순서를 제어할 수 있다.
5. 깊이 값의 활용: 깊이 값은 물체의 렌더링 순서, 가려진 표면 계산, 그림자 생성, 포커싱 효과 등 다양한 그래픽스 효과에 사용된다.     
또한 게임 및 시뮬레이션에서는 객체 간의 상대적인 거리를 파악하는 데 사용된다.

요약하면, 원근 투영의 깊이 값은 3D 공간에서 객체까지의 거리를 나타내며, 그래픽스 렌더링에서 객체의 표시 순서와 다양한 시각 효과를 제어하는 데 중요한 역할을 한다.

# 15. 절두체
절두체(Frustum)는 컴퓨터 그래픽스와 3D 렌더링에서 중요한 개념 중 하나로, 3D 공간에서 화면 또는 카메라 시야에 보이는 부분을 정의하고 제한하는 형태를 나타낸다.   
절두체는 렌더링 엔진에서 시야 플레인(Frustum Planes)이라고도 불린다.

절두체의 주요 특징과 역할에 대해 설명:

1. 시야 제한: 절두체는 카메라 렌즈로부터의 시야를 제한한다.     
이것은 무한히 큰 3D 공간을 화면에 보이는 부분만큼으로 제한하는 것이다.
2. 모양: 절두체는 일반적으로 두 개의 원뿔과 사각 기둥으로 구성된다.     
카메라 시점에서 시작하여, 시야 각도에 따라 원뿔의 꼭지점이 형성되고, 화면과의 거리에 따라 사각 기둥이 형성된다.
3. 클리핑: 절두체는 카메라 시야에 포함되지 않는 객체 또는 부분을 제거하고 클리핑하는 역할을 한다.   
즉, 화면에 그려지는 객체는 절두체 안에 위치해야 한다.
4. 뷰 프러스텀: 게임 및 3D 애플리케이션에서는 종종 "뷰 프러스텀(View Frustum)"이라고도 불리는 특수한 형태의 절두체를 사용한다.  
뷰 프러스텀은 뷰포트(Viewport)로 불리는 2D 화면 공간으로의 투영 영역을 나타낸다.    
3D 객체는 뷰 프러스텀 안에 들어가야만 화면에 그려진다.
5. 클리핑 플레인: 절두체는 일반적으로 여러 개의 클리핑 플레인으로 나뉜다.   
이러한 플레인은 절두체의 각 면을 나타내며, 객체가 절두체 밖으로 나갈 경우 해당 객체를 클리핑하여 그리지 않도록 한다.

절두체는 3D 렌더링에서 시야 밖의 객체를 제거하고, 화면에 보이는 부분만 렌더링하여 성능을 향상시키는 데 중요한 역할을 한다.  
이를 통해 화면의 효과적인 렌더링과 시각적 효과를 제어할 수 있다.    
게임 엔진 및 3D 그래픽 소프트웨어에서 절두체는 매 프레임마다 객체가 시야에 포함되는지 여부를 확인하여 렌더링할 객체를 결정하는 데 사용된다.

# 15.1. 절두체 컬링
절두체 컬링(Frustum Culling)은 3D 렌더링에서 사용되는 최적화 기술 중 하나로, 화면에 보이지 않는 부분의 객체를 렌더링 대상에서 제외하여 성능을 향상시키는 과정을 말한다.     
이 기술은 절두체(Frustum)라고 불리는 시야 부피의 형태를 이용하여 렌더링 대상 객체를 제한하는 방식으로 작동한다.

절두체 컬링의 주요 원리와 동작 방식을 설명:

1. 카메라 시야의 절두체 생성: 먼저, 현재 카메라의 시야에 해당하는 절두체가 생성된다.    
이 절두체는 카메라 시점에서 시작하여, 시야각과 종횡비 등을 고려하여 형성된다.   
절두체는 일반적으로 6개의 면으로 정의되는데, 이를 "클리핑 플레인"이라고 한다.
2. 객체의 위치 판단: 모든 렌더링 대상 객체(3D 모델)의 위치와 바운딩 박스(Bounding Box) 또는 바운딩 스피어(Bounding Sphere)와 같은 기하학적 정보를 고려하여, 이 객체들이 절두체 내부에 있는지 외부에 있는지 판단한다.
3. 절두체 컬링: 판단된 객체 중에서 절두체 내부에 위치한 객체들만을 렌더링 대상으로 선택한다.    
이렇게 하면 화면에 보이지 않는 객체들은 제외된다.
4. 렌더링: 최종적으로 절두체 컬링을 통과한 객체들만을 렌더링하여 화면에 표시된다.   
이로써 불필요한 객체를 렌더링하지 않아 성능이 향상된다.

절두체 컬링은 3D 환경에서 객체 수가 많고, 화면에 한 번에 표시되지 않는 객체들이 많은 상황에서 특히 중요하다.  
이 기술을 통해 렌더링의 부하를 줄이고, 불필요한 계산과 그래픽 작업을 방지하여 게임 또는 시뮬레이션의 성능을 최적화할 수 있다.

# 15.1.1. 평면의 방정식
절두체 컬링(Frustum Culling)에서 사용되는 평면의 방정식은 클리핑 플레인(Clip Planes)이라고도 불리며, 카메라 시야의 절두체(Frustum)를 정의하는데 사용된다.   
이러한 평면은 객체의 위치를 판단하고, 절두체 내부에 있는지 아닌지를 결정하는 데 사용된다.

일반적으로, 3D 공간에서 카메라 시야의 절두체를 정의하는 평면은 아래와 같은 방정식을 가진다:

1. 가까운 절두체 평면(Near Plane): 이 평면은 카메라에서 가장 가까운 뷰 프러스텀(View Frustum)의 부분을 나타낸다.    
이 평면은 카메라 시야에 가장 가까이 있는 객체를 클리핑하기 위해 사용된다.   
평면 방정식: Ax + By + Cz + D_near = 0
2. 원격 절두체 평면(Far Plane): 이 평면은 카메라에서 가장 먼 뷰 프러스텀의 부분을 나타낸다.     
이 평면은 원격에 있는 객체를 클리핑하기 위해 사용된다.  
평면 방정식: Ax + By + Cz + D_far = 0
3. 좌우 평면(Left Plane 및 Right Plane): 이 두 평면은 시야의 가로 범위를 나타낸다.  
카메라 시야가 좌우로 얼마나 넓은지를 제한하는 역할을 한다.  
왼쪽 평면 방정식: Ax + By + Cz + D_left = 0     
오른쪽 평면 방정식: Ax + By + Cz + D_right = 0
4. 상하 평면(Top Plane 및 Bottom Plane): 이 두 평면은 시야의 세로 범위를 나타낸다.  
카메라 시야가 위아래로 얼마나 높은지를 제한하는 역할을 한다.    
상단 평면 방정식: Ax + By + Cz + D_top = 0  
하단 평면 방정식: Ax + By + Cz + D_bottom = 0

여기서, (A, B, C)는 평면의 법선 벡터(Normal Vector)를 나타내며, (D_near, D_far, D_left, D_right, D_top, D_bottom)은 평면의 거리 상수를 나타낸다.    
이러한 방정식을 사용하여 객체의 위치를 검사하면, 객체가 절두체 내부에 있는지 아닌지를 판단할 수 있다.   
절두체 컬링은 이러한 평면들과 객체의 위치를 비교하여 렌더링 대상을 결정하는 중요한 최적화 기술이다.

# 15.1.2. 평면의 방정식의 정규화
평면의 방정식을 정규화(normalization)하는 것은 평면의 법선 벡터를 단위 벡터(unit vector)로 변환하는 과정을 의미한다.    
정규화는 일반적으로 벡터의 크기를 1로 만들어주는 작업을 수행하며, 이렇게 하면 평면 방정식의 해석이 간편해지고 계산도 효율적으로 이루어진다.

평면의 방정식은 일반적으로 다음과 같은 형태를 가진다:

$Ax + By + Cz + D = 0$

여기서 (A, B, C)는 평면의 법선 벡터이며, (D)는 평면의 거리 상수이다.    
정규화를 수행하려면 먼저 법선 벡터의 크기를 계산하고, 그 크기로 법선 벡터를 나누어야 한다.

법선 벡터의 크기를 계산하는 공식은 다음과 같다:

크기(Norm) = $\sqrt{(A^2 + B^2 + C^2)}$

이제 법선 벡터를 정규화하기 위해 각 구성 요소를 크기로 나눈다.

단위 벡터(Normalized) = $(A / Norm, B / Norm, C / Norm)$

이렇게 하면 평면의 방정식이 다음과 같이 정규화된다:

$(A / Norm)x + (B / Norm)y + (C / Norm)z + D / Norm = 0$

정규화를 수행하면 법선 벡터의 크기가 1이 되므로, 평면의 방정식을 더 쉽게 다룰 수 있고, 다양한 계산에서 효율적으로 사용할 수 있다.   
또한 정규화된 법선 벡터는 해당 평면의 방향을 나타내므로, 평면의 표면이 바라보고 있는 방향을 알 수 있다.

# 15.2. 바운딩 볼륨
바운딩 볼륨(Bounding Volume)은 객체나 모델의 형태를 근사적으로 나타내기 위한 가상의 기하학적 도형 또는 볼륨이다.    
바운딩 볼륨은 렌더링, 충돌 감지, 레이 트레이싱과 같은 다양한 그래픽 작업에서 성능을 향상시키고 복잡한 모델을 다루기 쉽게 만드는 데 사용된다.

바운딩 볼륨의 주요 특징과 목적:

1. 근사적인 형태: 바운딩 볼륨은 원래 객체의 형태를 근사적으로 나타낸다.     
이것은 복잡한 3D 모델을 더 단순한 형태(주로 상자 또는 구)로 근사화하여 계산 및 처리를 빠르고 효율적으로 만든다.
2. 충돌 감지: 바운딩 볼륨은 객체 간의 충돌 감지(Collision Detection)에 사용된다.    
객체의 실제 형태보다는 바운딩 볼륨 간의 충돌을 감지하여 더 복잡한 모델의 충돌을 판단하는 데 사용된다.   
3. 렌더링 최적화: 바운딩 볼륨은 렌더링 최적화에 사용된다.   
카메라 시야에 들어오는 객체를 결정할 때, 렌더링 대상을 결정하는 데 바운딩 볼륨을 사용하면 불필요한 객체를 렌더링하지 않고 성능을 향상시킬 수 있다.
4. 선택 및 피킹: 바운딩 볼륨은 마우스 클릭 또는 선택과 같은 사용자 상호 작용을 처리하는 데 사용된다.    
사용자가 클릭한 객체를 판별하기 위해 바운딩 볼륨을 사용하여 렌더링 대상을 선택할 수 있다.
5. 레이 트레이싱: 레이 트레이싱과 같은 복잡한 렌더링 기술에서도 바운딩 볼륨은 광선이 객체와의 교차를 검출하는 데 사용된다.  
이를 통해 광선-객체 교차 검출을 빠르게 수행할 수 있다.

주로 사용되는 바운딩 볼륨 유형으로는 경계 상자(Bounding Box), 경계 스피어(Bounding Sphere), 오브비(Bouding OBB), 경계 원통(Bouding Cylinder) 등이 있다.     
이러한 바운딩 볼륨을 적절히 선택하고 구현하면, 그래픽스 애플리케이션의 성능을 향상시키고 복잡한 계산을 단순화할 수 있다.

# 15.2.1. 구 바운딩 볼륨의 판정
구 바운딩 볼륨(Bounding Sphere)의 판정은 어떤 점이 또는 어떤 객체가 구 바운딩 볼륨 내부에 있는지 아니면 외부에 있는지를 결정하는 것을 의미한다.     
구 바운딩 볼륨은 중심과 반지름을 가지며, 이 정보를 사용하여 판정을 수행할 수 있다.

구 바운딩 볼륨 내부 판정을 수행하는 방법은 다음과 같다:

1. 구 바운딩 볼륨의 중심 계산: 먼저 구 바운딩 볼륨의 중심 좌표를 알아야 한다.   
이 중심은 구의 중심점을 나타낸다.
2. 구 바운딩 볼륨의 반지름 계산: 구의 반지름을 알아야 한다.     
반지름은 구의 중심으로부터 표면까지의 거리를 나타낸다.
3. 점의 위치 확인: 구 바운딩 볼륨 내부 판정을 수행하려면, 판정하려는 점(또는 객체의 중심점)과 구 바운딩 볼륨의 중심 사이의 거리를 계산한다.     
이 거리가 구의 반지름보다 작거나 같으면 해당 점 또는 객체는 구 바운딩 볼륨 내부에 있다.

구 내부 판정 수행 공식은 다음과 같다:   
거리 = $\sqrt{(X - centerX)^2 + (Y - centerY)^2 + (Z - centerZ)^2}$

여기서 (X, Y, Z)는 점 또는 객체의 위치 좌표이며, (centerX, centerY, centerZ)는 구 바운딩 볼륨의 중심 좌표이다.

1. 결과 확인: 계산한 거리를 구의 반지름과 비교한다.     
만약 거리가 반지름보다 작거나 같으면, 해당 점 또는 객체는 구 바운딩 볼륨 내부에 있다.   
그렇지 않으면 외부에 있다.

이 방법을 사용하면 간단하게 구 바운딩 볼륨 내부 판정을 수행할 수 있으며, 이 판정을 통해 렌더링 대상 객체를 결정하거나 충돌을 감지하는 등의 작업을 수행할 수 있다.

# 15.2.2. AABB와의 판정
AABB(Axis-Aligned Bounding Box)는 축에 정렬된 경계 상자로, 3D 공간에서 객체 또는 모델의 근사적인 형태를 표현하는 데 사용된다.   
AABB와의 판정은 어떤 점이 또는 어떤 객체가 AABB 내부에 있는지 또는 외부에 있는지를 결정하는 것을 의미한다.  
AABB는 각 축(일반적으로 x, y, z 축)에 대해 최소 점(minimum point)과 최대 점(maximum point)으로 정의되므로 이 정보를 사용하여 판정을 수행한다.

AABB 내부 판정을 수행하는 단계는 다음과 같다:

1. AABB의 최소 점과 최대 점 확인: AABB의 최소 점(Min)과 최대 점(Max)을 알아야 한다.     
이 두 점은 AABB의 대각선을 정의한다.
2. 점 또는 객체의 위치 확인: 판정하려는 점(또는 객체의 중심점)의 위치 좌표를 확인한다.
3. X, Y, Z 축별로 판정 수행: 판정을 수행하려는 점의 각 좌표(X, Y, Z)를 해당 축의 최소 점과 최대 점과 비교한다.
    - X 축 판정: Min.x <= X <= Max.x
    - Y 축 판정: Min.y <= Y <= Max.y
    - Z 축 판정: Min.z <= Z <= Max.z
4. 결과 확인: 위의 각 축별 판정을 모두 수행하여, 모든 축에서 점이 최소 점과 최대 점 사이에 있으면 해당 점 또는 객체는 AABB 내부에 있다.     
하나라도 벗어나면 AABB 외부에 있다.

AABB 판정은 렌더링, 충돌 감지, 객체 선택 및 피킹(Picking)과 같은 다양한 그래픽스 작업에 사용된다.   
객체의 복잡한 형태를 고려하지 않고 단순하게 AABB와의 교차를 판별함으로써 복잡한 계산을 간소화하고 성능을 향상시킬 수 있다.

# 15.3. 삼각형 클리핑
삼각형 클리핑은 절두체(Frustum) 내부에 포함되지 않는 삼각형을 제거하여 화면에 렌더링할 때 불필요한 계산을 줄이는 역할을 한다.   
이 과정은 렌더링 파이프라인의 일부로 수행되며, 다음과 같은 단계로 이루어진다:

1. 절두체 평면과 삼각형 교차 검출: 먼저 각 삼각형과 절두체의 각 평면(가까운 평면, 원격 평면, 좌우 평면, 상하 평면)과의 교차를 검출한다.     
이것은 각 삼각형의 모든 변이 평면과의 교차를 확인하는 것을 의미한다.
2. 삼각형 분할(Triangle Clipping): 삼각형의 변이 절두체의 평면과 교차하는 경우, 해당 변을 절두체 평면과 교차 지점에서 잘라 새로운 삼각형을 생성한다.    
이것은 원래의 삼각형을 절두체 내부로 들어갈 수 있도록 만드는 작업이다.
3. 삼각형 잘라내기(Triangle Clipping): 삼각형이 여러 개의 절두체 평면과 교차하는 경우, 이러한 교차 지점에서 삼각형을 잘라내어 절두체 내부로 들어갈 수 있는 부분을 남긴다.   
이 과정은 원래의 삼각형을 여러 개의 작은 삼각형으로 분할하는 것을 의미한다.
4. 삼각형 결정(Triangle Classification): 모든 교차 검출 및 분할이 완료되면, 각 삼각형은 절두체의 내부에 완전히 들어가거나, 절두체의 외부에 완전히 나가거나, 절두체와 교차하거나, 부분적으로 절두체와 교차하는 여러 종류로 분류된다.
5. 삭제 또는 렌더링: 절두체 내부에 완전히 들어가는 삼각형은 렌더링 대상으로 남기고, 절두체 외부에 있는 삼각형은 삭제한다.   
절두체와 교차하거나 부분적으로 교차하는 삼각형은 추가 처리가 필요하다.

이와 같은 과정을 통해 절두체 삼각형 클리핑은 불필요한 렌더링을 방지하고 성능을 향상시킨다.  
이러한 클리핑은 GPU에서 하드웨어 가속으로 수행되며 3D 그래픽스에서 렌더링 작업을 최적화하는 데 중요한 역할을 한다.

# 16. 복소수
복소수(Complex Number)는 실수(real number)와 허수(imaginary number)로 이루어진 수의 형태이다.   
복소수는 수학에서 중요한 개념으로, 실수만으로는 다루기 어려운 여러 수학적 문제와 방정식을 해결하는 데 사용된다.     
복소수는 다음과 같은 형태로 표현된다:   
$z = a + bi$

여기서,

- 'z'는 복소수를 나타내는 기호이다.
- 'a'는 실수 부분(Real Part)으로, 실수이다.
- 'b'는 허수 부분(Imaginary Part)으로, 실수와 'i' (허수 단위)의 곱으로 표현된다.    
'i'는 허수 단위로, $i^2 = -1$을 만족하는 수이다.

예를 들어, '2 + 3i'는 실수 부분이 2이고 허수 부분이 3인 복소수를 나타낸다.  
복소수의 허수 부분이 0인 경우, 이것은 순수한 실수이다.

복소수의 연산은 다음과 같이 정의된다:

- 덧셈: $(a + bi) + (c + di) = (a + c) + (b + d)i$
- 뺄셈: $(a + bi) - (c + di) = (a - c) + (b - d)i$
- 곱셈: $(a + bi) * (c + di) = (ac - bd) + (ad + bc)i$
- 나눗셈: $(a + bi) / (c + di) = ((ac + bd) / (c^2 + d^2)) + ((bc - ad) / (c^2 + d^2))i$

복소수의 크기(절댓값)는 다음과 같이 계산된다:

- 복소수 $z = a + bi$의 크기는 $|z| = \sqrt{a^2 + b^2}$이다.

복소수는 물리학에서 사용되며 복소수 평면(complex plane)을 사용하여 복소수를 시각적으로 표현하고 다루는데 유용하게 활용된다.

# 16.1. 허수
허수(Imaginary Number)는 실수 체계를 확장하여, 실수 부분과 허수 부분으로 이루어진 복소수(Complex Number)를 만드는 데 사용되는 개념이다.     
허수는 "i"로 표기되며, $i^2 - -1$의 관계를 갖는다.  
이것은 실수 체계에서는 성립하지 않는 관계로, 수학적으로는 임의의 실수를 나타내는 것보다 더 많은 수를 다루는 데 도움을 준다.

허수는 다음과 같은 특징을 갖는다.

1. i의 정의: 'i'는 허수 단위로 정의된다.    
$i^2 = -1$이 성립한다.
2. 허수 축: 복소수 평면(Complex Plane)에서, 허수 부분은 수직으로 나타내는 것이 관례이다.    
따라서 허수 축은 실수 축과 직교한다.

# 16.2. 복소평면
복소평면(Complex Plane)은 복소수(Complex Number)를 시각적으로 나타내는 2차원 좌표 평면이다.     
이 평면은 실수 부분과 허수 부분을 나타내는 두 개의 축으로 구성되며, 복소수는 이 평면 상의 한 점으로 표현된다.   
복소수 평면은 실수 축(수평 축)과 허수 축(수직 축)으로 이루어져 있으며, 각 축은 실수와 허수 부분을 나타낸다.

복소 평면의 주요 특징은 다음과 같다:

1. 수평 축(실수 축): 이 축은 실수 부분(Real Part)을 나타내며, 보통 가로로 나타낸다.     
복소수의 실수 부분은 수평 축을 따라 위치하며, 수직 축을 따라 움직인다.
2. 수직 축(허수 축): 이 축은 허수 부분(Imaginary Part)을 나타내며, 보통 세로로 나타낸다.    
복소수의 허수 부분은 수직 축을 따라 위치하며, 수평 축을 따라 움직인다.
3. 원점(Origin): 원점은 실수와 허수 부분이 모두 0인 복소수인 '0'을 나타낸다.    
원점은 평면의 중심에 위치한다.
4. 복소수 표현: 복소수 $a + bi$는 복소 평면 상에서 '(a, b)'라는 점으로 표현된다.
5. 복소 평면 분할: 복소 평면은 1사분면, 2사분면, 3사분면, 4사분면으로 나눌 수 있으며, 이는 복소수의 부호와 관련이 있다.     
1사분면은 양수 부호의 실수와 허수를 가지며, 2사분면은 음수 부호의 실수와 양수 부호의 허수를 가진다.

복소 평면은 복소수를 시각적으로 이해하고 다루는 데 매우 유용한 도구이다.    
이를 통해 복소수의 연산, 극좌표 표현, 복소수 함수의 그래프 작성 등을 수행할 수 있다.    

# 16.2.1. 단위 복소수와의 곱
단위 복소수(Unit Complex Number)는 크기가 1인 복소수를 의미한다.    
복소수 'z'가 단위 복소수인 경우, $|z| = 1$이 성립한다.  
즉, 단위 복소수의 크기는 1이며, 복소 평면 상에서 원점에서 거리가 1인 점을 나타낸다.

단위 복소수 중에서 가장 많이 사용되는 두 가지는 다음과 같다:

1. 허수 단위(i): 가장 기본적인 단위 복소수 중 하나로, 'i'는 복소수 평면에서 원점에서 출발하여 허수 축에 위치한 복소수이다.  
'i'의 크기는 1이며, 허수 단위의 제곱은 '-1'이 된다.     
즉, $i^2 = -1$이다.
2. 1을 기준으로 회전하는 복소수: 어떤 각도 $\theta$에 대한 단위 복소수는 $\cos(\theta) + i * \sin(\theta)$과 같이 표현할 수 있다.  
이 복소수는 원점에서 시작하여 실수 축과 $\theta$ 각도를 이루는 점이다.  
이러한 복소수는 오일러 공식(Euler's Formula)에 기반하여 다양한 수학적 및 공학적 응용에서 사용된다.

단위 복소수와 다른 복소수와의 곱셈은 간단하다.  
어떤 복소수 'z'와 단위 복소수 'u' 간의 곱셈은 다음과 같이 표현할 수 있다:   
$z * u = |z| * (\cos(\theta) + i*\sin(\theta))$

여기서:

- 'z'는 곱셈의 대상이 되는 임의의 복소수이다.
- 'u'는 단위 복소수이다.
- '|z|'는 'z'의 크기(절댓값)이다.
- '$\theta$'는 'z'의 복소수 평면에서의 각도이다.

이 곱셈은 'z'를 원점에서 출발하여 각도 '$\theta$'만큼 회전시키고 크기를 '|z|'배 확대하는 것과 같은 효과를 갖는다.   
이것은 복소수를 이용한 회전, 변환, 진폭 조절 등 다양한 작업에 활용된다.

# 16.2.2. 켤레 복소수의 회전 변환
켤레 복소수(Conjugate Complex Number)는 주어진 복소수의 허수 부분의 부호를 반대로 바꾼 복소수를 나타낸다.   
주어진 복소수 $z = a + bi$의 켤레 복소수는 'z'의 허수 부분 'bi'의 부호를 바꾸어 $a - bi$와 같이 표현된다.

복소수 'z'와 그 켤레 복소수를 이용하여 회전 변환을 수행할 수 있다.  
회전 변환을 이해하기 위해서는 복소수의 곱셈과 켤레 복소수의 개념을 활용한다.

1. 복소수의 곱셈: 두 복소수 'z1'과 'z2'의 곱셈은 다음과 같이 정의된다.  
$z1 * z2 = (a1 + b1i) * (a2 + b2i) = (a1a2 - b1b2) + (a1b2 + a2b1)i$    
이 곱셈 공식을 이용하여 두 복소수의 곱을 계산할 수 있다.
2. 켤레 복소수와 회전: 복소수 'z'와 그 켤레 복소수 'z*' 사이의 곱은 다음과 같다.    
$z * \bar{z} = (a + bi) * (a - bi) = a^2 + b^2$     
여기서 $a^2 + b^2$는 'z'의 크기(절댓값)를 나타낸다.

이제 복소수 'z'와 그 켤레 복소수 'z*'의 곱셈 결과를 이용하여 회전 변환을 설명한다.

복소수 'z'를 $a + bi$라고 하고, 그 켤레 복소수를 'z*'라고 하면, 'z'와 'z*'의 곱은 $a^2 + b^2$이다.  
이 값은 'z'의 크기를 나타낸다.  
따라서 'z'를 'z*'로 나누면 크기가 1인 복소수가 된다.    
$z' = z / |z| = (a + bi) / \sqrt{a^2 + b^2}$

이렇게 구한 $z'$는 'z'를 원점에서 출발하여 복소 평면 상에서 크기가 1인 원 위를 회전하는 효과를 갖는다.  
이 회전의 각도는 'z'의 허수 부분('b')과 실수 부분('a') 사이의 관계에 의해 결정된다.

켤레 복소수와 회전 변환 컴퓨터 그래픽스와 신호 처리 등에서 자주 사용되며, 복소수의 특성을 활용하여 회전, 변환, 진폭 조절 등을 수행하는 데 유용하다.

# 16.3. 복소수와 행렬의 관계
복소수와 행렬 간의 관계는 몇 가지 다른 관점에서 설명할 수 있다:

1. 복소수와 2x2 행렬: 2x2 행렬은 다음과 같이 복소수로 표현할 수 있다.   
$A = \begin{bmatrix} a & -b \\ b & a \end{bmatrix}$     
이때, 'a'는 대각 원소(Diagonal Element) 중 하나로 복소평면 상의 실수 축을 나타내며, 'b'는 대각 원소 중 하나로 복소평면 상의 허수 축을 나타낸다.     
이 행렬은 스칼라 'a'와 'b'를 이용하여 특정 회전, 스케일링, 변환 등을 나타내는 데 사용된다.
2. 복소수와 선형 변환: 행렬을 선형 변환을 나타내는 데 사용된다.     
복소수는 회전과 스케일링을 나타내는 데 사용된다.    
따라서 복소수와 행렬은 선형 변환에 관련된 작업에서 함께 사용된다.
3. 복소수와 행렬 연산: 행렬과 복소수 간의 연산도 가능하다.  
예를 들어, 2x2 행렬과 복소수 간의 행렬 곱셈은 회전, 스케일링, 변환 등을 조합하여 복잡한 변환을 나타내는 데 사용된다.
4. 행렬과 복소수의 응용: 복소수와 행렬은 다양한 응용 분야에서 사용된다.     
예를 들어, 컴퓨터 그래픽스에서는 2D 및 3D 변환, 회전, 확대/축소, 투영 변환을 나타내는 데 사용된다.  

복소수와 행렬은 수학적인 도구로서, 다양한 계산과 시뮬레이션에 사용되며, 복잡한 시스템을 해석하고 모델링하는 데 도움을 준다.     

# 17. 오일러 공식
오일러 공식(Euler's Formula)은 복소수와 지수 함수(exponential function) 간의 중요한 수학적 관계를 나타내는 공식이다.    
이 공식은 수학자 레오나르도 오일러(Leonhard Euler)에 의해 개발되었으며 다음과 같이 표현된다:    
$e^{i\theta} = \cos(\theta) + i \sin(\theta)$

여기서:
- $e$는 자연로그의 밑인 오일러 수(Euler's number)이다.
- $i$는 허수 단위로, $i^2 = -1$이다.
- $\theta$는 임의의 실수 각도이다.
- $\cos(\theta)$는 삼각함수 코사인 함수의 값이며, $\sin(\theta)$는 삼각함수 사인 함수의 값이다.

오일러 공식은 복소평면(Complex Plane)에서 각도 $\theta$에 해당하는 위치에 있는 복소수를 나타낸다.   
이 공식은 복소수의 크기가 1인 단위 원 위를 따라 회전하면서 복소평면 상에서 주기적인 진동을 하는 복소수를 정의한다.

오이럴 공식은 복소수를 사용하여 각종 주기적인 현상을 모델링하거나 해석하는 데 유용하다.     
또한, 복소수의 지수 함수를 통해 복잡한 계산을 간단하게 처리할 수 있게 해주므로 많은 수학적 문제와 물리학적 현상을 연구하는 데 필수적인 도구 중 하나이다.

# 17.1. 자연지수함수
자연지수함수(Exponential Function)는 매우 중요한 수학적 함수 중 하나로, 다음과 같은 형태를 가진다:

$f(x) = a^x$

여기서:

- $f(x)$는 함수의 출력(함수 값)을 나타낸다.
- $a$는 밑(base)으로, 양의 실수이며 1이 아닌 어떤 값을 가질 수 있다.
- $x$는 지수(exponent)로, 실수 값을 가진다.

자연지수함수에서 가장 잘 알려진 경우는 $a$가 자연로그의 밑인 오일러 수($e$)일 때이다.   
이때의 자연지수함수는 다음과 같이 나타낸다:

$f(x) = e^x$

이 함수는 매우 특별한 성질을 갖고 있으며, 많은 수학적, 과학적 응용 분야에서 사용된다.   
몇 가지 주요한 특성은 다음과 같다:

1. 지수 법칙: 자연지수함수는 지수 법칙을 따른다.    
즉, $e^{x+y} = e^x \cdot e^y$와 같이 지수 합법칙과 곱법칙을 갖는다.
2. 극한값: $x$가 어떤 실수로 어떤 방향으로 가더라도 자연지수함수 $e^x$의 극한값은 항상 양수 무한대로 발산한다.
3. 미분 가능성: 자연지수함수 $e^x$는 미분 가능한 함수로, 미분한 결과는 자신과 동일한 형태를 가진다.

자연지수함수는 지수적으로 증가하거나 감소하는 현상을 모델링하는 데 사용된다.

# 17.1.1. 무리수 e
무리수 $e$는 자연로그의 밑인 오일러 수(Euler's number)로, 매우 특별하고 중요한 수학 상수이다.   
오일러 수는 $e \approx 2.71828$의 근사값을 가지며, 무한 소수로 표현되는 수이다.     
이것은 다음과 같이 정의된다:

$e = \lim_{n \to \infty}(1 + \frac{1}{n})^n$

$e$는 다양한 수학적 및 과학적 응용 분야에서 주요한 역할을 한다.     
이에 대한 몇 가지 주요한 특징과 응용 사례는 다음과 같다:

1. 복잡한 함수와 미분: $e$는 함수의 미분과 관련하여 매우 중요한 역할을 한다.    
$e^x$ 형태의 함수는 미분한 결과가 자신과 동일하게 되어 매우 편리하다.   
따라서 물리학, 공학, 경제학 등에서 변화율과 성장률을 모델링하는 데 사용된다.
2. 확률과 통계: 확률론과 통계학에서도 $e$는 중요한 역할을 한다.     
특히 지수 분포와 포아송 분포와 관련된 확률 분포를 설명할 때 사용된다.
3. 복잡한 수학 및 과학 연구: 복소 해석, 복소수 고급 함수, 푸리에 변환 등 많은 수학 및 과학 분야에서 $e$는 핵심적인 역할을 한다.
4. 컴퓨터 과학: 알고리즘 분석, 데이터 구조, 암호학, 신호 처리 등 다양한 컴퓨터 과학 분야에서도 $e$와 지수 함수가 중요한 역할을 한다.

$e$는 수학과 과학의 여러 분야에서 광범위하게 사용되는 상수로, 그 중요성은 이론적인 계산부터 실제 응용까지 다양한 영역에 걸쳐 있다.  

# 17.2. 미분
미분(Differentiation)은 수학에서 함수의 변화율(rate of change)을 계산하고, 그 변화율을 나타내는 또 다른 함수를 구하는 과정을 의미한다.  
미분은 함수에서 한 점에서의 순간적인 변환량을 측정하고, 이러한 변화량이 어떤 패턴을 따르는지 이해하는 데 사용된다.  
미분의 주요 개념과 관련된 중요한 개념은 다음과 같다:

1. 도함수(Derivative): 미분을 통해 얻은 변화율 함수를 도함수라고 한다.  
도함수는 원래 함수의 변화율을 나타내며, 주어진 입력 값에서의 순간 변화율을 의미한다.    
도함수는 주로 $f'(x)$로 표기하며 다음과 같이 정의된다.  
$f'(x) = \lim_{h \to 0}\frac{f(x+h)-f(x)}{h}$   
여기서 $h$는 아주 작은 값이며, $h$가 0에 가까워질수록 순간 변화량을 나타낸다.
2. 미분 가능성(Differentiability): 함수가 어떤 점에서 미분 가능하다는 것은 그 점에서 도함수가 존재한다는 것을 의미한다.     
함수가 어떤 구간에서 미분 가능하면 그 구간에서 연속적인 변화율을 갖는 것을 의미한다.
3. 미분 공식(Derivative Rules): 다양한 함수의 미분 공식이 있으며, 이를 사용하여 다양한 함수의 도함수를 계산할 수 있다.  
예를 들어, 상수 함수, 다항 함수, 지수 함수, 로그 함수 등의 미분 공식이 있다.
4. 적분(Intergration): 미분의 반대 과정으로, 함수의 도함수를 원래 함수로 되돌리는 과정을 적분이라고 한다.   
미분과 함께 적분은 미적분학(Calculus)의 중요한 주제 중 하나이며, 미분과 적분은 서로 역관계를 갖는다.
5. 미분의 응용: 물리학에서는 물체의 운동, 컴퓨터 과학에서는 알고리즘 분석 등에서 미분이 사용된다.

미분은 수학에서 핵심적인 개념 중 하나이며, 함수의 특징과 행동을 이해하고 모델링하는 데 매우 중요하다.   
또한, 미분은 다양한 과학 및 엔지니어링 분야에서 현상을 설명하고 예측하는 데 필수적인 도구 중 하나이다.

# 17.2.1. 도함수
도함수(Derivative)는 함수의 변화율을 나타내는 함수로, 특정 지점에서 함수의 순간 변화율(instantaneous rate of change)을 정의한다.    
도함수는 주어진 함수를 미분한 결과로, 다음과 같이 표기된다.

만약 함수 $f(x)$가 미분 가능하다면, $f'(x)$ 또는 $\frac{df}{dx}$로 표기한다.    
이 표기법은 함수 $f$를 $x$에 대해 미분한 함수를 나타낸다.

도함수의 정의는 다음과 같다:

$f'(x) = \lim_{h \to 0}\frac{f(x+h)-f(x)}{h}$

여기서 $h$는 아주 작은 값이다.  
이 정의는 함수 $f(x)$를 $x$ 지점에서 아주 작은 변화량 $h$만큼 변화시켰을 때, $x$에서의 순간 변화율을 계산한다.  
이때, $h$를 0으로 극한(limit)을 취하면, 해당 점에서의 순간 변화율을 구할 수 있다.

도함수는 주어진 함수의 기울기(경사)를 나타내며, 이는 해당 함수의 접선(tangent line)의 기울기와 일치한다.    
도함수는 어떤 지점에서 함수가 가파르게 상승하거나 하강하는 정도를 측정하는 도구로 사용된다.

도함수의 중요한 특성과 활용은 다음과 같다:

1. 변화율 분석: 도함수를 통해 함수의 특정 지점에서의 기울기를 분석하여 해당 지점에서 함수가 증가하거나 감소하는 정도를 이해할 수 있다.
2. 극점 및 최솟값/최댓값 찾기: 도함수를 사용하여 함수의 극점(최솟값 또는 최댓값)을 찾거나 함수의 최적화 문제를 해결하는 데 도움이 된다.
3. 속도와 가속도 계산: 물리학에서는 도함수를 사용하여 물체의 속도와 가속도를 계산하는 데 활용된다.
4. 함수 근사: 도함수를 사용하여 함수를 선형 근사하거나 다항식으로 근사하는 데 사용된다.
5. 미적분학의 기반: 미적분학에서는 도함수와 적분을 연계하여 다양한 수학적 문제를 해결한다.

도함수는 수학과 과학 분야에서 매우 중요한 개념으로, 함수의 특성 및 동작을 분석하고 모델링하는 데 필수적인 도구 중 하나이다.

# 17.2.2. 자연지수함수의 도함수
자연지수함수 $f(x) = e^x$의 도함수를 계산하려면 다음과 같이 미분 규칙을 적용한다.   
자연로그의 밑인 $e$는 상수이므로 간단하게 미분할 수 있다.

자연지수함수 $f(x) = e^x$의 도함수는 다음과 같다:

$f'(x) = \frac{d}{dx}(e^x) = e^x$

즉, 자연지수함수 $e^x$를 미분하면 자기 자신인 $e^x$가 된다.     
이것은 자연지수함수의 특별한 성질 중 하나이다.  
이 도함수는 어떤 점 $(x, e^x)$에서의 순간 변화율을 나타내며, 해당 점에서의 기울기를 나타낸다.   
또한, 자연로그 함수 $\ln(x)$의 역함수로서의 역할도 한다.

# 17.2.3. sin 함수와 cos 함수의 도함수
1. Sine 함수 ($\sin(x)$)의 도함수 ($\sin'(x)$):
    - Sine 함수의 도함수는 cosine 함수이다.     
    즉, $\sin'(x) = \cos(x)$이다.
    - 이것은 sine 함수의 기울기가 $x$에서 cosine 함수와 일치한다는 것을 의미한다.
    - Sine 함수의 그래프가 최고점 또는 최저점에 도달하면, 도함수인 cosine 함수는 0이다.
    - 예를 들어, $\sin(0) = 0$일 때, $\cos(0) = 1$이다.
2. Cosine 함수 ($\cos(x)$)의 도함수 ($\cos'(x)$):
    - Cosine 함수의 도함수는 negative sine 함수이다.    
    즉, $\cos'(x) = -\sin(x)$이다.
    - 이것은 cosine 함수의 기울기가 x에서 sine 함수와 반대 방향으로 움직인다는 것을 의미한다.
    - Cosine 함수의 그래프가 최고점 또는 최저점에 도달하면, 도함수인 negative sine 함수는 0이다.
    - 예를 들어, $\cos(\pi/2) = 0$일 때, $\cos'(\pi/2) = -1$이다.

Sine 함수와 Cosine 함수의 도함수는 주기적이며, 원형으로 돌아가는 현상을 모델링하는 데 사용된다.

# 17.3. 급수
급수(Series)는 무한히 많은 항으로 이루어진 수열의 합을 나타내는 수학적인 개념이다.  
급수는 다음과 같이 표현된다:

$S = a_1 + a_2 + a_3 + ...$

여기서:

- $S$는 급수의 합을 나타낸다.
- $a_1, a_2, a_3, ...$는 급수의 각 항을 나타낸다.

급수는 유한한 항의 합과는 다르게 무한한 항의 합을 표현한다.     
급수의 합을 찾는 것은 수학적 분석, 미적분학, 수렴과 발산, 근사론 등 다양한 수학적 주제와 응용 분야에서 중요한 역할을 한다.

급수의 중요한 특징과 개념은 다음과 같다:

1. 수렴과 발산: 급수가 수렴(converge)하는 경우, 무한히 많은 항을 더했을 때 합이 유한한 값을 가진다.     
수렴하지 않는다면, 급수는 발산(diverge)한다.
2. 수렴 조건: 급수가 수렴하기 위해서는 급수의 각 항이 0에 가까워야 한다.    
이것은 "수렴하는 급수의 필요 조건"이다.     
하지만 이 조건만으로는 충분하지 않을 수 있다.   
수렴하는 급수의 수렴 속도를 결정하는 다양한 수렴 테스트가 있다.
3. 등비급수와 등차급수: 등비급수는 각 항이 이전 항에 상수 비율을 곱해 얻어지는 급수이며, 등차급수는 각 항이 이전 항에 상수를 더해 얻어지는 급수이다.    
예를 들어, 등비급수의 일반항은 $a_n = a_1 \cdot r^{n-1}$이고, 등차급수의 일반항은 $a_n = a_1 + (n - 1)d$이다.
4. 테일러 급수: 특정 함수를 다항식으로 근사하는 데 사용되는 급수로, 테일러 급수는 함수를 무한항 다항식으로 나타낸다.    
이것은 미적분학과 해석학에서 중요한 도구이다.
5. 급수의 연산: 급수는 덧셈과 뺄셈에 대해 닫혀 있으며, 두 급수를 더하거나 뺄셈하여 새로운 급수를 생성할 수 있다.

급수는 함수나 현상을 모델링하고 분석하는 데에 사용된다.

# 17.3.1. 등비수열
등비수열(Geometric Sequence)은 각 항이 이전 항에 일정한 비율을 곱해서 얻어지는 수열이다.    
등비수열의 일반적인 형태는 다음과 같다:

$a, ar, ar^2, ar^3, ...$

여기서:

- $a$는 첫 번째 항을 나타낸다.  
이를 초항 또는 첫 항이라고 한다.
- $r$은 공비(common ratio)라고 불리며, 각 항이 이전 항에 곱해지는 비율이다.
- $ar$는 두 번째 항, $ar^2$는 세 번째 항, 이와 같이 진행된다.

등비수열은 다음과 같이 일반항으로 나타낼 수 있다:

$a_n = a \cdot r(n-1)$

여기서 $a_n$은 수열의 n번째 항을 나타낸다.

등비수열의 주요 특징은 다음과 같다:

1. 공비 $r$의 값: 공비 $r$이 0이 아니면서 $|r| < 1$인 경우, 등비수열은 수렴(converge)한다.  
그렇지 않으면, $|r| \geq 1$일 때 등비수열은 발산(diverge)한다.
2. 등비수열의 합: 등비수열의 합을 구하는 공식은 다음과 같다.    
$S = \frac{a}{1-r}$     
여기서 $S$는 등비수열의 합을 나타내며, $a$는 초항, $r$은 공비를 나타낸다.
3. 무한 등비수열: 공비 $|r| < 1$인 경우, 무한 등비수열의 다음과 같이 구할 수 있다.  
$S_\infty = \frac{a}{1-r}$  
여기서 $S_\infty$는 무한 등비수열의 합을 나타낸다.  
이 식은 등비수열의 합이 수렴하고, 합이 $a/(1 - r)$에 수렴한다는 것을 보여준다.

등비수열은 자연게에서 다양한 현상을 모델링하는 데 사용된다.

# 17.3.2. 매클로린 급수
매클로린 급수(Maclaurin Series)는 함수를 무한 개의 항으로 근사하는 데 사용되는 급수 표현이다.   
매클로린 급수는 특정 함수를 다항식의 형태로 나타내어 다루기 쉽게 만들어준다.    
매클로린 급수는 다음과 같은 형태로 나타낼 수 있다:

$f(X) = f(0) + f'(0)x + \frac{f''(0)}{2!}x^2 + \frac{f'''(0)}{3!}x^3 + ...$

여기서:

- $f(x)$는 근사하려는 함수이다.
- $f(0)$는 $x = 0$에서의 함수의 값이다.
- $f'(0)$는 $x = 0$에서의 함수의 1차 도함수 값이다.
- $f''(0)$는 $x = 0$에서의 함수의 2차 도함수 값이다.
- $f'''(0)$는 $x = 0$에서의 함수의 3차 도함수 값이다.
- 이어지는 항들은 $x$의 거듭제곱으로 증가하며, 각 항은 $f$의 $n$차 도함수를 $n!$로 나눈 값과 $x^n$의 곱으로 이루어져 있다.

매클로린 급수는 $x$가 충분히 작을 때(주로 0 근처에서), 주어진 함수를 다항식으로 근사하는 데 사용된다.   
이렇게 근사한 다항식을 사용하면 함수의 계산이 단순해지고, 복잡한 함수를 다루기 쉬워진다.

예를 들어, 지수 함수 $e^x$의 매클로린 급수는 다음과 같이 주어진다:

$e^x = 1 + x + \frac{x^2}{2!} + \frac{x^3}{3!} + ...$

이 급수를 이용하면 지수 함수의 값을 $x$의 다항식으로 근사할 수 있다.    
다른 함수들에 대해서도 유사한 매클로린 급수를 구할 수 있다.