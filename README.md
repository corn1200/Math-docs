# Math-docs

# 목차
* [1. 벡터와 스칼라](#1-벡터와-스칼라)
    * [1.1. 벡터의 연산](#11-벡터의-연산)
    * [1.2. 벡터의 내적과 외적](#12-벡터의-내적과-외적)
* [2. 좌표계](#2-좌표계)
    * [2.1. 데카르트 좌표계](#21-데카르트-좌표계)
    * [2.2. 극좌표계](#22-극좌표계)
* [3. 피타고라스 정리](#3-피타고라스-정리)
* [4. 삼각비](#4-삼각비)
* [5. 삼각함수](#5-삼각함수)
    * [5.1. 삼각함수를 활용한 물체의 회전](#51-삼각함수를-활용한-물체의-회전)
    * [5.2. 삼각함수의 역함수](#52-삼각함수의-역함수)
    * [5.3. 삼각함수의 덧셈 정리](#53-삼각함수의-덧셈-정리)
* [6. 수와 집합](#6-수와-집합)
    * [6.1. 연산과 수의 구조](#61-연산과-수의-구조)
    * [6.2. 수의 표현](#62-수의-표현)
* [7. 함수](#7-함수)
    * [7.1. 함수의 개념과 종류](#71-함수의-개념과-종류)
    * [7.2. 합성 함수](#72-합성-함수)
    * [7.3. 항등함수와 역함수](#73-항등함수와-역함수)
    * [7.4. 곱집합을 활용한 좌표 평면으로의 확장](#74-곱집합을-활용한-좌표-평면으로의-확장)
* [8. 행렬](#8-행렬)
    * [8.1. 선형성](#81-선형성)
        * [8.1.1. 선형 함수](#811-선형-함수)
    * [8.2. 행렬의 기본 연산](#82-행렬의-기본-연산)
    * [8.3. 행렬의 설계](#83-행렬의-설계)
        * [8.3.1. 크기 변환행렬](#831-크기-변환행렬)
        * [8.3.2. 회전 변환행렬](#832-회전-변환행렬)
        * [8.3.3. 전단 변환행렬](#833-전단-변환행렬)
    * [8.4. 역행렬](#84-역행렬)
        * [8.4.1. 역행렬의 존재를 판별하는 행렬식](#841-역행렬의-존재를-판별하는-행렬식)
        * [8.4.2. 크기 변환행렬의 역행렬](#842-크기-변환행렬의-역행렬)
        * [8.4.3. 회전 변환행렬의 역행렬](#843-회전-변환행렬의-역행렬)
        * [8.4.4. 전단 변환행렬의 역행렬](#844-전단-변환행렬의-역행렬)
        * [8.4.5. 행렬 곱의 역행렬](#845-행렬-곱의-역행렬)
* [9. 아핀 공간](#9-아핀-공간)
    * [9.1. 이동 변환을 위한 아핀 공간](#91-이동-변환을-위한-아핀-공간)
    * [9.2. 아핀 공간의 구성 요소](#92-아핀-공간의-구성-요소)
    * [9.3. 아핀 결합](#93-아핀-결합)
    * [9.4. 선 그리기 알고리즘](#94-선-그리기-알고리즘)
        * [9.4.1. 벡터를 모니터의 점으로 표현](#941-벡터를-모니터의-점으로-표현)
        * [9.4.1. 라인 클리핑 알고리즘](#942-라인-클리핑-알고리즘)
* [10. 메시](#10-메시)
    * [10.1. 무게중심좌표](#101-무게중심좌표)
    * [10.2. 정점에 설정된 부가 정보의 활용](#102-정점에-설정된-부가-정보의-활용)

# 1. 벡터와 스칼라
## 벡터(vector)
- 기하학적으로 벡터를 방향을 가진 선분 즉, 화살표로 표현한다.
- 벡터의 속성은 '길이(혹은 크기)'와 '가리키는 방향'
- '위치'는 벡터의 속성이 아니다.    
따라서 다른 위치에 있더라도 동일한 길이와 방향을 가리키는 두 개의 벡터는 동일한 것으로 취급된다.    
예를 들어, 아래의 그림에서 벡터 u와 v는 동일하다.
- 크기와 방향을 모두 갖는 물리량을 모델링하는 데 유용하다.  
ex) 빛이 비추는 방향, 다각형의 방향, 3D 세계에서의 카메라가 보고 있는 방향 등

![벡터](/img/vector0.png)

보통 벡터를 표시할 때는 굵은 소문자를 이용하지만 굵은 대문자를 이용하는 경우도 있다.    
다음은 각각 2차원, 3차원, 4차원 벡터의 표시 예이다.     
혹은 화살표를 사용하여 표기하기도 한다: $\overrightarrow{a}$    
$u = (u_x, u_y), N = (N_x, N_y, N_z), c = (c_x, c_y, c_z, c_w)$

### 벡터의 크기 계산
기하학적으로 벡터의 크기는 방향을 가진 선분의 길이이다.     
벡터의 성분이 주어졌다고 할 때, 다음과 같은 식을 이용해 벡터의 크기를 대수학적으로 계산해낼 수 있다.    
$||u|| = \sqrt{u_x^2 + u_y^2 + u_z^2}$

ex) $u = (1,2,3)$과 $v = (1,1)$ 벡터의 크기를 구하라.   
$||u|| = \sqrt{1^2 + 2^2 + 3^2} = \sqrt{1 + 4 + 9} = \sqrt{14}$

![벡터](/img/vector1.png)

마찬가지로, 위의 식을 2차원으로 일반화하면 다음과 같이 $v$를 얻을 수 있다.  
$||v|| = \sqrt{1^2 + 1^2} = \sqrt{2}$

![벡터](/img/vector2.png)   
연관 내용: 피타고라스의 정리

### 영 벡터와 단위 벡터
영 벡터란 모든 성분에 0을 가진 것이다.  
영 벡터는 굵은 0으로 표시된다: $0 = (0, 0, 0)$

단위 벡터란 크기가 1인 벡터이다.    
곱셈에서, $1 * n = n$일 때 n에 어떤 수를 넣더라도 항상 n이 나오도록 하는 1을 곱셈에서의 항등수라고 한다.    
벡터에서도 값과 벡터가 곱해질 때 단위 벡터는 항등수에 해당한다. 
단위 벡터는 크기가 1이고 방향을 가지고 있으므로, 여기에 값을 곱해주면 방향은 같지만 크기가 다른 벡터를 마음대로 만들 수 있다.   
혹은 크기는 무시하고 방향만 나타내기 위해서 사용한다.

모든 벡터는 정규화(normalize) 과정을 거쳐 단위 벡터로 만들 수 있다.     
단위 벡터의 용도는 일반적으로 회전의 중심축으로써 사용되는 경우가 많다.     
그 외에도 삼각형면의 법선 벡터(normal vector) 역시 단위 벡터를 사용한다.    
법선 벡터란, 평면에 수직인 벡터이다.

![벡터](/img/vector3.png)

### 벡터의 정규화
벡터의 정규화란 벡터의 크기를 1로 만들어 단위 벡터가 되도록 하는 것이다.    
다음과 같이 벡터의 각 성분을 벡터의 크기로 나누면 정규화가 된다.    
단위 벡터는 위에 모자를 씌워 표기한다: $\hat{u}$    
$\hat{u} = \frac{u}{||u||} = (\frac{u_x}{||u||}, \frac{u_y}{||u||}, \frac{u_z}{||u||})$

ex) $u = (1,2,3)$ 벡터를 정규화하라.    
$\hat{u} = \frac{u}{\sqrt{14}} = (\frac{1}{\sqrt{14}}, \frac{2}{\sqrt{14}}, \frac{3}{\sqrt{14}})$

## 스칼라(scalar)
- 크기와 방향을 가지는 벡터의 대비되는 개념
- 단지 크기만 있는 물리량이다.
- 좌표계가 변환되어도 그에 따라 변화하지 않는 양, 단순히 '하나의 숫자'이다.

### 벡터와 스칼라의 연산
스칼라는 벡터와의 곱셈 연산을 통해 벡터의 크기를 조정하는 데 사용된다.  
스칼라 연산은 벡터의 방향에는 영향을 미치지 않으며 단지 벡터의 크기만을 바꿀 뿐이다.    
각 항에 스칼라를 곱해주면 된다.     
만약 음수를 이용하는 경우에는 벡터의 방향이 뒤집힌다.   
즉, 벡터에서 부호는 방향을 결정하는 역할을 한다.    
$ku = (ku_x, ku_y, ku_z)$

![벡터](/img/vector4.png)

게임에서 캐릭터를 이동시킬 때, 단위 벡터와 스칼라의 곱을 사용한다.  
캐릭터를 이동시킬 방향(단위 벡터)에 이동하고자 하는 거리(스칼라) 값을 곱하면, 캐릭터가 이동할 벡터를 구할 수 있다.

즉, 캐릭터의 위치 벡터에 이동 벡터를 더하여, 최종적으로 캐릭터가 이동될 위치를 구해 캐릭터를 그 위치로 이동시키면 된다.

![벡터](/img/vector5.png)

### 역벡터
역벡터란 크기는 같으나 방향이 서로 반대인 벡터를 말한다.    
역벡터는 벡터 앞에 -(음부호)를 붙여서 표시를 한다.  
-(음부호)의 역할은 벡터의 방향을 바꾸는 역할을 하며, 각 성분에 -1을 곱한 것과 같다.     
예를 들어 (1, 1) 벡터에 -1을 곱해주면 크기는 그대로지만 방향이 반대가 된다는 것을 아래 그림을 통해 알 수 있다.

![벡터](/img/vector6.png)

# 1.1. 벡터의 연산
### 벡터의 덧셈
대응되는 성분을 더하면 두 개의 벡터를 더할 수 있다.     
이때, 더하고자 하는 벡터는 반드시 동일한 차원을 가져야 한다.    
교환법칙과 결합법칙이 성립한다.     
$u + v = (u_x + v_x, u_y + v_y, u_z + v_z)$

교환법칙 성립: $u + v = v + u$      
결합법칙 성립: $(u + v) + w = u + (v + w)$

아래의 그림은 벡터의 덧셈의 기하학적 보간을 보여준다.

![벡터](/img/vector7.png)

### 벡터의 뺄셈
벡터의 덧셈과 비슷하게 벡터의 대응되는 성분을 빼는 방법으로 벡터의 뺄셈을 수행할 수 있다.   
벡터는 반드시 동일한 차원을 가져야 한다.    
$u - v = u + (-v) = (u_x - v_x, u_y - v_y, u_z - v_z)$

아래의 그림은 벡터 뺄셈의 기하학적 보간을 보여주고 있다.    
게임에서는 '내'가 '타겟'을 보는 방향을 구하고자 할 때 벡터의 뺄셈이 유용하게 사용된다.

![벡터](/img/vector8.png)

### 벡터의 분해
하나의 벡터는 두 개의 성분 벡터로 분해될 수 있다.

![벡터](/img/vector9.png)

위 그림에서 벡터 A는 벡터 B와 벡터 C의 합으로 분해되어진다.     
벡터 B와 벡터 C의 합이 결국 A 벡터이기 때문이다.

이렇게 벡터를 성분 분해하는 이유는 벡터 연산을 좀 더 효율적이고 쉽게 하기 위함이다.     
예를 들어 2차원 벡터끼리 연산을 할 때 각 벡터를 x, y 축의 두 성분 벡터로 분해하여 연산하면 다음과 같다.

![벡터](/img/vector10.png)

벡터의 연산이 복잡해질 수록 벡터 분해에 대한 이해는 필수적이다.         
벡터 내적의 이해와도 관련되어 있다.

# 1.2. 벡터의 내적과 외적
## 내적
- 내적은 벡터 대수학에서 정의하는 두 가지 곱셈 중 하나이다.
- 두 벡터 사이의 연산이지만, 내적의 결과는 벡터가 아닌 스칼라 값이다.
- 벡터의 내적을 구하는 공식은 다음과 같다.

1. $u * v = u_xv_x + u_yv_y + u_zv_z$
2. $u * v = ||u||||v|| \cos \theta$

1번은 두 벡터의 각은 모르고 벡터의 성분만을 알고 있을 경우 사용할 수 있는 공식이며, 2번은 두 벡터의 각과 크기를 알고 있을 경우 사용할 수 있는 공식이다.

1번의 식은 분명한 기하학적 의미를 보여주고 있지 않다.   
코사인 법칙을 이용하면 $u * v = ||u||||v||$의 관계를 발견할 수 있으며, 이는 두 벡터 간의 내적이 벡터 크기 배율을 가진 벡터 간 각도의 코사인임을 알 수 있다.

1번 공식을 2차원 벡터를 예로 들어 그림으로 표현하면 다음과 같다.

![벡터](/img/vector11.png)

2번 공식을 2차원 벡터를 예로 들어 그림으로 표현하면 다음과 같다.

![벡터](/img/vector12.png)

벡터 D의 크기는 A 벡터의 크기에 $\cos \theta$를 곱한 것이다.    
$||D|| = ||A|| * \cos \theta$   
여기서 A의 크기가 아닌, A를 분해한 벡터 D의 크기를 곱해주는 이유는 B 벡터에 실제로 영향을 주는 벡터가 D이기 때문이다.   
한편 벡터 C는 벡터 B의 방향으로 어떤 영향도 주지 못하기 때문에, 내적 계산에서 무시한다.

### 내적의 특성
$u$와 $v$가 모두 단위 벡터인 경우 $u * v$는 두 벡터 간 각도의 코사인이 된다.

![벡터](/img/vector13.png)

만약 $u * v = 0$ 이라면, 두 벡터는 직각이다.     
만약 $u * v > 0$ 이라면, 두 벡터 간의 각도 $\theta$는 90도($\frac{\pi}{2}$) 보다 작다.      
만약 $u * v < 0$ 이라면, 두 벡터 간의 각도 $\theta$는 90도($\frac{\pi}{2}$) 보다 크다.

![벡터](/img/vector14.png)

또한, 자기자신과 내적하면 자기자신 크기만큼의 제곱이다.     
자기자신과 이루는 각도는 0도 이며, $\cos 0 = 1$이기 때문에 결과적으로 같은 벡터 2개를 내적하면 제곱이다.

### 벡터의 내적 활용
첫째, 두 벡터 사이각을 내적을 통해 구할 수 있다.    
두 벡터의 성분을 알고 있다면, 크기를 알 수 있고 내적 계산을 이용해 $\arccos \theta$를 통해 구할 수 있다.
$$\cos \theta = \frac{a * b}{||a||||b||} = \frac{a_xb_x + a_yb_y + a_zb_z}{||a||||b||}$$
$$\theta = \arccos(\frac{a * b}{||a||||b||})$$

![벡터](/img/vector15.png)

둘째, 어떤 벡터 a에서 수직으로 내린 길이(투영 길이)를 구할 때 내적을 사용한다.

![벡터](/img/vector16.png)

위의 그림에서 벡터 a의 투영 길이를 구하고자 할 때는 벡터 b의 단위 벡터를 이용한다.  
벡터 b의 단위 벡터의 길이는 1이며 내적 공식에 적용하면 $a * b = ||a|| * 1 * \cos \theta$가 되어 결국 투영 길이는 $||a|| \cos \theta$가 된다.   
또는 $a_xb_x + a_yb_y + a_zb_z$에서 벡터 b의 단위 벡터를 적용하면 된다.     
투영 길이는 곧 벡터 b의 방향으로 얼마만큼 뻗어있는지 그 정도(크기)를 의미한다.

셋째, '나'의 방향 벡터가 있을 때 적이 주인공의 앞에 있는지 뒤에 있는지 판단할 때 사용된다.      
적의 위치에서 '나'의 위치를 뺀 벡터 즉, 내가 적을 바라보는 방향 벡터와 나의 Forward 벡터 간 내적을 했을 때, 각이 -90도 ~ 90도 사이에 있으면($\cos \theta$가 양수이면) 적이 나의 앞에 있는 것이고, 각이 90도 ~ 270도 사이에 있으면($\cos \theta$가 음수이면) 적이 나의 뒤에 있는 것이다.

![벡터](/img/vector17.png)

넷째, 적이 '나'의 시야각 안에 들어와 있는지 아닌지 판단할 때 사용된다.    
'나'의 시야각을 $\theta$라고 하면, Forward 벡터와 적과 '적의 위치에서 나의 위치를 뺀' 벡터 A 간의 내적을 통해 나오는 각도 값이 $\frac{\theta}{2}$를 넘지 않아야 시야각 내에 존재한다는 것을 판별할 수 있다.

![벡터](/img/vector18.png)

다섯째, 점 A와 평면 S 간의 최단 거리를 구할 때 내적을 이용해 구할 수 있다.  
(B는 평면 위의 점, d는 점 A와 평면 S 간의 최단 거리)    
$(A - B) * n = d$

![벡터](/img/vector19.png)

단면으로 표현하면 아래와 같다.

![벡터](/img/vector20.png)

벡터 BA와 평면의 법선 벡터(normal vector)와 내적을 구하면, $||BA|| * \cos \theta$값이 된다.     
이때, 평면의 법선 벡터는 정규화된 단위 벡터라고 가정한다.   
'투영 길이'를 떠올려보면 점 A와 평면 S 간의 최단거리 d가 됨을 알 수 있다.   
만약, 거리값이 0이면 A는 평면 위의 점이 된다.

## 외적
- 벡터 수학이 정의하는 두번째 형식의 곱은 외적이다.
- 스칼라로 계산되는 내적과는 달리, 외적의 결과는 또 다른 벡터이다.
- a와 b 두 벡터의 외적을 수행하면 다른 벡터 p를 얻으며, 이는 a와 b에 서로 지각을 이룬다.    
즉, p는 a에 직각이며, p는 b에 직각이다.
- 벡터의 외적을 구하는 공식은 다음과 같다.

1. $p = a * b = \hat{n}||a||||b|| \sin \theta$
2. $p = a * b = [(a_yb_z - a_zb_y), (a_zb_x - a_xb_z), (a_xb_y - a_yb_x)]$

1번의 식을 자세히 살펴보면, n은 방향 벡터이고, 나머지는 값이기에 결과는 벡터라는 것을 알 수 있다.   
또한, 외적 벡터의 크기는 두 벡터의 크기에 $\sin \theta$를 곱한 값과 같음을 알 수 있다.

![벡터](/img/vector21.png)

2번의 식은 다음과 같이 행렬식(Determinant)를 이용하여 간단히 쓸 수 있다.    
($i = (1,0,0), j = (0,1,0), k = (0,0,1)$)

![벡터](/img/vector22.svg)

$a * b$ 외적 벡터의 방향은 수학에서는 오른손 좌표계를 사용하며, 게임은 엔진이 사용하는 좌표계에 따라 다르다. (OpenGL에서는 오른손 좌표계, Unity나 Direct3D에서는 왼손 좌표계)   
예를 들어, Direct3D는 왼손 좌표계를 사용하므로 왼손법칙에 따라 외적 벡터의 방향을 계산하지 않고도 알 수 있다.   
왼손으로 첫번째 벡터 방향으로 손바닥을 맞춘 후, 두번째 벡터 방향으로 구부렸을 때 엄지 손가락이 가리키는 방향이 바로 외적으로 리턴되는 벡터의 방향이 된다.

![벡터](/img/vector23.png)

### 외적의 특성
- 외적의 결과는 내적과 달리 벡터이기 때문에 방향과 크기를 동시에 가지게 된다.   
방향: $u \times v \perp u$ 이고 $u \times v \perp v$ 이다. 즉, 두 벡터 $u$와 $v$ 에 동시에 수직이다.    
크기: 외적 벡터의 크기는 $u$ 와 $v$를 변으로 하는 평행사변형의 넓이이다.

![벡터](/img/vector24.png)

외적도 내적과 마찬가지로 주로 단위 벡터와 함께 사용되는데, 예를 들어 위의 그림에서 u와 v가 단위 벡터라면, u와 v의 외적 결과값인 벡터 p의 크기로 u와 v의 사이각을 판단할 수 있다.    
벡터 p의 크기가 1이라면 u와 v를 연결해서 만든 도형이 가로세로가 1인 정사각형임을 알 수 있고, 결국 벡터 u와 벡터 v가 수직임을 알 수 있다.

- 내적과 달리 교환 법칙이 성립하지 않으며, 순서를 바꾸면 반대 방향의 벡터가 나온다: $u \times v = -(u \times v)$
- 내적과 동일하게 분배 법칙은 성립한다: $u \times (v + w) = (u \times v) + (u \times w)$
- 두 벡터가 모두 영벡터가 아닐 때, $u \times v = 0$인 것은 $u$와 $v$가 서로 평행인 것과 동치이다.   
즉, 두 벡터가 평행하면 크기는 0이다. $(\sin \theta = 0)$

![벡터](/img/vector25.png)

### 벡터의 외적 활용
첫째, 평면의 법선 벡터를 구할 때 사용한다.  
삼각형의 세 점을 알고 있다고 할 때, 벡터 2개를 구할 수 있게 되고 그 두 벡터를 외적하면 해당 삼각형이 속한 평면의 법선 벡터를 구할 수 있다.

![벡터](/img/vector26.png)

입체적으로 표현하면 아래 그림과 같다.

![벡터](/img/vector27.png)

또한, 삼각형의 넓이를 구할 때도 외적을 사용할 수 있다.

![벡터](/img/vector28.png)

둘째, 평면이 앞면인지 뒷면인지를 알아낼 수 있고, 따라서 컬링(culling)할 때 사용된다.    
법선 벡터가 한 평면의 뒤를 가리킨다면, 뒷면을 화면 출력에서 제외되는 면이 된다.     
이와 같이 보이지 않는 뒷면을 화면 출력에서 제외시키는 것을 백페이스 컬링(backface culling)이라고 하며, Direct3D에서는 컬링 옵션에 따라 출력에서 제외시키거나 출력하게 할 수 있다.   
컬링의 기준이 되는 것이 바로 이 법선 벡터의 방향이다.   
eye 벡터와 평면의 법선 벡터의 내적으로부터 얻는 $\cos \theta$ 값을 사용하면 앞과 뒤를 판단할 수 있다.

![벡터](/img/vector29.png)

셋째, 점과 직선사이의 거리를 구할 때 사용된다.

![벡터](/img/vector30.png)

직선 S의 위의 점 B와 C를 임의로 선택한다.   
$BA$ 와 $BC$ 벡터를 만들어, 평행사변형의 높이를 구하는 방법을 응용해 문제를 풀 수 있다.

넷째, 빛의 방향과 평면의 법선 사이의 각도를 이용해 평면에 적용될 빛의 영향을 결정하게 된다.     
만약 빛을 평면에 비추고 싶다면, 평면을 이루는 각 벡터 정보에는 법선 벡터에 대한 정보가 반드시 있어야한다.

# 2. 좌표계
좌표계는 크게 2D 좌표계와 3D 좌표계로 나눌 수 있다.     
2D 좌표계는 모니터 좌표계와 동일하며 x, y 좌표를 가진다.    
3D 좌표계는 공간상의 한 점을 나타내기 위해 x, y, z 좌표로 위치를 나타낸다.  
3D 프로그래밍은 3D 좌표계를 사용하며 Direct3D는 3D 공간상의 정점들을 2D 좌표계로 바꾸어 출력하게 된다.  

### 왼손 좌표계 & 오른손 좌표계
두 좌표계의 차이는 +z축이 진행하는 방향에 있다.     
왼손 좌표계에서의 +z축은 화면 안쪽으로 향하며, 오른손 좌표계에서는 화면 바깥쪽으로 향한다.  
Direct3D와 Unity3D는 왼손좌표계를 사용한다.

![좌표계](/img/coordinate0.png)

2차원에서 도형은 한 점(원점 또는 임의의 위치)을 기준으로 회전된다.  
하지만 3차원에서는 하나의 축(x, y, z축 혹은 임의의 축)을 기준으로 개체가 회전된다.

왼손 좌표계에서 회전 방향은 각 축에 대해 시계방향(clockwise)이다.   
왼주먹을 말아쥐고 엄지를 들었을 때 엄지방향이 회전축 방향, 말아쥔 손가락 방향이 회전방향임을 알 수 있다.

오른손 좌표계에서 회전 방향은 각 축에 대해 반시계방향(counterclockwise)이다.    
오른주먹을 말아쥐고 엄지를 들었을 때 엄지방향이 회전축 방향, 말아쥔 손가락 방향이 회전방향임을 알 수 있다.

![좌표계](/img/coordinate1.png)

# 2.1. 데카르트 좌표계
데카르트 좌표계는 수학에서 점들의 위치를 숫자의 조합으로 나타내는 방법 중 하나로, 평면이나 공간 상의 점들을 좌표로 표현할 수 있는 체계이다.     
이는 수학자 르네 데카르트에 의해 개발된 것으로, 대부분의 수학 분야에서 사용되는 중요한 개념 중 하나이다.

데카르트 좌표계는 평면과 공간을 직교하는 좌표 축들로 나타내며, 각 축은 서로 수직이며 원점을 공유한다.   
이 좌표축은 수평축을 x축, 수직축을 y축이라고 하는 경우가 많으며, 공간을 다루는 경우에는 추가적으로 수직축을 z축으로 추가할 수 있다.     

2차원 데카르트 좌표계:

- x축과 y축으로 구성된다.
- 각 점은 (x,y)와 같은 숫자 쌍으로 표현된다.
- 원점 (0,0)은 x축과 y축이 교차하는 지점이다.

3차원 데카르트 좌표계:

- x축, y축, z축으로 구성된다.
- 각 점은 (x,y,z)와 같은 숫자 세 개의 조합으로 표현된다.
- 원점 (0,0,0)은 세 축이 모두 교차하는 지점이다.

데카르트 좌표계를 사용하면 공간 상의 점들을 좌표로 표현하고, 이를 통해 거리, 각도, 면적 등을 계산하거나 문제를 해결할 수 있다.  
예를 들어, 두 점 간의 거리는 피타고라스의 정리를 사용하여 계산할 수 있다.

# 2.2. 극좌표계
삼각함수의 극좌표계는 데카르트 좌표계와는 다른 방식으로 점들의 위치를 나타내는 좌표 체계이다.   
극좌표계는 각도와 반지름의 조합으로 점의 위치를 나타내는 방식으로, 원의 중심으로부터의 거리와 각도로 점을 표현한다.     
이는 주로 원형 대칭, 원의 반지름과 각도와 관련된 문제에서 사용되며, 물체의 회전 운동과 같은 문제에도 적용될 수 있다.

극좌표계에서 한 점은 $(r, \theta)$로 나타내며, 여기서 $r$은 극좌표에서 원의 중심으로부터의 거리(반지름), $\theta$는 각도이다.   
각도는 라디안 형태로 표현된다.

데카르트 좌표계와 극좌표계 간의 변환은 다음과 같이 이루어진다:

$x = r \cdot \cos(\theta)$  
$y = r \cdot \sin(\theta)$

여기서 (x,y)는 데카르트 좌표계의 좌표이며, $(r, \theta)$는 극좌표계의 좌표이다.

### 예시:
만약 $(r, \theta) = (3, \pi/4)$라면, 이는 극좌표계에서 반지름이 3이고 각도가 $\pi/4$인 점을 나타낸다.   
데카르트 좌표계로 변환하며:

$x = 3 \cdot \cos(\pi/4) = \frac{3}{\sqrt{2}} \approx 2.1213$   
$y = 3 \cdot \sin(\pi/4) = \frac{3}{\sqrt{2}} \approx 2.1213$

따라서, 데카르트 좌표계에서의 좌표는 (2.1213, 2.1213)이다.

극좌표계는 특히 원 대칭과 각도 관련 문제에서 데카르트 좌표계보다 간단하고 편리하게 사용된다.    
또한 물체의 위치와 회전 운동을 설명할 때도 적용될 수 있다.

# 3. 피타고라스 정리

![피타고라스](/img/pytha0.svg)      
$a^2 + b^2 = c^2$   
직각삼각형에서 빗변의 길이의 제곱은 나머지 두 변의 길이를 제곱한 뒤 더한 것과 같다.

직각삼각형의 세 변의 길이를 각각 a, b, c 라 하고 변 a, b 사이 각도가 직각을 이룰 때, 즉 변 c가 빗변일때 $a^2 + b^2 = c^2$가 성립함을 뜻한다.

### 유클리드의 증명법

![피타고라스](/img/pytha1.gif)

위의 그림과 같이 $\angle C = 90^\circ$인 직각삼각형 ABC 에 대하여 세 변의 길이를 각각 한 변의 길이로 하는 정사각형 ADEB, ACHI, BFGC를 그린다.   
점 C에서 변 AB에 내린 수선의 발을 M, 그 연장선과 변 DE와 만나는 점을 N이라고 하자.      
이 때   
1. $\Box ACHI = 2 \triangle ACI$   

또, 밑변의 길이와 높이가 각각 같으므로,     

2. $\triangle ACI = \triangle ABI$

두 변의 길이와 그 끼인각의 크기가 각각 같으므로,    

3. $\triangle ABI \equiv \triangle ADC$    

밑변의 길이와 높이가 각각 같으므로,     

4. $\triangle ADC = \triangle ADM$     
5. $\Box ADNM = 2 \triangle ADM$   

(1), (2), (3), (4), (5)에서     

6. $\Box ACHI = \Box ADNM$  

같은 방법으로

7. $\Box ACHI = \Box ADNM$

(6), (7)에서    
$\Box ADEB = \Box ACHI + \Box BFGC$     
$\therefore \overline{AB}^2 = \overline{BC}^2 + \overline{BC}^2$

### 바스카라의 증명법

![피타고라스](/img/pytha2.png)

정사각형 ABCD를 기준으로, 대각선이 c가 되는 직각 삼각형을 그린다.   

그러면 삼각형 ABE와 같은 모양이 된다.   
그리고, 각 모서리를 기준으로 돌려가면서 배치하면, 가운데 정사각형 EFGH를 남겨놓는 모양이 된다.

넓이를 비교하면,
- S1 = 전체 정사각형(ABCD)의 넓이 = $c \times c = c^2$
- S2 = 부분 도형들의 넓이의 함 = $\triangle ABE + \triangle BCF + \triangle GCD + \triangle AHD + \Box EFGH = 4 \times \frac{1}{2} \times a \times b + (b - a)^2$

S1 = S2 이므로,     
$c^2 = 2ab + b^2 - 2ab + a^2$   
$c^2 = a^2 + b^2$   
$a^2 + b^2 = c^2$

# 4. 삼각비

직각삼각형의 세 변의 길이 중 두 변의 길이간의 비례 관계를 나타내는 값이다.  
일반적으로 비례 관계는 분수로 나타낸다.     
또한 $\sin$과 $\cos$은 반비례한다.  

항상 빗변의 길이를 나눠야 될 물리량으로 생각하면 직관적으로 적용할 수 있다.     
밑변의 길이에서 나누면 코사인(cosine), 높이에서 나누면 사인(sine)이라고 한다.

![삼각비](/img/triratios0.webp)

엄밀하게는 직각삼각형에 대해 sine, cosine, tangent를 다음과 같이 정의한다.  
$$\sin A = \frac{a}{h}$$
$$\cos A = \frac{b}{h}$$
$$\tan A = \frac{a}{b}$$

그리고 이들을 역수로서 cosecant, secant, cotangent 함수를 다음과 같이 정의한다.
$$\csc A = \frac{1}{\sin A} = \frac{h}{a}$$
$$\sec A = \frac{1}{\cos A} = \frac{h}{b}$$
$$\cot A = \frac{1}{\tan A} = \frac{b}{a}$$

# 5. 삼각함수
삼각비에서 쓰이는 정의역을 예각($0^\circ$ 에서 $90^\circ$ 사이의 각)에서 일반각(기존의 예각은 물론 예각이 아닌 각까지 포함하는 더 넓은 개념)으로 확장시킨 것을 삼각함수라고 한다.

### 일반각과 삼각비
일반각을 정의하는 방법에는 도($^\circ$)를 단위로 하는 육십분법과 라디안(rad)을 단위로 하는 호도법이 있다.

- 육십분법(단위: $^\circ$)은 시초선을 기준($0^\circ$)으로 하여 1회전을 $360^\circ$로 정의하는 각이다.
- 호도법(단위: rad)은 부채꼴에서 중심각의 크기와 호의 길이가 반지름에 비례한다는 특징과, '원주가 지름의 $\pi$배(원주가 반지름의 $2\pi$배)'라는 성질을 이용하여 정의되는 각이다. (차원이 없다.)

### 좌표와 원으로 정의하기
![삼각함수](/img/trifunc0.svg)

좌표평면 상 원점 $O$가 중심인 단위원을 고려하자.    
단위원 위의 한 점 $P(x, y)$에 대해여 $x$축의 양의 방향을 시초선으로 잡는다.     
$O$를 중심으로 시초선에서 반시계 방향 회전을 각의 양의 방향으로 잡고, 그 각의 크기를 $\theta$라고 하면, 다음으로 정의한다.
$$\sin \theta := y$$
$$\cos \theta := x$$
$$\tan \theta := \frac{y}{x}\quad (x \neq 0)$$

동경이 몇 사분면에 위치하는지에 따라 삼각함수의 부호는 달라진다.

|동경의 위치|1사분면|2사분면|3사분면|4사분면|
|---|---|---|---|---|
|사인의 부호|$+$|$+$|$-$|$-$|
|코사인의 부호|$+$|$-$|$-$|$+$|
|탄젠트의 부호|$+$|$-$|$+$|$-$|

$\theta$가 예각일 때, 위의 관계식은 빗변의 길이가 1인 직각삼각형에서 삼각비를 정의했던 것과 완전히 같다.    
차이점은 (0 또는 음수가 될 수 없는)'길이' 개념에서 벗어나 '좌표'를 이용하기 때문에 직각삼각형에 구애받을 필요가 없고, 따라서 $\theta$가 일반각으로 확장된다.

다음과 같이 삼각함수의 역수를 정의한다.
$$\sec \theta := \frac{1}{\cos \theta} = \frac{1}{x} \quad (x \neq 0)$$
$$\csc \theta := \frac{1}{\sin \theta} = \frac{1}{y} \quad (y \neq 0)$$
$$\cot \theta := \frac{1}{\tan \theta} = \frac{x}{y} \quad (y \neq 0)$$

각각 '시컨트', '코시컨트', '코탄젠트'라 읽는다.     
또, 코시컨트는 $\cosec x$로 쓰기도 한다.

좌표평면 상 원점 $O$가 중심이고, 반지름이 $r$인 원 위의 점 $(x, y)$에 대해서도 동일한 방법으로 정의가 가능하며, 아래와 같다.
$$\sin \theta := \frac{y}{r}$$
$$\cos \theta := \frac{x}{r}$$
$$\tan \theta := \frac{y}{x}$$

주의해야 할 것은 거듭제곱 꼴로 나타낸 경우, 예를 들어 $\sin^n \theta$, 그것은 $n$번 함수를 합성한 것이 아닌 함숫값의 $n$제곱의 값을 의미한다.   
즉, $\sin^2 \theta = (\sin \theta)^2 \neq \sin(\sin \theta)$

# 5.1. 삼각함수를 활용한 물체의 회전
삼각함수는 물체의 회전과 같은 주기적인 운동을 모델링하고 분석하는 데 매우 유용하게 사용된다.    
물체의 회전은 주기적으로 반복되는 움직임이므로, 삼각함수의 주기성과 파동의 특성을 활용하여 설명할 수 있다.

회전 운동의 주요 특성을 삼각함수를 통해 설명하는 데에는 주로 사인 함수와 코사인 함수가 사용된다.

### 사인 함수와 코사인 함수의 활용:
1. 사인 함수 (Sine Function): 사인 함수는 주기적인 진동을 나타내는데 사용된다.      
물체가 주기적으로 왕복하거나 진동할 때 사인 함수가 적용될 수 있다.      
예를 들어, 시계 바늘이나 그림자의 움직임과 같이 주기적으로 변화하는 움직임은 사인 함수를 통해 모델링할 수 있다.
2. 코사인 함수 (Cosine Function): 코사인 함수도 사인 함수와 마찬가지로 주기적인 운동을 나타내는 데 사용된다.    
코사인 함수는 움직임의 초기 위상을 나타내거나, 사인 함수와 함께 사용하여 복잡한 주기 운동을 설명하는 데 활용된다.

### 각도와 시간의 관계:
물체의 회전 운동을 설명할 때는 일반적으로 각도와 시간의 관계를 사용한다.    
각도는 물체가 회전한 정도를 나타내며, 시간은 회전이 진행되는 동안의 흐름을 나타낸다.    
각도를 라디안으로 표현하면 수학적인 계산이 더 편리해지며, 이를 통해 각도와 삼각함수를 연결할 수 있다.

# 5.2. 삼각함수의 역함수
삼각함수의 역함수는 원래의 삼각함수 함수들의 역전된 동작을 나타내는 함수이다.   
각각의 삼각함수에 대해 역함수가 존재하며, 역함수는 원래 함수의 출력값을 입력값으로 사용하여 원래의 입력값을 찾아내는 역할을 한다.   
역함수는 각도나 비율과 같은 삼각함수의 입력값을 구할 때 유용하게 사용된다.

1. 사인 함수의 역함수 (Arcsine, asin):
사인 함수의 역함수는 주어진 숫자의 사인 값을 입력으로 받아 그에 해당하는 각도를 출력으로 내놓는다.  
일반적으로 arcsin 또는 asin으로 표기된다.   
즉, $\sin(\theta) = x$ 일 때, $\theta = \arcsin(x)$이다.    
주의할 점은 역함수의 출력은 $-\pi/2$에서 $\pi/2$ 범위에 제한되어 있다.
2. 코사인 함수의 역함수 (Arccosine, acos):  
코사인 함수의 역함수는 주어진 숫자의 코사인 값을 입력으로 받아 그에 해당하는 각도를 출력으로 내놓는다.      
일반적으로 arccos 또는 acos로 표기된다.     
즉, $\cos(\theta) = x$ 일 때, $\theta = \arccos(x)$이다.    
역함수의 출력은 0에서 $\pi$ 범위에 제한되어 있다.
3. 탄젠트 함수의 역함수 (Arctangent, atan):     
탄젠트 함수의 역함수는 주어진 숫자의 탄젠트 값을 입력으로 받아 그에 해당하는 각도를 출력으로 내놓는다.  
일반적으로 arctan 또는 atan로 표기된다.     
즉, $\tan(\theta) = x$ 일 때, $\theta = \arctan(x)$이다.    
역함수의 출력은 $-\pi/2$에서 $\pi/2$ 범위에 제한되어 있다.

각 역함수의 범위에는 주의해야 하며, 일부 역함수 값은 다른 값으로 매핑될 수 있기 때문에 주의 깊게 사용해야 한다.     
역함수는 삼각함수의 역전 동작을 반대로 해석하거나, 각도를 계산하는 데 사용할 수 있다.

### 예시:
움직이는 바닥에 그림자가 떨어지는 상황을 가정해본다.    
물체의 회전에 의해 그림자의 길이가 주기적으로 변하는 경우, 사인 함수를 사용하여 그림자의 길이와 시간의 관계를 표현할 수 있다.   
그림자의 길이는 각도의 변화와 관련이 있으며, 각도와 시간의 관계를 삼각함수로 표현하여 회전 운동을 모델링할 수 있다.

이와 같이 삼각함수는 회전 및 주기적인 운동을 수학적으로 모델링하고 분석하는 데 사용되며, 물리학, 공학, 컴퓨터 그래픽스 등 다양한 분야에서 활용된다.

# 5.3. 삼각함수의 덧셈 정리
삼각함수의 덧셈 공식은 두 개의 각에 대한 삼각함수 값을 더할 때 사용되는 공식이다.   
이 공식을 사용하면 두 각의 삼각함수 값을 더하거나 빼는 것을 더 쉽게 계산할 수 있다.     
주로 삼각함수 값을 합치거나 분해하는 데 사용되며, 삼각형의 변의 길이나 각의 관계를 계산하는 데에도 활용된다.

주요한 삼각함수의 덧셈 공식은 다음과 같다:

1. 사인 함수의 덧셈 공식:   
$\sin(\alpha + \beta) = \sin(\alpha) \cos(\beta) + \cos(\alpha) \sin(\beta)$
2. 코사인 함수의 덧셈 공식:     
$\cos(\alpha + \beta) = \cos(\alpha) \cos(\beta) - \sin(\alpha) \sin(\beta)$
3. 탄젠트 함수의 덧셈 공식:     
$\tan(\alpha + \beta) = \frac{\tan(\alpha) + \tan(\beta)}{1 - \tan(\alpha) \tan(\beta)}$

이 공식들을 사용하면 두 각의 삼각함수 값을 더하거나 빼는 것을 수월하게 계산할 수 있다.

# 6. 수와 집합
### 수 (Numbers):
수는 양, 음, 정수, 유리수, 실수 등으로 나타낼 수 있는 개념이다.     
여러 가지 형태와 특성을 갖는다.

1. 자연수 (Natural Numbers): 1, 2, 3, 4와 같이 양의 정수들을 의미한다.  
주로 자연적인 세기나 계산에 사용된다.
2. 정수 (Integers): 0, 양의 정수, 음의 정수를 포함한 수의 집합이다.     
양의 정수와 음의 정수는 무한대로 확정될 수 있다.
3. 유리수 (Rational Numbers): 두 정수의 나눗셈으로 나타낼 수 있는 수를 의미한다.    
이 때 분모는 0이 아니어야 한다.     
예를 들어 1/2, -3/4 등이 유리수이다.
4. 실수 (Real Numbers): 유리수와 더불어 모든 실수를 포함하는 집합이다.  
실수는 실제 세계의 대부분의 측정이나 계산에 사용된다.   
실수는 무한 소수로 나타낼 수도 있다.
5. 복소수 (Complex Numbers): 실수와 허수를 합한 수이다.     
허수는 실수와 곱하여 -1을 얻는 수로, i라는 기호로 표현한다.     
복소수는 a + bi 형태로 나타낼 수 있으며, 여기서 a는 실수 부분이고 bi는 허수 부분이다.

### 집합 (Sets):
집합은 원소들의 모임을 나타내는 개념이다.   
집합은 중복되지 않는 원소들로 구성된다.     
수학적으로 집합은 중괄호 {} 안에 원소를 나열하여 나타낼 수 있다.

예를 들어, A = {1, 2, 3}은 원소 1, 2, 3으로 구성된 집합 A를 나타낸다.   
또 다른 예로, B = {red, green, blue}는 색상을 나타내는 집합 B를 나타낸다.

집합의 특성:

- 원소 (Elements): 집합을 구성하는 각각의 개별 요소를 원소라고 한다.
- 원소의 중복: 집합은 중복된 원소를 허용하지 않는다.    
즉, 하나의 원소는 집합 내에서 유일하게 나타난다.
- 집합의 크기: 집합 내 원소의 개수를 집합의 크기 또는 원소의 개수라고 한다.
- 부분집합 (Subset): 집합 A의 모든 원소가 집합 B에도 속할 때, 집합 A는 집합 B의 부분집합이라고 한다.
- 합집합 (Union): 두 개 이상의 집합에서 모든 원소들을 모아 새로운 집합을 만들 때, 이를 합집합이라고 한다.
- 교집합 (Intersection): 두 개 이상의 집합에서 공통으로 포함된 원소들을 모아 새로운 집합을 만들 때, 이를 교집합이라고 한다.

집합 이론은 수학적 분석, 확률론, 그래프 이론 등 다양한 분야에서 활용되며, 수와 관련된 다양한 개념과 연산을 다루는데 사용된다.

# 6.1. 연산과 수의 구조
### 연산 (Operations):
연산은 수나 다른 개체들 사이에서 수행되는 계산 또는 작용을 의미한다.    
연산은 수학적으로 다양한 형태로 나타낼 수 있으며, 주요한 연산에는 다음과 같은 것들이 있다.

1. 덧셈 (Addition): 두 수를 더하는 연산이다.    
덧셈은 수의 합을 구하는 데 사용된다.
2. 뺄셈 (Substraction): 하나의 수에서 다른 수를 빼는 연산이다.  
뺄셈은 두 값 사이의 차이를 구하는 데 사용된다.
3. 곱셈 (Multiplication): 두 수를 곱하는 연산이다.  
곱셈은 수의 증가율, 면적 등을 계산하는 데 사용된다.
4. 나눗셈 (Division): 하나의 수를 다른 수로 나누는 연산이다.    
나눗셈은 비율, 분수 등을 표현하는 데 사용된다.
5. 지수 (Exponentiation): 수를 다른 수의 거듭제곱으로 나타내는 연산이다.    
a^n은 a를 n번 곱하는 것을 의미한다.
6. 제곱근 (Square Root): 어떤 수의 제곱이 특정한 값이 되도록 하는 수를 찾는 연산이다.

### 수의 구조:
수의 구조는 수들 간의 관계와 패턴을 이해하고 분석하는 데 도움을 준다.

1. 집합 구조: 수는 집합의 원소로 나타낼 수 있다.    
집합에는 원소 간의 연산인 합집합, 교집합 등의 연산이 있다.
2. 순서 구조: 수의 순서는 수열이나 수량을 나타내는 데 사용된다.     
수열은 수들이 순서대로 나열된 구조이다.
3. 대수 구조: 수의 대수 구조는 수들 간의 연산에 관한 구조를 의미한다.   
이에는 그룹, 반환, 체 등이 포함된다.
4. 유한성과 무한성: 수의 구조에는 유한한 수의 개수와 무한한 수의 개수가 있다.   
자연수 집합은 무한한 원소를 가지지만, 유한한 집합도 있을 수 있다.
5. 소수와 합성수: 소수는 1과 자기 자신만을 약수로 가지는 수이다.    
합성수는 두 개 이상의 양의 약수를 가지는 수이다.
6. 모듈로 구조: 모듈로 연산은 나눗셈의 나머지를 다루는 구조이다.    
이 구조는 순환 패턴이나 주기성을 분석하는 데 사용된다.
7. 순열과 조합: 순열은 원소들의 순서에 따른 나열을 의미하고, 조합은 원소들의 순서에 관계 없는 선택을 의미한다.  
이들은 주로 카운팅 문제나 확률 문제에서 사용된다.

수의 구조와 연산은 수학의 핵심 개념이며, 이를 통해 다양한 문제를 분석하고 해결할 수 있다.

# 6.2. 수의 표현
수는 다양한 방법으로 표현될 수 있다.    
각각의 표현 방법은 수의 특성이나 용도에 따라 선택될 수 있다.    

1. 십진법 (Decimal Notation):   
십진법은 일상 생활에서 가장 많이 사용되는 표현 방법이다.    
숫자 0부터 9까지의 10개의 기호를 사용하여 수를 나타낸다.    
수의 위치가 변화함에 따라 그 값이 달라지는 위치 표기법을 사용한다.      
예를 들어, 365는 3 * 10^2 + 6 * 10^1 + 5 * 10^0으로 표현된다.

2. 이진법 (Binary Notation):    
이진법은 0과 1의 두 개의 기호만을 사용하여 수를 나타내는 방법이다.      
컴퓨터 시스템에서 주로 사용되며, 전기 신호의 온/오프 상태로 표현된다.   
예를 들어, 101은 1 * 2^2 + 0 * 2^1 + 1 * 2^0으로 표현된다.

3. 프로그래밍에서의 표현:   
프로그래밍 언어에서는 정수, 부동소수점, 복소수 등 다양한 형식으로 수를 표현할 수 있다.      

4. 지수 표기법 (Scientific Notation):   
매우 크거나 작은 수를 간결하게 표현하기 위해 지수 표기법을 사용한다.    
예를 들어, 3,000,000은 3 * 10^6으로 표현할 수 있다.

5. 분수 (Fractions):    
분수는 두 개의 정수를 나누어 나타내는 표현 방법이다.    
분자와 분모로 구성되며, 분자는 분모를 나눈 몫을 나타낸다.   
예를 들어, 1/2는 분자가 1이고 분모가 2인 분수를 나타낸다.

6. 소수 (Decimal Fractions):    
소수는 십진법에서 소수점을 가진 수로, 정수와 소수 부분으로 나누어 나타낸다.     
예를 들어, 3.14159sms 정수 부분이 3이고 소수 부분이 0.14159인 소수이다.

7. 혼합수 (Mixed Numbers):  
정수 부분과 분수 부분을 함께 가진 표현 방법이다.    
예를 들어, 2 1/2는 정수 부분이 2이고 분수 부분이 1/2인 혼합수를 나타낸다.

8. 복소수 (Complex Numbers):    
실수와 허수 부분으로 구성된 수이다.     
a + bi 형태로 나타내며, a는 실수 부분이고 bi는 허수 부분이다.

이러한 다양한 표현 방법은 수학적 계산, 과학, 엔지니어링, 프로그래밍 등 다양한 분야에서 사용되며, 특정한 문제나 상황에 맞게 선택하여 사용한다.

# 7. 함수
함수는 수학과 다양한 분야에서 중요한 개념으로 사용되는 개념이다.    
함수는 입력값을 받아서 특정한 규칙에 따라 출력값을 계산하는 규칙이나 연산을 나타내는 수학적 객체이다.   
함수는 다양한 형태와 목적으로 사용된다.

### 함수의 구성요소:
1. 입력 (Domain): 함수에 입력되는 값들의 집합을 의미한다.   
이 집합은 함수가 정의되는 범위를 결정한다.
2. 출력 (Codomain 또는 Range): 함수가 입력값을 대응시켜 계산한 결과값들의 집합이다.     
함수의 출력값은 입력값에 따라 달라질 수 있다.
3. 규칙 (Rule): 함수가 입력값을 어떤 연산에 따라 출력값으로 변환하는지를 나타내는 부분이다.     
이 규칙은 함수의 정의에 따라 달라진다.

### 함수의 표기법:
함수는 보통 다음과 같이 표기된다: f(x), g(y), h(z)와 같이 함수 이름 다음에 입력값을 나타내는 변수를 괄호 안에 표기한다.     
함수 이름은 임의로 지정할 수 있으며, 입력 변수도 함수에 따라 다를 수 있다.

### 예시:
1. 선형 함수 (Linear Function): 가장 간단한 함수 중 하나로, 출력값이 입력값에 대해 일정한 비율로 변하는 함수이다.   
예를 들어, f(x) = 2x는 입력값을 2배씩 증가시켜 출력값을 계산한다.
2. 제곱 함수 (Quadratic Function): 출력값이 입력값의 제곱에 관련된 함수이다.    
예를 들어, g(x) = x^2는 입력값을 제곱하여 출력값을 계산한다.
3. 삼각 함수 (Trigonometric Function): 삼각형의 각도와 변의 비율에 관련된 함수로, 삼각함수(sin, cos, tan 등)는 각도에 따른 값을 계산한다.
4. 지수 함수 (Exponential Function): 출력값이 입력값의 지수에 관련된 함수로, f(x) = e^x는 입력값의 지수에 해당하는 값들을 출력값으로 계산한다.

### 함수의 활용:
함수는 수학뿐만 아니라 과학, 공학, 경제학, 컴퓨터 과학 등 다양한 분야에서 활용된다.     
함수는 데이터 분석, 모델링, 문제 해결 등에 사용되며, 복잡한 현상을 간단한 규칙으로 설명할 수 있는 도구로 활용된다.      
함수의 연속성, 미분, 적분 등의 특성은 미적분학과 같은 수학 분야에서 중요한 개념이다.

# 7.1. 함수의 개념과 종류
### 함수의 개념:
함수는 입력과 출력 간의 대응 관계를 정의하는 수학적 규칙이다.   
어떤 집합의 각 원소(입력)가 다른 집합의 원소(출력)와 대응된다.      
이때, 하나의 입력에 대해 하나의 출력이 대응되어야 한다.     
함수는 특정한 규칙에 따라 입력값을 처리하고 연산하여 출력값을 생성하는 과정을 나타낸다.

수학적으로 함수는 다음과 같이 표기된다:     
$f : X \rightarrow Y$   
여기서 $f$는 함수의 이름, $X$는 입력의 집합(도메인), $Y$는 출력의 집합(치역)을 나타낸다.    
입력 $x$가 주여졌을 때, 함수 $f(x)$로 나타내며 이는 입력 $x$에 대응되는 출력값을 의미한다.

### 함수의 종류:
1. 선형 함수 (Linear Functions): 출력이 입력에 대해 일정한 비율로 변화하는 함수이다.    
$f(x) = ax + b$ 형태로 나타낼 수 있으며, $a$는 기울기를, $b$는 y 절편을 나타낸다.
2. 다항 함수 (Polynomial Functions): 여러 항의 합으로 표현되는 함수로, $f(x) = a_nx^n + a_{n-1}x^{n-1} + ... + a_1x + a_0$ 형태이다.    
n은 차수를 나타내며, $a_n$부터 $a_0$은 계수이다.
3. 지수 함수 (Exponential Functions): 출력이 입력값의 지수에 관련된 함수이다.   
$f(x) = a^x$ 형태로 나타낼 수 있으며, $a$는 기저이며 양수여야 한다.
4. 로그 함수 (Logarithmic Functions): 입력값의 로그에 관련된 함수이다.      
$f(x) = \log _a(x)$ 형태로 나타낼 수 있으며, $a$는 양수인 상수이며, 입력 $x$는 양수여야 한다.
5. 삼각 함수 (Trigonometric Functions): 삼각형의 각도와 변의 비율에 관련된 함수로, 삼각함수인 $\sin (x), \cos (x), \tan (x)$ 등이 있다.
6. 복소 함수 (Complex Functions): 복소수를 입력값이나 출력값으로 가지는 함수이다.   
$f(z)$ 형태로 표기되며, $z$는 복소수이다.
7. 계단 함수 (Step Functions): 입력값의 범위에 따라 출력값이 불연속적으로 변화하는 함수이다.    
주로 디지털 신호 처리 등에 활용된다.
8. 비선형 함수 (Nonlinear Functions): 선형이 아닌 형태로 출력값이 입력값에 대해 변화하는 함수들을 포함한다.     
다항 함수, 지수 함수, 로그 함수 등이 비선형 함수에 해당된다.

# 7.2. 합성 함수
합성 함수는 두 개 이상의 함수를 결합하여 새로운 함수를 만드는 개념이다.     
하나의 함수의 출력값을 다른 함수의 입력값으로 사용하여 새로운 함수를 생성하는 것을 의미한다.    
이렇게 합성된 함수는 두 개의 함수를 조합한 결과로, 입력을 첫 번째 함수에 넣고 그 출력을 다시 두 번째 함수의 입력으로 넣어 최종 출력값을 얻는다.

합성 함수의 표기는 $(f \circ g)(x)$와 같이 표현됩니다. 여기서 $f$와 $g$는 두 개의 함수이며, $x$는 입력 변수이다.    
합성 함수에서 먼저 입력 $x$가 함수 $g$의 입력으로 들어가고, 그 결과가 함수 $f$의 입력으로 들어가 최종 출력값이 계산된다.

수식적으로 나타내면 다음과 같습니다:    
$(f \circ g)(x) = f(g(x))$

### 예시:
1. 함수 $f(x) = 2x$와 함수 $g(x) = x + 3$이 있다고 가정해 본다.     
이 경우 합성 함수 $(f \circ g)(x)$는 다음과 같이 계산된다:    
$(f \circ g)(x) = f(g(x)) = f(x + 3) = 2(x + 3) = 2x + 6$

2. 함수 $h(x) = x^2$와 함수 $k(x) = \sqrt{x}$가 있다고 가정해 본다.     
이 경우 합성 함수 $(h \circ k)(x)$는 다음과 같이 계산된다:      
$(h \circ k)(x) = h(k(x)) = h(\sqrt{x}) = (\sqrt{x})^2 = x$

합성 함수는 함수를 조합하고 복잡한 연산을 간편하게 표현할 수 있는 강력한 도구이다.  
실제로 다양한 수학적, 과학적, 공학적 문제에서 사용되며, 함수들 간의 관계를 분석하고 모델링하는데 유용하게 활용된다.

# 7.3. 항등함수와 역함수
항등함수와 역함수는 함수의 중요한 개념 중 하나로, 서로 반대되는 역할을 하는 함수이다.

### 항등함수 (Identity Function):
항등함수는 입력값과 출력값이 동일한 함수를 말한다.      
다시 말해, 모든 입력값에 대해 출력값이 그 입력값과 같은 함수이다.   
수학적으로 표기하면 다음과 같다:

$f(x) = x$

여기서 $f(x)$는 항등함수이며, $x$는 입력 변수이다.      
항등함수는 어떤 값을 넣어도 그 값을 그대로 반환하는 역할을 한다.    
그래프로 나타내면 직선 $y = x$와 같은 형태가 된다.

### 역함수 (Inverse Function):
역함수는 어떤 함수의 입력과 출력의 역할을 뒤바꾼 함수를 말한다.     
즉, $f(x)$가 어떤 함수일 때, $f$의 출력값을 입력값으로, $f$의 입력값을 출력값으로 가지는 함수를 $f$의 역함수라고 한다.      
역함수는 $f^{-1}$로 표기하며, 다음과 같이 나타낼 수 있다:

$f^{-1}(f(x)) = x$  
$f(f^{-1}(x)) = x$

여기서 $f^{-1}(x)$는 $f$의 역함수이며, $x$는 입력 변수이다.     
역함수는 원래 함수의 반대 동작을 수행하므로, $f$의 출력값을 넣으면 원래 입력값이 나오고, $f$의 입력값을 넣으면 원래 출력값이 나온다.

### 예시:
1. 항등함수: $f(x) = x$는 입력값과 출력값이 같은 항등함수이다.
2. 역함수: $f(x) = 2x$일 때, $f^{-1}(x) = \frac{x}{2}$가 역함수이다.    
즉, $f(f^{-1}(x)) = 2(\frac{x}{2}) = x$가 되며, 역으로도 $f^{-1}(f(x)) = \frac{2x}{2} = x$가 된다.

항등함수와 역함수는 함수의 특성과 관계를 분석하는 데 중요한 역할을 한다.    
역함수를 구하는 것은 함수의 규칙과 역전을 이해하는 데 도움이 되며, 실제 문제에서도 활용되는 경우가 많다.

# 7.4. 곱집합을 활용한 좌표 평면으로의 확장
곱집합을 활용한 좌표 평면으로의 확장은 수학적 개념을 사용하여 2개의 집합을 결합하여 새로운 공간을 생성하는 것을 의미한다.   
이를 통해 2개 이상의 차원을 가지는 좌표 평면이나 공간을 표현할 수 있다.

일반적으로, 2차원 좌표 평면은 숫자 쌍인 x와 y로 표현되는 점들의 집합이다.   
각 점은 x축과 y축의 값으로 나타내지며, 예를 들어 (2,3)은 x=2와 y=3의 교차점을 의미한다.

이제, 좌표 평면을 확장하여 3차원 공간으로 생각해 보겠다.    
이때, 각 점은 숫자 쌍이 아닌 숫자 세 개의 조합 (x,y,z)로 표현된다.      
이렇게 하여 3차원 공간에서 각 점은 x,y,z 축에 의해 정의된다.

마찬가지로, 곱집합을 사용하여 좌표 평면이나 공간을 더 높은 차원으로 확장할 수 있다.     
n차원 공간에서 각 점은 숫자 n개의 조합 $(x_1, x_2, ..., x_n)$로 표현된다.   
이런 식으로 곱집합을 사용하여 다차원 공간을 생성하면, 좌표 평면이나 공간에서의 점들을 더 다양하게 나타낼 수 있다.

### 예시:
1. 2차원 좌표 평면: 점 (2,3)은 x=2와 y=3의 교차점이다.
2. 3차원 공간: 점 (2,3,4)는 x=2, y=3, z=4의 교차점으로, 3차원 공간에서의 위치를 나타낸다.
3. 4차원 공간: 점 (1,2,3,4)는 4개의 좌표 축으로 나타낸 4차원 공간에서의 점이다.     
이는 상상력을 초월하는 개념이므로 시각적으로는 표현하기 어려울 수 있다.

이와 같이 곱집합을 사용하여 좌표 평면이나 다차원 공간을 확장하는 개념은 수학적 모델링, 공학, 물리학, 컴퓨터 그래픽스 등 다양한 분야에서 사용되며, 다차원 공간에서의 데이터나 개념을 표현하는 데 유용하다.

# 8. 행렬
게임 수학에서 행렬은 게임의 다양한 측면을 모델링하고 해결하는 데 사용되는 중요한 수학적 도구이다.   
행렬은 게임 엔진 개발, 그래픽스, 물리 시뮬레이션, 인공지능 등 다양한 영역에서 활용되며, 게임 내의 객체의 변환, 충돌 감지, 렌더링, 카메라 관리 등에 사용된다.

1. 변환 행렬 (Transformation Matrices): 물체의 이동, 회전, 크기 조절과 같은 변환은 행렬을 사용하여 표현될 수 있다.  
이러한 변환 행렬을 사용하면 게임 객체들의 위치와 방향을 효과적으로 제어할 수 있다.
2. 카메라 행렬 (Camera Matrices): 게임 내에서 카메라의 위치와 방향은 행렬로 표현된다.   
이를 통해 게임 화면을 구성하거나 3D 공간을 2D 화면에 투영할 수 있다.
3. 물리 시뮬레이션 (Physics Simulation): 물리 엔진에서 물체의 운동을 시뮬레이션하기 위해 행렬을 사용한다.   
행렬을 사용하여 물체의 위치, 속도, 가속도 등을 계산하고 시간에 따른 물체의 움직임을 예측할 수 있다.
4. 그래픽스 렌더링 (Graphics Rendering): 게임 그래픽스에서 행렬은 3D 모델의 변환과 렌더링 과정에서 중요한 역할을 한다.  
객체의 변환, 투영, 뷰 변환 등에 행렬이 사용되어 실제 화면에 어떻게 표시될지 결정된다.
5. 인공지능 (Artificial Intelligence): 게임 내의 NPC나 적 캐릭터의 움직임과 의사 결정에도 행렬이 사용된다.  
경로 탐색, 강화 학습, 행동 패턴 등을 모델링하기 위해 행렬 연산을 활용할 수 있다.

행렬은 게임 개발에서 수학적 모델링과 계산을 효과적으로 다루는 데 필수적인 도구로 활용되며, 게임의 시각적인 표현과 물리적 모델링, 인공지능 구현 등 다양한 측면에서 중요한 역할을 한다.

# 8.1. 선형성
행렬의 선형성과 예측 가능한 비례 관계는 선형대수학의 중요한 개념 중 하나이다.   
이들은 다양한 수학적 연산과 현실 세계에서의 관계를 모델링하고 분석하는 데 사용된다.

### 선형성 (Linearity):
행렬의 선형성은 다음 두 가지 기본 조건으로 정의된다:

1. 덧셈에 대한 선형성: 행렬 $A$와 $B$가 주어졌을 때, $A + B$ 역시 선형성을 만족해야 한다.   
즉, $A + B = B + A$이며, $A + (B + C) = (A + B) + C$가 성립해야 한다.   
2. 스칼라 곱에 대한 선형성: 행렬 $A$와 스칼라 $c$가 주어졌을 때, $cA$ 역시 선형성을 만족해야 한다.  
즉, $1 \cdot A = A$이며, $(cd)A = c(dA)$가 성립해야 한다.

이러한 선형성은 행렬 연산을 조합하거나 분해할 때 유용하게 사용된다.     
예를 들어, 여러 가지 선형 변환을 연결하여 복잡한 변환을 표현하거나, 선형 시스템의 해를 구하는 과정에서 선형성을 활용할 수 있다.

### 예측 가능한 비례 관계:
행렬은 예측 가능한 비례 관계를 모델링하는 데 사용될 수 있다.    
예를 들어, $Ax = b$와 같은 선형 시스템을 생각해보자.    
이 때, $A$는 변환 행렬, $x$는 입력 벡터, $b$는 결과 벡터이다.   
$A$가 주어지면 입력 벡터를 변환하여 결과 벡터를 예측할 수 있다.     
이러한 예측 가능한 비례 관계는 데이터 분석, 예측 모델링, 신호 처리 등 다양한 분야에서 활용된다.

예시:

- 선형 회귀 분석에서, 입력 변수와 결과 변수 간의 관계를 행렬과 벡터를 사용하여 모델링할 수 있다.
- 그래픽스 프로그래밍에서 변환 행렬을 사용하여 객체를 움직이고 변형시키는 것이 가능하다.

행렬의 선형성과 예측 가능한 비례 관계는 수학적 모델링과 문제 해결에 있어서 강력하고 유용한 도구다.

# 8.1.1. 선형 함수
선형 함수는 수학에서 매우 중요한 개념으로, 다음 두 가지 기본적인 성질을 만족하는 함수를 말한다:

1. 가산성 (Additivity): 함수의 입력값에 대한 합성이 결과값에 대한 합성으로 이어져야 한다.   
즉, 함수 $f$가 가산성을 만족하려면 모든 $x$와 $y$에 대해 $f(x + y) = f(x) + f(y)$이어야 한다.
2. 동차성 (Homogeneity): 함수의 입력값에 스칼라를 곱한 것이 결과값에도 그 스칼라를 곱한 것과 같아야 한다.   
즉, 함수 $f$가 동차성을 만족하려면 모든 $x$와 스칼라 $c$에 대해 $f(cx) = cf(x)$이어야 한다.

선형 함수는 주로 선형대수학이나 미적분학에서 중요한 역할을 한다.    
예를 들어, 선형 함수의 예시로 $f(x) = ax + b$를 들 수 있다.     
여기서 $a$와 $b$는 상수이며, 가산성과 동차성을 만족한다.    
선형 함수는 입력값과 결과값 간의 비례 관계를 나타내며, 다양한 수학적 문제나 현실 세계에서의 문제를 모델링하고 해결하는 데 사용된다.

선형 함수의 중요한 특징은 슈퍼포지션의 원리를 만족한다는 것이다.    
이는 한 선형 함수의 출력을 다른 선형 함수의 입력으로 사용하여 두 함수를 결합해도 결과는 여전히 선형 함수가 된다.

또한, 선형 함수는 다른 함수를 선형 변환하는데 사용되며, 이는 다양한 분야에서 활용된다.  
물리학에서는 물체의 움직임을 모델링하고, 공학에서는 시스템의 동작을 분석하는데 사용된다.    
또한, 선형 회귀 분석과 같은 통계적 기법에서도 사용된다.

### 벡터 공간의 선형 변환
벡터 공간의 선형 변환은 한 벡터 공간에서 다른 벡터 공간으로 벡터를 변환시키는 함수를 의미한다.  
선형 변환은 선형 함수의 한 형태로, 입력 벡터들에 대해 가산성과 동차성을 유지하는 변환을 말한다.     
이러한 선형 변환은 수학적 모델링, 물리학, 공학, 그래픽스 등 다양한 분야에서 사용되며, 벡터의 형태나 방향을 변화시키거나 공간을 변형하는데 활용된다.

선형 변환의 주요 특징은 가산성과 동차성이다.

선형 변환은 여러 가지 방식으로 나타낼 수 있다.  
행렬을 사용하는 것이 가장 흔한 방법 중 하나이다.    
행렬을 사용하여 벡터를 변환하는 경우, 행렬과 벡터의 곱셈을 통해 변환된 결과를 계산할 수 있다.

예시:

- 2D나 3D 그래픽스에서 변환 행렬을 사용하여 객체를 이동, 회전, 크기 조절하는 것이 선형 변환의 예시이다.
- 선형 회귀 분석에서 입력 변수들을 변환하여 결과 변수와의 관계를 모델링하는 것도 선형 변환의 한 형태이다.   
- 어떤 시스템의 입력과 출력 간의 관계를 선형 변환으로 나타내어 분석하는 것도 일반적인 응용 중 하나이다.

선형 변환은 다양한 분야에서 벡터나 공간의 변환을 모델링하고 다루는 데에 사용되며, 수학적 모델링과 문제 해결에 있어서 매우 중요한 개념 중 하나이다.

# 8.2. 행렬의 기본 연산
행렬의 기본 연산에는 덧셈, 뺄셈, 스칼라 곱, 행렬곱 등이 포함된다.   
이러한 연산들은 행렬을 다루고 변형하는 데 사용되며, 선형 대수학과 다양한 응용 분야에서 중요한 역할을 한다.

1. 행렬 덧셈과 뺄셈:    
행렬 간의 덧셈과 뺄셈은 각 원소별로 동일한 위치에 있는 원소들끼리 더하거나 뺄 때 이루어진다.    
두 행렬의 크기가 같을 때만 덧셈과 뺄셈이 가능하다.  
예시:   
$$\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix} + \begin{bmatrix} 5 & 6 \\ 7 & 8 \end{bmatrix} = \begin{bmatrix} 6 & 8 \\ 10 & 12 \end{bmatrix}$$
2. 스칼라 곱:   
행렬과 스칼라(숫자)의 곱은 해당 행렬의 모든 원소에 스칼라를 곱해주는 연산이다.  
예시:
$$2 \cdot \begin{bmatrix} 3 & 4 \\ 5 & 6 \end{bmatrix} = \begin{bmatrix} 6 & 8 \\ 10 & 12 \end{bmatrix}$$
3. 행렬곱 (Matrix Multiplication):
두 행렬 $A$와 $B$의 행렬곱 $C = AB$는 $C$의 각 원소를 $A$의 해당 행과 $B$의 해당 열의 내적으로 구한다.  
행렬곱을 수행하기 위해서는 첫 번째 행렬의 열 수와 두 번째 행렬의 행 수가 일치해야 한다.     
예시:
$$\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix} \cdot \begin{bmatrix} 5 & 6 \\ 7 & 8 \end{bmatrix} = \begin{bmatrix} 19 & 22 \\ 43 & 50 \end{bmatrix}$$
4. 전치행렬 (Transpose Matrix):     
행렬의 전치는 행과 열을 바꾸는 연산이다.    
$A$의 전치는 $A^T$로 나타내며, $A$의 $i$행과 $j$열의 원소가 $A^T$의 $j$행과 $i$열의 원소로 이동한다.    
예시:
$$\begin{bmatrix} 1 & 2 \\ 3 & 4 \end{bmatrix}^T = \begin{bmatrix} 1 & 3 \\ 2 & 4 \end{bmatrix}$$

행렬의 이러한 기본 연산들은 선형 변환, 데이터 분석, 컴퓨터 그래픽스, 공학 등 다양한 분야에서 활용되며, 행렬을 다루고 조작하는 데에 필수적이다.

# 8.3. 행렬의 설계
행렬의 설계는 행렬의 크기, 원소의 값, 구조, 목적 등을 결정하는 과정을 의미한다.     
행렬은 다양한 수학적 모델링과 문제 해결에 사용되며, 이에 따라 행렬을 어떻게 설계하느냐에 따라 결과나 성능이 크게 영향을 받을 수 있다.   
다음은 행렬의 설계에 관련된 몇 가지 요소들이다:

1. 크기 (Dimensions):   
행렬의 크기는 행과 열의 개수로 결정된다.    
행렬의 크기는 해당 문제에 맞게 결정되어야 하며, 연산이나 변환에 필요한 차원을 고려하여 정확하게 정의되어야 한다.
2. 원소의 값 (Values of Elements):  
행렬의 원소들은 해당 문제나 모델의 특성에 따라 결정된다.    
일부 문제에서는 행렬의 원소들을 임의로 설정하는 것이 가능하며, 다른 경우에는 데이터나 조건에 따라 값을 채워넣어야 할 수도 있다.
3. 구조 (Structure):    
행렬은 여러 가지 구조를 가질 수 있다.   
대각행렬, 삼각행렬, 대칭행렬, 희소행렬 등 다양한 구조의 행렬을 사용하여 특정한 성질이나 조건을 나타낼 수 있다.  
4. 목적 (Purpose):  
행렬의 설계는 해당 행렬이 어떤 목적을 위해 사용되는지에 따라 결정된다.  
예를 들어, 변환 행렬은 객체의 이동, 회전, 크기 조절과 관련하여 설계될 것이며, 데이터 분석을 위한 행렬은 주어진 데이터와 분석 목적에 따라 설계될 것이다.
5. 행렬의 종류 (Types of Matrices):     
특정한 목적이나 문제에 따라 다양한 종류의 행렬을 사용할 수 있다.    
예를 들어, 항등행렬, 영행렬, 대각행렬 등의 특수한 형태의 행렬을 활용하여 특별한 성질을 나타낼 수 있다.

행렬의 설계는 해당 문제의 특성을 이해하고 수학적인 모델을 구축하는 과정을 포함한다. 
이를 통해 행렬을 최적으로 활용하여 원하는 결과를 얻을 수 있다.

# 8.3.1. 크기 변환행렬
크기 변환 행렬은 객체나 벡터의 크기를 조절하기 위해 사용되는 변환 행렬이다.     
크기 변환은 객체를 확대 또는 축소하는 등 크기를 조절하는 변환을 의미하며, 이를 수행하기 위해 행렬을 사용할 수 있다.     
크기 변환 행렬은 주로 2D나 3D 그래픽스에서 사용되며, 객체를 원하는 크기로 변환하는데 활용된다.

2D 그래픽스에서 크기 변환 행렬은 일반적으로 다음과 같이 나타낼 수 있다:
$$S = \begin{bmatrix} S_x & 0 \\ 0 & S_y \end{bmatrix}$$

여기서 $S_x$는 $x$축 방향으로의 크기 비율이고, $S_y$는 $y$축 방향으로의 크기 비율이다.  
이 행렬을 사용하여 객체의 각 점을 변환하면, 객체가 $x$축과 $y$축 방향으로 각각 $S_x$와 $S_y$배만큼 확대 또는 축소된다.

3D 그래픽스에서 크기 변환 행렬은 다음과 같이 나타낼 수 있다:

$$S = \begin{bmatrix} S_x & 0 & 0 \\ 0 & S_y & 0 \\ 0 & 0 & S_z \end{bmatrix}$$

여기서 $S_x$, $S_y$, $S_z$는 각각 $x$축, $y$축, $z$축 방향으로의 크기 비율을 나타낸다.  
이 행렬을 사용하여 3D 객체의 각 점을 변환하면, 객체가 각 축 방향으로 크기 비율에 따라 확대 또는 축소된다.   

크기 변환행렬은 여러 가지 분야에서 활용된다:

1. 그래픽스: 2D나 3D 그래픽스에서 객체의 크기를 확대 또는 축소하는 데 사용된다.     
또한, 객체의 크기를 조절하여 시각적인 효과를 줄 수 있다.
2. 이미지 처리: 이미지를 확대 또는 축소하는데 크기 변환행렬을 사용하여 이미지를 변형하고 조정할 수 있다.
3. 물리 시뮬레이션: 물체의 크기 변환을 모델링하여 시뮬레이션하는데 사용된다.    
예를 들어, 물체가 확대되거나 수축되는 상황을 모델링할 수 있다.

크기 변환행렬은 선형 변환 중 하나로, 객체의 크기를 조절하는 데 유용하게 사용되며, 다양한 응용 분야에서 활용된다.

# 8.3.2. 회전 변환행렬
회전 변환행렬은 객체나 벡터를 특정 각도만큼 회전시키기 위해 사용되는 행렬이다.  
이 행렬은 객체의 방향을 바꾸거나 좌표계를 회전시키는데 사용된다.    
회전 변환행렬은 선형 변환 행렬의 일종으로, 주어진 행렬과 원본 벡터 또는 객체를 곱하여 회전된 결과를 얻는 과정으로 작용한다.

2D 공간에서의 회전 변환행렬은 다음과 같은 형태를 가진다:
$$R = \begin{bmatrix} \cos(\theta) & -\sin(\theta) \\ \sin(\theta) & \cos(\theta) \end{bmatrix}$$

여기서 $\theta$는 회전 각도이다.    
이 회전 변환행렬은 시계방향으로 회전하는 경우에는 각도 $\theta$가 양수이며, 반시계반향으로 회전하는 경우에도 각도 $-\theta$가 사용된다.

3D 공간에서는 축에 따라 회전 변환행렬이 다양한 형태를 가진다.   
주요한 회전 변환행렬로 다음과 같은 것들이 있다:

- X축 주위 회전:
$$R_x = \begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos(\theta) & -\sin(\theta) \\ 0 & \sin(\theta) & \cos(\theta) \end{bmatrix}$$

- Y축 주위 회전:
$$R_y = \begin{bmatrix} \cos(\theta) & 0 & \sin(\theta) \\ 0 & 1 & 0 \\ -\sin(\theta) & 0 & \cos(\theta) \end{bmatrix}$$

- Z축 주위 회전:
$$R_z = \begin{bmatrix} \cos(\theta) & -\sin(\theta) & 0 \\ \sin(\theta) & \cos(\theta) & 0 \\ 0 & 0 & 1 \end{bmatrix}$$

회전 변환행렬은 그래픽스, 로봇공학, 물리 시뮬레이션 등 다양한 분야에서 활용된다.    
객체의 방향을 조절하거나 3D 공간에서의 움직임을 모델링할 때 회전 변환행렬이 중요한 도구로 사용된다.

# 8.3.3. 전단 변환행렬
전단 변환행렬은 객체나 벡터를 특정 축 방향으로 변형하는 변환을 나타내는 행렬이다.   
이 변환은 객체의 모양을 뒤틀거나 늘이는데 사용된다.     
전단 변환행렬은 선형 변환 행렬의 한 형태로, 주어진 행렬과 원본 벡터 또는 객체를 곱하여 변환된 결과를 얻는 과정으로 작용한다.

2D 공간에서의 전단 변환행렬은 다음과 같은 형태를 가진다:
$$SH = \begin{bmatrix} 1 & sh_x \\ sh_y & 1 \end{bmatrix}$$

여기서 $sh_x$는 $x$축 방향으로의 전단 계수이며, $sh_y$는 $y$축 방향으로의 전단 계수이다.    
전단 변환행렬은 원본 객체의 점들을 해당 축 방향으로 이동시키는 역할을 한다.

3D 공간에서도 각 축에 대한 전단 변환행렬이 있으며, 이는 해당 축에 대한 이동 변환이 이루어짐을 나타낸다.

전단 변환행렬은 다양한 분야에서 사용된다:

1. 그래픽스: 객체나 이미지를 뒤틀거나 변형시키는 데 사용된다.   
에를 들어, 텍스트나 이미지를 특정 각도로 기울이는 데 활용된다.
2. 컴퓨터 비전: 이미지 처리와 패턴 인식에서 이미지의 형태를 변형하거나 조정하는 데 사용된다.

전단 변환행렬은 객체나 벡터의 형태를 뒤틀거나 늘이는 데 활용되며, 다양한 응용 분야에서 사용되는 중요한 변환 중 하나이다.

# 8.4. 역행렬
역행렬(Inverse Matrix)은 주어진 정방행렬(행과 열의 개수가 같은 행렬)의 곱으로 항등행렬이 되는 행렬을 말한다.    
즉, 행렬 $A$의 역행렬 $A^{-1}$은 다음 조건을 만족하는 행렬이다:

$A \cdot A^{-1} = A^{-1} \cdot A = I$

여기서 $I$는 항등행렬(identity matrix)을 나타낸다.  
역행렬을 구하는 것은 주어진 행렬로부터 역변환을 수행하는 과정으로, 선형 변환의 역변환을 구하는 데에 중요한 역할을 한다. 

행렬 $A$의 역행렬 $A^{-1}$이 존재하려면 몇 가지 조건을 만족해야 한다:

1. 행렬 $A$는 정방행렬이어야 한다: 역행렬은 정방행렬에 대해서만 정의된다.   
즉, 행과 열의 개수가 같은 행렬이어야 한다.
2. 행렬 $A$는 풀랭크(full rank)여야 한다: 행렬 $A$의 역행렬이 존재하려면 $A$가 선형 독립인 행(또는 열) 벡터들로 이루어져 있어야 한다.
3. 행렬 $A$의 행렬식(determinant)이 0이 아니어야 한다: 만약 $A$의 행렬식이 0이라면, 역행렬은 존재하지 않는다.

역행렬은 다양한 응용 분야에서 중요한 역할을 한다.   
선형 방정식의 해를 구하는데 사용되거나, 선형 변환의 역변환을 계산하거나, 데이터 분석과 최적화 문제를 해결하는 데에 활용된다.    
하지만 모든 정방행렬이 역행렬을 갖는 것으 아니며, 역행렬이 존재하지 않을 수도 있다.

# 8.4.1. 역행렬의 존재를 판별하는 행렬식
역행렬의 존재를 판별하는 주요한 기준 중 하나는 행렬식(Determinant)을 사용하는 것이다.   
행렬식은 정방행렬(행과 열의 개수가 같은 행렬)의 성질을 나타내는 값으로, 역행렬의 존재 여부와 관련된 중요한 정보를 제공한다.

만약 행렬 $A$가 $n \times n$ 크기의 정방행렬이라면, $A$의 역행렬이 존재하려면 그리고 그럴 때에만, $A$의 행렬식이 0이 아니어야 한다.

수식으로 나타내면 다음과 같다:

If $det(A) \neq 0$, then $A^{-1}$ exits.

이 조건을 만족하지 않는 경우, 즉 $det(A) = 0$인 경우에는 역행렬이 존재하지 않는다.

행렬식은 다양한 방법으로 계산할 수 있지만, 주로 가우스 소거법이나 행렬의 특성값과 특성벡터를 활용하여 계산한다.     
행렬식은 행렬의 선형 변환에 따른 부피 변화를 나타내는 값으로 이해할 수 있다.    
따라서 역행렬이 존재하려면 원본 공간의 부피가 변환된 공간의 부피와 같아야 한다.

# 8.4.2. 크기 변환행렬의 역행렬
크기 변환행렬의 역행렬은 원본 객체나 벡터의 크기를 원래의 크기로 돌리기 위해 사용되는 역변환 행렬이다.  
역행렬은 이전에 적용한 변환을 원래대로 되돌리는 역할을 하며, 크기 변환에 대한 역변환을 구하는 데 활용된다.

2D 공간에서의 크기 변환행렬은 다음과 같다:
$$S = \begin{bmatrix} s_x & 0 \\ 0 & s_y \end{bmatrix}$$

역행렬 $S^{-1}$은 다음과 같다:
$$S^{-1} = \begin{bmatrix} \frac{1}{s_x} & 0 \\ 0 & \frac{1}{s_y} \end{bmatrix}$$

여기서 $s_x$와 $s_y$는 원래 크기 대비 확대 또는 축소 비율이다.  
역행렬을 적용하면 이전의 크기 변환을 원래대로 돌릴 수 있다.

3D 공간에서도 크기 변환행렬과 역행렬의 개념이 유사하게 적용된다.    
3D 공간에서의 크기 변환행렬은 각 축에 대해 크기 변환 비율을 지정하는 대각 행렬의 형태를 가지며, 역행렬은 각 축의 크기 변환 비율의 역수로 이루어진 대각 행렬이다.

크기 변환행렬의 역행렬은 객체나 벡터의 크기 변환을 원래대로 되돌리는 데에 활용되며, 그래픽스, 이미지 처리, 데이터 분석 등 다양한 분야에서 유용하게 사용된다.

# 8.4.3. 회전 변환행렬의 역행렬
회전 변환행렬의 역행렬은 원래의 회전을 되돌리는 데 사용되는 역변환 행렬이다.    
회전 변환행렬은 객체나 벡터를 특정 각도만큼 회전시키는 변환을 나타내며, 역행렬은 그 회전을 원래의 상태로 되돌리는데 활용된다.

2D 공간에서의 회전 변환행렬은 다음과 같다:
$$R = \begin{bmatrix} \cos(\theta) & -\sin(\theta) \\ \sin(\theta) & \cos(\theta) \end{bmatrix}$$

여기서 $\theta$는 회전 각도이다.    
역행렬 $R^{-1}$은 다음과 같다:
$$R^{-1} = \begin{bmatrix} \cos(-\theta) & -\sin(-\theta) \\ \sin(-\theta) & \cos(-\theta) \end{bmatrix} = \begin{bmatrix} \cos(\theta) & \sin(\theta) \\ -\sin(\theta) & \cos(\theta) \end{bmatrix}$$

따라서 역행렬은 원래의 회전 각도의 음수값으로 구성된다.     
이를 적용하면 원래의 회전을 원상태로 되돌릴 수 있다.

3D 공간에서도 회전 변환행렬과 역행렬의 개념이 유사하게 적용된다.    
3D 공간에서의 회전 변환행렬은 축 주위의 회전을 나타내며, 역행렬은 이 회전을 원래대로 되돌리는 역변환을 수행한다.

회전 변환행렬의 역행렬은 회전을 원래대로 되돌리는데 사용되며, 그래픽스, 로봇공학, 3D 모델링 등 다양한 분야에서 활용된다.

# 8.4.4. 전단 변환행렬의 역행렬
전단 변환행렬의 역행렬은 원래의 전단 변환을 되돌리는데 사용되는 역변환 행렬이다.    
전단 변환행렬은 객체나 벡터를 특정 축 방향으로 변형하는 변환을 나타내며, 역행렬은 그 변형을 원래대로 되돌리는 역할을 한다.

2D 공간에서의 전단 변환행렬은 다음과 같다:
$$SH = \begin{bmatrix} 1 & sh_x \\ sh_y & 1 \end{bmatrix}$$

전단 변환행렬의 역행렬 $SH^{-1}$은 다음과 같다:
$$SH^{-1} = \begin{bmatrix} 1 & -sh_x \\ -sh_y & 1 \end{bmatrix}$$

여기서 $sh_x$와 $sh_y$는 원래 전단 변환의 이동량을 나타냈다.    
역행렬을 적용하면 원래의 변형을 되돌릴 수 있다.

3D 공간에서도 각 축에 대한 전단 변환행렬과 역행렬의 개념이 유사하게 적용된다.   
3D 공간에서의 전단 변환행렬은 각 축 방향으로의 변형을 나타내며, 역행렬은 이 변형을 되돌리는 역변환을 수행한다.

전단 변환행렬의 역행렬은 객체나 벡터의 변형을 원래대로 되돌리는데 사용되며, 그래픽스, 이미지 처리, 데이터 분석 등 다양한 분야에서 활용된다.

# 8.4.5. 행렬 곱의 역행렬
두 개의 행렬을 곱할 때, 이 두 행렬의 곱의 역행렬은 각각의 행렬의 역행렬을 곱한 것과 같다.   
수식적으로 나타내면, 만약 $A$와 $B$라는 두 행렬이 있을 때, 다음과 같은 관계가 성립한다:

$(AB)^{-1} = B^{-1}A^{-1}$

이 관계는 행렬의 곱의 역행렬에 대한 중요한 성질 중 하나이다.

이러한 성질을 이해하기 위해서는 행렬의 곱셈과 역행렬의 정의를 이해하는 것이 중요하다.   
역행렬은 주어진 행렬의 곱으로 항등행렬이 나오도록 하는 행렬이며, 두 행렬의 곱의 역행렬은 각 행렬의 역행렬을 곱해서 얻을 수 있다.

이러한 성질을 활용하면 두 개의 행렬을 곱한 후에 역행렬을 구하는 경우, 두 행렬의 역행렬을 각각 구한 다음 순서를 바꿔서 곱하면 된다.  
이는 행렬 곱셈의 순서를 바꿀 수 없지만 역행렬을 구하는 순서를 바꿀 수 있기 때문에 가능한 것이다.

이 성질은 선형 대수학과 다양한 응용 분야에서 사용되며, 복잡한 행렬식을 간단하게 다룰 수 있는 도구 중 하나이다.

# 9. 아핀 공간
아핀 공간(Affine Space)은 벡터 공간(Vector Space)의 일반화된 개념으로, 점들 간의 상대적인 위치와 거리를 다루는 공간이다.    
아핀 공간은 벡터 덧셈을 통해 정의되며, 점과 점 사이의 차이 벡터의 개념을 사용하여 상대적인 위치를 표현한다.     
하지만 아핀 공간은 원점(영벡터)를 갖지 않으며, 벡터 공간의 원래 구조에서 원점을 제외한 것이라고 볼 수 있다.

아핀 공간의 특징은 다음과 같다:

1. 아핀 조합(Affine Combination): 주어진 점들에 대해 아핀 조합은 각 점과 그에 해당하는 가중치의 선형 조합을 의미한다.   
아핀 조합을 통해 아핀 공간 내의 새로운 점을 생성할 수 있다.
2. 점 간 거리와 상대적 위치: 아핀 공간에서는 점 간 거리보다는 점들 간의 상대적인 위치와 방향이 더 중요하다.     
따라서 점들 사이의 벡터 차이, 즉 차이 벡터를 통해 거리와 방향을 나타낼 수 있다.
3. 변환 및 이동: 아핀 공간에서는 점들에 대한 변환이나 이동(이동 변환)이 중요한데, 이는 아핀 변환(Affine Transformation)이라고 불린다.   
아핀 변환은 선형 변환과 이동 변환을 조합하여 점들 간의 상대적 위치와 거리를 보존하는 변환이며, 그래픽스와 컴퓨터 비전 분야에서 널리 사용된다.

아핀 공간은 그래픽스, 컴퓨터 비전, 기하학, 물리학 등 다양한 분야에서 활용되며, 점들 간의 상대적 위치와 변환을 다루는 데 유용한 개념이다.

# 9.1. 이동 변환을 위한 아핀 공간
이동 변환은 아핀 변환(Affine Transformation)의 한 형태로, 객체나 좌표를 특정 벡터만큼 이동 시키는 변환을 의미한다.  
이동 변환은 아핀 공간 내에서 점들의 위치를 변경시키는 작업을 나타낸다.  
이때, 이동 변환은 점들 간의 상대적인 위치와 방향을 보존하면서 이루어지며, 아핀 변환의 중요한 부분 중 하나이다.

아핀 공간에서의 이동 변환은 다음과 같은 특징을 가진다:

1. 벡터의 덧셈을 통한 이동: 이동 변환은 벡터의 덧셈을 통해 이루어진다.  
특정 벡터를 주어진 점들에 더함으로써 모든 점들을 동일한 벡터만큼 이동시킬 수 있다.
2. 상대적인 위치 보존: 이동 변환은 점들의 상대적인 위치와 방향을 보존한다.  
즉, 어떤 점에서 다른 점으로의 벡터 차이는 변환 전후에도 보존된다.
3. 변환 행렬: 이동 변환은 행렬로 표현되며, 이동 변환행렬은 대각 요소가 1이고 나머지 요소가 0인 항등 행렬과 벡터의 덧셈으로 구성된다.

2D 아핀 공간에서의 이동 변환행렬은 다음과 같다:
$$T = \begin{bmatrix} 1 & 0 & t_x \\ 0 & 1 & t_y \\ 0 & 0 & 1 \end{bmatrix}$$

여기서 $(t_x, t_y)$는 이동할 벡터를 나타낸다.

3D 아핀 공간에서도 유사한 원리로 이동 변환행렬을 구성할 수 있다.

이동 변환은 그래픽스, 컴퓨터 비전, 로봇공학 등에서 다양하게 활용되며, 객체나 좌표의 위치를 조절하는 데에 중요한 역할을 한다.

# 9.2. 아핀 공간의 구성 요소
아핀 공간은 다양한 구성 요소로 이루어진 개념적인 공간이다.  
이 공간은 점들 간의 상대적인 위치와 변환이 중요하며, 다음과 같은 구성 요소를 가지고 있다:

1. 점(Point): 아핀 공간의 기본 단위는 점이다.   
각 점은 좌표로 나타내며, 점들 간의 상대적인 위치를 다루는데 사용된다.
2. 벡터(Vector): 아핀 공간에서의 벡터는 한 점에서 다른 점으로의 방향과 거리를 표현하는 데 사용된다.     
벡터는 점들 간의 차이를 표현하는 데 활용되며, 이동 변환과 같은 작업에 중요한 역할을 한다.
3. 아핀 조합(Affine Combination): 아핀 조합은 점들 간의 가중치를 고려한 선형 조합을 의미한다.   
즉, 주어진 점들과 그에 해당하는 가중치를 조합하여 새로운 점을 생성하는데 사용된다.
4. 아핀 변환(Affine Transformation): 아핀 변환은 점들 간의 상대적인 위치와 거리를 보존하면서 변환을 수행하는 작업을 의미한다.   
이동 변환, 회전 변환, 크기 변환 등이 아핀 변환에 해당한다.
5. 아핀 공간의 차원(Dimension): 아핀 공간의 차원은 그 공간 내의 벡터의 개수를 나타낸다. 
2D 아핀 공간은 평면을, 3D 아핀 공간은 입체를 나타낸다.
6. 아핀 기하학(Affine Geometry): 아핀 공간 내에서 점들의 상대적인 위치와 변환에 관한 기하학적 개념을 다루는 분야이다.   
이동 변환, 회전 변환, 크기 변환 등의 아핀 변환을 다루며, 그래픽스와 기하학 분야에서 중요한 개념이다.

아핀 공간은 객체의 변환, 이미지 처리, 기하학적 모델링, 컴퓨터 비전 등 다양한 분야에서 사용되며, 점들 간의 상대적인 위치와 변환을 다루는 데 중요한 개념이다.

# 9.3. 아핀 결합
아핀 결합(Affine Combination)은 아핀 공간에서 주어진 점들과 그에 해당하는 가중치를 사용하여 새로운 점을 생성하는 작업을 의미한다.   
이 작업은 아핀 조합이라고도 불린다.     
아핀 결합은 벡터의 선형 결합과 유사한 개념이지만, 점들 간의 상대적인 위치와 변환이 중요한 아핀 공간에서 사용된다.

두 개 이상의 점 $P_1, P_2, ..., P_n$과 그에 해당하는 가중치 $w_1, w_2, ..., w_n$가 주어졌을 때, 이들을 아핀 결합하여 새로운 점 $Q$를 생성하는 수식은 다음과 같다:

$Q = w_1P_1 + w_2P_2 + ... + w_nP_n$

이 수식에서 각 가중치 $w_i$는 실수 값이며, 가중치의 합은 1이어야 한다: $w_1 + w_2 + ... + w_n = 1.$

아핀 결합은 점들 간의 상대적인 위치를 나타내는 중요한 개념이다.     
예를 들어, 세 점 $A, B, C$의 아핀 결합 $P = w_AA + w_BB + w_CC$는 이 세 점을 가중치 $w_A, w_B, w_C$에 따라 섞은 결과로, $P$의 위치는 $A, B, C$의 상대적인 위치에 의해 결정된다.

아핀 결합은 아핀 공간에서 다양한 작업에 사용된다.   
예를 들어, 선형 보간, 다각형의 내부 계산, 그리고 그래픽스에서 곡선의 표현 등에서 사용된다.

# 9.4. 선 그리기 알고리즘
아핀 공간에서 선 그리기 알고리즘은 주어진 두 점을 연결하여 직선을 그리는 과정을 나타내는 알고리즘이다.  
이 알고리즘은 컴퓨터 그래픽스 분야에서 매우 중요한 역할을 하며, 선분을 화면에 그리는 데에 사용된다.     
여러 선 그리기 알고리즘이 개발되었는데, 그 중 가장 간단한 것 중 하나는 Bresenham's Line Algorithm이다.

Bresenham's Line Algorithm은 점 $P(x_1, y_1)$와 점 $Q(x_2,y_2)$를 연결하여 선을 그리는 알고리즘이다.    
이 알고리즘은 기울기가 0보다 작은 경우와 0보다 큰 경우, 그리고 두 점이 수직한 경우 등을 모두 처리할 수 있다.    
알고리즘의 핵심은 픽셀 간의 거리와 기울기를 이용하여 어떤 픽셀을 선택할지 결정하는 것이다.

Bresenham's Line Algorithm의 간략한 설명은 다음과 같다:

1. 두 점 $P(x_1,y_1)와 $Q(x_2,y_2)$를 입력으로 받는다.
2. 점 $P$를 기준으로 시작하며, 각 단계마다 픽셀을 선택하고 다음 픽셀을 결정한다.
3. 기울기를 기준으로 직선의 방향을 결정하고, 픽셀 간의 거리를 이용하여 다음 픽셀의 위치를 선택한다.
4. 직선의 방향에 따라 x 좌표 또는 y 좌표를 하나씩 증가시키면서 픽셀을 선택한다.

이 알고리즘은 계산량이 적고, 단순한 방식으로 선을 그릴 수 있어서 과거에는 많이 사용되었다.  
하지만 현대의 그래픽스 하드웨어은 더 정교한 알고리즘을 사용하며, 더 부드럽고 정교한 선을 그릴 수 있게 되었다.   

# 9.4.1. 벡터를 모니터의 점으로 표현
아핀 공간에서 벡터를 모니터의 점으로 표현하는 과정은 컴퓨터 그래픽스에서 벡터를 화면 상에 표현하는 작업을 의미한다.     
이 작업은 컴퓨터 그래픽스 애플리케이션에서 객체나 도형을 화면에 그릴 때 사용된다.

일반적으로 모니터나 디스플레이는 그리드 형태의 픽셀로 구성되어 있다.    
각 픽셀은 특정 색상을 가지며, 이러한 픽셀을 조합하여 그림을 만들어낸다.     
이때 아핀 공간의 벡터를 모니터의 픽셀 좌표로 변환하는 과정은 다음과 같이 진행된다:

1. 모델 좌표 변환(Model Coordinate Transformation): 객체나 도형의 모델 좌표를 정의한다.     
이 모델 좌표는 일반적으로 상대적인 크기 및 위치 정보를 가지고 있다.
2. 월드 좌표 변환(World Coordinate Transformation): 모델 좌표를 월드 좌표로 변환한다.   
월드 좌표는 전체 그래픽스 공간에서 객체의 위치와 방향을 나타낸다.   
이 단계에서 크기 변환, 회전 변환, 이동 변환 등을 수행할 수 있다.
3. 뷰포트 변환(Viewport Transformation): 월드 좌표를 실제 화면의 뷰포트 좌표로 변환한다.    
이때 뷰포트는 화면 상에서 어떤 영역에 그림을 그릴 것인지를 지정하는 영역이다.   
뷰포트 변환은 월드 좌표를 화면에 맞는 좌표로 조정한다.
4. 투영 변환(Projection Transformation): 뷰포트 변환된 좌표를 2D 투영 좌표로 변환한다.  
이 단계에서 원근감을 추가하여 3D 공간을 2D 화면에 표현할 수 있다.
5. 디바이스 좌표 변환(Device Coordinate Transformation): 투영된 2D 좌표를 디바이스 좌표로 변환한다.     
디바이스 좌표는 실제 모니터나 디스플레이의 픽셀 좌표를 의미한다.
6. 클리핑과 래스터화(Clipping and Rasterization): 디바이스 좌표로 변환된 객체들을 화면에 표시할 영역 내에서 잘라내고, 픽셀 단위로 변환하여 표시될 부분을 결정한다.
7. 색칠 및 그림 그리기: 래스터화된 픽셀들에 색상을 할당하고, 필요한 그림을 화면에 그린다.

3D 벡터를 모니터의 점으로 표현하는 과정은 복잡한 계산과 변환을 포함하지만, 그 결과로 3D 객체를 2D 화면에서 시각적으로 표현할 수 있게 된다.  
이러한 과정을 그래픽스 파이프라인이라고 부르며, 그래픽스 애플리케이션에서 3D 시각화를 구현하는 핵심 과정 중 하나이다.

# 9.4.2. 라인 클리핑 알고리즘
아핀 공간에서의 라인 클리핑 알고리즘은 주어진 라인 또는 선분을 특정 영역 내로 잘라내는 작업을 의미한다.     
이는 그래픽스에서 화면에 표시할 범위 내에 있는 객체를 제외한 부분을 제거하는 작업으로, 특히 2D 그래픽스에서 중요한 역할을 한다.     
여러 라인 클리핑 알고리즘이 개발되었는데, 그 중에는 Cohen-Sutherland 알고리즘과 Liang-Barsky 알고리즘이 널리 사용된다.

Cohen-Sutherland 알고리즘은 2D 공간을 9개의 영역으로 나누고, 라인의 각 점을 이 영역에 따라 분류하는 방식을 사용한다.    
이때, 화면 영역과 라인의 각 점이 어느 영역에 속하는지를 판별하여 영역 내에 있는 점을 선택하거나, 화면 영역 밖에 있는 점을 제거하여 라인을 잘라낸다.     
이 알고리즘은 빠르고 간단한 방식으로 클리핑을 수행할 수 있다.

Liang-Barsky 알고리즘은 Cohen-Sutherland 알고리즘보다 좀 더 정교한 방법으로 라인 클리핑을 수행한다.     
이 알고리즘은 화면 영역을 벗어나지 않는 라인 세그먼트에 대해 더 정확한 클리핑을 수행할 수 있다.     
Liang-Barsky 알고리즘은 라인의 각 점이 화면 영역 밖에 있는지, 내부에 있는지를 판별하여 클리핑을 수행하며, 계산량이 좀 더 복잡하지만 정교한 결과를 제공한다.

라인 클리핑 알고리즘은 그래픽스 애플리케이션에서 뷰포트 내에 있는 부분만을 처리하고 불필요한 계산을 줄이는 데에 중요한 역할을 한다.     
이를 통해 객체들을 효율적으로 화면에 표시할 수 있게 된다.

# 10. 메시
컴퓨터 그래픽스에서의 "메시"는 3D 객체를 구성하는 정점(Vertex)과 그 정점들을 연결하는 면(Face)으로 이루어진 구조를 의마한다.    
메시는 3D 모델을 표현하고 저장하기 위한 중요한 개념으로, 그래픽스 애플리케이션에서 다양한 객체를 만들고 표현하는 데 사용된다.

메시는 다음과 같은 요소로 구성된다:

1. 정점(Vertex): 정점은 3D 공간 상의 하나의 점을 나타낸다.  
각 정점은 위치 좌표(x,y,z)를 포함하여, 종종 색상, 텍스처 좌표, 법선 벡터 등의 추가 정보도 포함할 수 있다.   
정점은 3D 모델의 모양과 성질을 결정하는데 중요한 역할을 한다.
2. 면(Face): 면은 정점들의 연결로 구성되며, 이 연결을 통해 실제 객체의 표면을 나타낸다.     
3D 모델을 만들 떄 면들을 조합하여 객체의 형태를 결정하며, 이때 면의 종류에 따라 삼각형(Triangle), 사각형(Quadrilateral) 등이 사용될 수 있다.
3. 인덱스(Index): 메시의 정점을 저장할 때 중복되는 정점을 줄이고 메모리 사용량을 최적화하기 위해 인덱스를 사용하는 경우가 있다.     
이는 정점들의 순서를 인덱스로 참조하여 면을 구성하는 방식이다.
4. 텍스처 좌표(Texture Coordinates): 객체에 텍스처를 입히기 위해 각 정점에 텍스처의 어느 부분을 매핑할 것인지를 나타내는 좌표이다.

메시는 컴퓨터 그래픽스에서 3D 모델을 표현하고 처리하는 핵심적인 구조이다.   
메시를 이용하면 다양한 형태의 객체와 표면을 생성하고 조작할 수 있으며, 조명, 재질, 텍스처 등을 적용하여 현실적이고 다양한 시각적 효과를 구현할 수 있다.     
메시의 분할, 변환, 클리핑, 래스터화 등의 작업은 그래픽스 파이프라인의 중요한 단계 중 하나이다.

# 10.1. 무게중심좌표
메시의 무게중심좌표는 3D 메시(3D 모델의 정점과 면으로 이루어진 구조) 내의 정점들의 무게를 고려하여 계산된 평균 위치를 나타내는 좌표이다.    
이는 메시가 어디에 위치하며 어떻게 균형을 이루는지를 나타내는 중요한 개념이다.

메시의 무게중심좌표를 계산하는 방법은 다음과 같다:

1. 정점의 무게(weight) 계산: 각 정점은 일반적으로 추가 정보인 무게(weight)를 가지고 있다.   
이 무게는 해당 정점이 메시의 무게중심에 얼마나 기여하는지를 나타내는 값이다.    
이 값은 주로 정점의 면적, 부피, 질량 등과 관련되며, 그래픽스 애플리케이션에 따라 다르게 정의될 수 있다.
2. 무게중심 계산: 메시의 모든 정점들의 무겔르 사용하여 각 좌표 축(x,y,z)에 대한 가중 평균을 계산한다.   
이를 통해 메시의 무게중심 좌표가 구해진다.

메시의 무게중심은 물리 시뮬레이션, 모델의 배치 및 애니메이션, 그리고 렌더링 등 다양한 그래픽스 작업에서 활용될 수 있다.

# 10.2. 정점에 설정된 부가 정보의 활용
메시 정점에 설정된 부가 정보는 3D 모델의 정점에 대한 추가적인 데이터를 의미한다.    
이러한 정보는 그래픽스 애플리케이션에서 다양한 목적으로 활용될 수 있다.     
아래는 메시 정점에 설정된 부가 정보의 일부 활용 예시이다:

1. 색상 정보: 정점마다 특정 색상 정보를 가질 수 있다.   
이를 활용하여 3D 모델의 다양한 부분에 다른 색상을 입힐 수 있다.     
예를 들어, 각 정점을 다른 색상으로 설정하여 물체를 다채롭게 표현하거나, 그라데이션 효과를 만들 수 있다.
2. 텍스처 좌표: 정점에 텍스처 좌표를 할당하여 텍스처 이미지의 어느 부분을 정점에 매핑할 것인지를 지정할 수 있다.    
이를 통해 3D 모델에 텍스처를 입히거나, 물체의 일부에만 특정 이미지를 입힐 수 있다.
3. 법선 벡터: 정점에 법선 벡터를 할당하여 면의 방향과 표면 노말을 정의할 수 있다.   
법선 벡터는 조명과 그림자 계산, 셰이딩 등의 작업에서 중요한 역할을 한다.
4. 애니메이션 정보: 애니메이션을 위해 정점마다 변형 정보를 설정할 수 있다.  
이를 활용하여 모델의 움직임이나 변형을 지정할 수 있다.  
예를 들어, 캐릭터의 관절 부분을 움직이는 애니메이션에 사용될 수 있다.
5. 추가 속성 정보: 정점에는 위에서 언급한 것 외에도 다양한 추가 정보를 할당할 수 있다.  
예를 들어, 투명도 정보, 반사도 정보, 표면의 거칠기 정보 등을 정점에 설정하여 렌더링 효과를 조작할 수 있다.

이러한 부가 정보는 그래픽스 애플리케이션에서 시각적인 다양성을 확보하고 더 현실적인 결과물을 얻기 위해 사용된다.    
다양한 효과를 표현하거나 모델의 시각적 품질을 향상시키는 데 활용되며, 모델의 다양한 특성을 정밀하게 제어하는 데 중요힌 역할을 한다.

# 10.3. 텍스처 매핑
텍스처 매핑은 3D 그래픽스에서 객체의 표면을 텍스처 이미지로 입히는 작업을 의미한다.     
이를 통해 객체에 디테일한 색상, 패턴, 이미지 등을 추가하여 더 현실적이고 다양한 시각적 효과를 구현할 수 있다.   

텍스처 매핑은 주로 다음과 같은 단계로 이루어진다:

1. 텍스처 생성: 텍스처 매핑을 위해서는 먼저 텍스처 이미지를 준비해야 한다.  
이 이미지는 보통 JPEG, PNG 등의 형식으로 저장되며, 객체의 표면에 표시할 디테일이나 색상 정보가 포함된다.
2. 텍스처 좌표 설정: 메시의 각 정점에 텍스처 좌표를 할당한다.   
텍스처 좌표는 텍스처 이미지 상에서 어떤 부분을 해당 정점에 매핑할 것인지를 나타내는 값이다.     
텍스처 좌표는 일반적으로 (u,v) 좌표로 표현되며, 각 정점마다 해당 텍스처의 어느 부분을 사용할 것인지를 지정한다.
3. 텍스처 매핑 계산: 텍스처 좌표를 기반으로 실제 텍스처 이미지에서 해당 위치의 색상을 가져온다.     
이를 활용하여 각 정점에서 텍스처의 색상을 보간하여 표면 상에 텍스처를 입힌다.
4. 셰이딩과 조명 적용: 텍스처 매핑된 표면에 빛의 조명이나 그림자 효과 등을 적용하여 현실적인 느낌을 만들어낸다.     
텍스처 매핑은 그림자와 반사 등을 시뮬레이션하기 위해 사용되는 데 중요한 역할을 한다.

텍스처 매핑은 게임 그래픽스, 가상현실, 시뮬레이션 등 다양한 분야에서 사용된다.  
객체의 표면을 현실적으로 보이게 하거나 특정 효과를 구현하는 데 유용하며, 텍스처의 다양한 매핑 기법과 효과를 조합하여 다양한 시각적 품질을 얻을 수 있다.

# 11. 게임 엔진
수학은 게임 엔진의 핵심적인 요소로 사용되며 다양한 게임 시스템과 시각적 효과를 구현하는 데 필수적이다.  
아래는 수학과 게임 엔진 간의 연관성에 대한 설명이다:

1. 3D 그래픽스 및 물리 시뮬레이션: 게임은 보통 3D 공간에서 동작하는데, 3D 그래픽스를 구현하기 위해서는 선형 대수학과 행렬 연산을 활용해야 한다.     
이를 통해 객체의 변환, 회전, 크기 조절 등을 구현하고 물체의 충돌, 운동 등을 모델링하는 데 사용된다.
2. 벡터 및 행렬 연산: 게임에서는 객체의 위치, 방향, 속도 등을 다차원 공간에서 표현해야 한다.    
이를 위해 벡터와 행렬 연산이 사용되며, 게임 엔진은 이러한 연산을 효율적으로 처리하는 데 중요한 역할을 한다.
3. 물리 엔진: 게임에서 물리 시뮬레이션은 중요한 요소 중 하나이다.   
물리 엔진은 물체의 운동, 중력, 충돌, 힘의 적용 등을 모델링하여 현실적인 동작을 구현한다.    
이를 위해 뉴터의 운동 법칙, 적분, 미분 등의 수학적 개념이 활용된다.
5. 조명과 셰이딩: 게임에서는 조명과 셰이딩을 통해 그래픽스의 현실감을 높이는 데 수학적인 계산이 필요하다.   
광원의 위치, 표면의 법선 벡터, 재질의 반사 특성 등을 고려하여 조명 효과를 계산한다.
6. 데이터 구조와 알고리즘: 게임은 대량의 데이터를 효율적으로 처리해야 한다.     
데이터 구조와 알고리즘을 통해 빠른 렌더링, 충돌 감지, 경로 탐색 등을 구현한다.
7. 수학적 시뮬레이션: 게임에서는 현실적인 상황을 시뮬레이션하기 위해 수학적 모델을 사용한다.    
경기장의 물리, 인공지능 행동, 경제 시뮬레이션 등 다양한 분야에서 수학적 모델링이 사용된다.

게임 엔진은 이러한 수학적 개념과 기술을 모아 효율적으로 동작하도록 설계된다.

# 11.1. 게임 엔진의 구성 요소
게임 엔진은 복잡한 시스템으로, 다양한 기능을 수행하기 위해 여러 구성 요소로 나누어진다.     
아래는 대표적인 게임 엔진의 구성 요소들이다:

1. 렌더링 엔진(Rendering Engine): 그래픽 처리를 담당하는 부분으로, 3D 렌더링, 쉐이딩, 조명, 텍스처 매핑 등을 수행한다.  
2D 및 3D 객체를 화면에 렌더링하여 시각적인 효과를 만든다.
2. 물리 엔진(Physics Engine): 물리 시뮬레이션을 다루는 부분으로, 물체의 운동, 충돌, 중력 등을 모델링하여 현실적인 동작을 시뮬레이션한다.
3. 애니메이션 엔진(Animation Engine): 캐릭터 및 객체의 애니메이션을 제어하고, 보간(interpolation) 기술을 사용하여 부드러운 모션을 생성한다.
4. 사운드 엔진(Sound Engine): 게임 내의 음향 효과, 배경 음악 등을 재생하고 관리한다.    
3D 위치음향, 음향 효과 등을 다룬다.
5. 인풋 엔진(Input Engine): 사용자 입력을 처리하고, 키보드, 마우스, 조이스틱 등의 입력 장치와 상호작용한다.
6. 인공지능 엔진(Artificial Intelligence Engine): NPC(non-player character)의 행동을 조절하고, 경로 탐색, 의사 결정 등을 다루어 인공지능을 시뮬레이션한다.
7. 씬 그래프(Scene Graph): 게임 내의 객체들의 계층 구조와 관계를 나타내는 구성 요소로, 객체의 위치, 회전, 스케일 등을 관리한다.
8. 자원 관리(Resource Management): 텍스처, 모델, 사운드 파일 등 게임에 사용되는 자원들을 관리하고 로드하여 사용한다.
9. 데이터베이스 관리(Database Management): 게임의 상태, 플레이어 정보, 저장된 데이터 등을 관리하며 필요한 데이터를 저장 및 검색한다.
10. 데이터 시스템(Data System): 게임 내에서 사용되는 데이터의 구조와 관리를 담당하며, 게임의 설정, 레벨 디자인, 스토리 등을 저장하고 조작한다.
11. UI 엔진(User Interface Engine): 게임의 사용자 인터페이스 요소를 디자인하고 관리한다.    
메뉴, 버튼, 텍스트 등을 표시하고 상호 작용할 수 있게 한다.
12. 파일 시스템(File System): 게임 파일들을 읽고 쓰며, 자원들의 경로와 저장 위치를 관리한다.

게임 엔진은 이러한 구성 요소들을 통합하여 게임을 개발하고 실행하는 환경을 제공한다.     
이들 요소는 서로 협력하여 게임의 시각적, 음향적, 물리적 요소를 통합하고 게임 플레이어에게 원활한 경험을 제공하는 데 기여한다.

# 11.1.1. 씬의 구조
씬(Scene)의 구조와 수학은 게임 개발에서 중요한 역할을 하는데, 수학은 씬 내의 객체의 위치, 변환, 렌더링, 물리 시뮬레이션 등을 다루는 데 필수적이다.  
아래는 씬의 구조와 수학의 연관성에 대한 설명이다:

1. 객체의 위치와 변환(Transformations): 씬 내의 객체는 3D 공간 상에서 위치하며, 이들 객체의 위치, 회전, 크기 조절 등의 변환은 수학적 행렬 연산을 통해 이루어진다.   
이동 변환, 회전 변환, 크기 변환 등을 표현하고 조직화하기 위해 선형 대수학의 행렬과 벡터 연산이 사용된다.
2. 뷰 프로젝션(View Projection): 객체가 3D 공간에서 화면에 투영되는 과정에서 수학적 프로젝션 변환을 사용한다.   
이를 통해 카메라 시점에 따라 객체의 3D 좌표를 2D 화면 좌표로 변환하며, 플레이어의 시야를 시뮬레이션한다.
3. 렌더링(Rendering): 씬 내의 객체를 렌더링하기 위해서는 객체의 변환, 조명, 재질, 텍스처 매핑 등이 필요하다.    
이들 요소를 조합하여 물체의 표면을 계산하고 화면에 그리는데, 이 과정에서 선형 대수학 및 행렬 연산이 사용된다.
4. 물리 시뮬레이션(Physics Simulation): 물리 시뮬레이션은 씬 내의 물체의 운동, 충돌, 중력 등을 모델링한다.  
뉴턴의 운동 법칙, 적분, 미분 등의 수학적 개념을 활용하여 객체의 동작을 시뮬레이션한다.
5. 수학적 보간(Interpolation): 애니메이션과 보간은 씬 내의 객체의 움직임을 부드럽게 만드는 데 사용된다.     
베지어 곡선, 쿼터니언 등의 수학적 보간 기법을 활용하여 객체의 변화를 조절한다.
6. 콜리전 검출(Collision Detection): 씬 내의 객체 간의 충돌을 검출하려면 수학적 계산이 필요하다.    
객체의 형상을 기반으로 충돌을 감지하고 처리하는데 수학적 알고리즘이 사용된다.
7. 좌표 변환(Coordinate Transformations): 씬 내에서 다양한 좌표계를 사용해야 할 때, 좌표 변환을 수행한다.   
이는 객체를 다른 공간으로 이동시키거나 회전시키는 등의 작업에 사용된다.
8. 상호 작용과 위치 계산(Interaction and Position Calculation): 사용자 입력과 게임 객체의 상호 작용은 수학적 계산을 통해 이루어진다.    
마우스 클릭 위치의 화면 좌표를 3D 공간의 객체 위치로 변환하는 등의 작업에서 수학이 활용된다.

씬 내의 수학적 계산은 게임 엔진의 다양한 구성 요소에서 필수적으로 사용되며, 게임의 시각적, 물리적, 상호 작용적 요소들을 제어하는 데 중요한 역할을 한다.